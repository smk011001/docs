{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Flare Network Technical Documentation","text":"<p>New here? Start with What Is Flare?</p> <ul> <li> Flare Fundamentals  Descriptions of Flare's key concepts, technology and tools. </li> <li> User Guides  Step-by-step guides for tools like the Explorer or the different wallets.</li> <li> Infrastructure Guides  Step-by-step guides to deploy your own Flare network components.</li> <li> Exchange Guides  Advice for exchanges willing to support the Flare blockchain.</li> <li> Developer Docs  Programming tutorials to help you build your app using Flare's tech.</li> <li> API Reference Guides  API documentation and access RPC nodes.</li> </ul> <p>These pages are a Work In Progress. Use the contact buttons at the bottom of the page if there is anything you cannot find here!</p>"},{"location":"apis/","title":"APIs","text":"<p>Select one of the topics below:</p>"},{"location":"apis/#flare-api-documentation","title":"Flare API Documentation","text":"<ul> <li>Smart Contracts API (Work in progress)</li> </ul>"},{"location":"apis/#external-documentation","title":"External Documentation","text":"<ul> <li>web3.js API</li> <li>ethers.js API</li> </ul> <p>Access Nodes</p> <ul> <li>Public RPC nodes for Flare, Songbird and Coston.</li> <li>Public RPC nodes for connected chains</li> <li>Flare API Portal (private nodes)</li> </ul>"},{"location":"apis/smart-contracts/","title":"Smart Contracts API","text":"<p>List of Flare smart contracts.</p>"},{"location":"apis/smart-contracts/#contracts","title":"Contracts","text":"Name Description <code>AddressUpdatable</code> Abstract base class for contracts that depend on other contracts whose addresses can change. <code>AddressUpdater</code> Keeps track of the current address for all unique and special platform contracts. <code>CheckPointable</code> Check-Pointable ERC20 Behavior. <code>ClaimSetupManager</code> Manages automation of operations related to reward claiming. <code>CleanupBlockNumberManager</code> Token history cleanup manager. <code>CloneFactory</code> Simple clone contract factory. <code>Delegatable</code> <code>Delegatable</code> ERC20 behavior. <code>FlareContractRegistry</code> The Flare contract registry. <code>FlareDaemon</code> Flare Daemon contract. <code>Ftso</code> Flare Time Series Oracle contract. <code>FtsoManager</code> FTSO Manager contract. <code>FtsoRegistry</code> Handles registration of assets to the FTSO system. <code>FtsoRewardManager</code> Handles reward distribution and claiming related to the FTSO system. <code>GovernanceSettings</code> A special contract that holds the Flare governance address and its timelock. <code>GovernanceVotePower</code> Contract managing governance vote power and its delegation. <code>Governed</code> Defines behaviors for governed contracts that must have a governor set at construction-time. <code>GovernedAndFlareDaemonized</code> Base class for contracts that are governed and triggered from the <code>FlareDaemon</code>. <code>GovernedAtGenesis</code> Defines behaviors for governed contracts that have their governor set at genesis. <code>GovernedBase</code> Abstract base class that defines behaviors for governed contracts. <code>Inflation</code> Recognizes, authorizes, mints, and funds native tokens to Flare services that are rewardable through inflation. <code>PriceSubmitter</code> Receives prices from FTSO data providers. <code>RevertErrorTracking</code> Revert error tracking contract. <code>VoterWhitelister</code> Manager of the FTSO whitelist. <code>VPContract</code> Helper contract handling all the vote power and delegation functionality for an associated <code>VPToken</code>. <code>VPToken</code> Vote power token. <code>WNat</code> Wrapped native token."},{"location":"apis/smart-contracts/#interfaces","title":"Interfaces","text":"Name Description <code>IClaimSetupManager</code> Public interface for the <code>ClaimSetupManager</code> contract. <code>IFlareContractRegistry</code> Interface for the <code>FlareContractRegistry</code>. <code>IFlareDaemonize</code> Interface for contracts that receive triggers from the <code>FlareDaemon</code> contract. <code>IFtso</code> Interface for each of the FTSO contracts that handles an asset. <code>IFtsoGenesis</code> Portion of the <code>IFtso</code> interface that is available to contracts deployed at genesis. <code>IFtsoManager</code> Interface for the <code>FtsoManager</code> contract. <code>IFtsoManagerGenesis</code> Portion of the <code>IFtsoManager</code> interface that is available to contracts deployed at genesis. <code>IFtsoRegistry</code> Interface for the <code>FtsoRegistry</code> contract. <code>IFtsoRegistryGenesis</code> Portion of the <code>IFtsoRegistry</code> interface that is available to contracts deployed at genesis. <code>IFtsoRewardManager</code> Interface for the <code>FtsoRewardManager</code> contract. <code>IGovernanceSettings</code> Interface for the <code>GovernanceSettings</code> that hold the Flare governance address and its timelock. <code>IGovernanceVotePower</code> Interface for contracts delegating their governance vote power. <code>IInflationGenesis</code> Portion of the <code>Inflation</code> contract that is available to contracts deployed at genesis. <code>IPriceSubmitter</code> Interface for the <code>PriceSubmitter</code> contract. <code>IVoterWhitelister</code> Interface for managers of the FTSO whitelist. <code>IVPContractEvents</code> Events interface for vote-power related operations. <code>IVPToken</code> Vote power token interface. <code>IWNat</code> Wrapped native token interface."},{"location":"apis/smart-contracts/#internal-interfaces","title":"Internal Interfaces","text":"<p>For platform development, not application.</p> Name Description <code>IIAddressUpdatable</code> Internal interface for contracts that depend on other contracts whose addresses can change. <code>IIAddressUpdater</code> Internal interface for <code>AddressUpdater</code>. <code>IIClaimSetupManager</code> Internal interface for the <code>ClaimSetupManager</code> contract. <code>IICleanable</code> Internal interface for entities that can have their block history cleaned. <code>IIFtso</code> Internal interface for each of the FTSO contracts that handles an asset. <code>IIFtsoManager</code> Internal interface for the <code>FtsoManager</code> contract. <code>IIFtsoRegistry</code> Internal interface for the <code>FtsoRegistry</code> contract. <code>IIFtsoRewardManager</code> Internal interface for the <code>FtsoRewardManager</code>. <code>IIGovernanceVotePower</code> Internal interface for contracts delegating their governance vote power. <code>IIInflationReceiver</code> Internal interface for contracts that can receive inflation. <code>IIPriceSubmitter</code> Internal interface for the <code>PriceSubmitter</code> contract. <code>IITokenPool</code> Internal interface for token pools. <code>IIVoterWhitelister</code> Internal interface for managers of the FTSO whitelist. <code>IIVPContract</code> Internal interface for helper contracts handling functionality for an associated <code>VPToken</code>. <code>IIVPToken</code> Vote power token internal interface."},{"location":"apis/smart-contracts/AddressUpdatable/","title":"AddressUpdatable","text":""},{"location":"apis/smart-contracts/AddressUpdatable/#ct_addressupdatable","title":"<code>AddressUpdatable</code>","text":"<p>Source | Inherits from IIAddressUpdatable</p> <p>Abstract base class for contracts that depend on other contracts whose addresses can change.</p> <p>The <code>AddressUpdater</code> contract keeps a list of addresses for all unique and special platform contracts. By inheriting from <code>AddressUpdatable</code> a contract will receive updates if any of the platform contract addresses change.</p> <p>A contract's address changes when it is redeployed, so <code>AddressUpdatable</code> offers a way to keep up to date with the latest address for all dependencies.</p>"},{"location":"apis/smart-contracts/AddressUpdatable/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/AddressUpdatable/#fn_getaddressupdater_5267a15d","title":"<code>getAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function getAddressUpdater(\n) public view returns (\n    address _addressUpdater);\n</code></pre> <p>Returns the configured address updater.</p> Returns Type Description <code>_addressUpdater</code> <code>address</code> The <code>AddresUpdater</code> contract that can update our contract address list, as a response to a governance call."},{"location":"apis/smart-contracts/AddressUpdatable/#fn_updatecontractaddresses_b00c0b76","title":"<code>updateContractAddresses</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function updateContractAddresses(\n    bytes32[] _contractNameHashes,\n    address[] _contractAddresses\n) external;\n</code></pre> <p>External method called from <code>AddressUpdater</code> only.</p>"},{"location":"apis/smart-contracts/AddressUpdatable/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/AddressUpdatable/#md_onlyaddressupdater","title":"<code>onlyAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>modifier onlyAddressUpdater()\n</code></pre> <p>Only the <code>AdressUpdater</code> contract can call this method. Its address is set at construction time but it can also update itself.</p>"},{"location":"apis/smart-contracts/AddressUpdatable/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/AddressUpdater/","title":"AddressUpdater","text":""},{"location":"apis/smart-contracts/AddressUpdater/#ct_addressupdater","title":"<code>AddressUpdater</code>","text":"<p>Source | Inherits from IIAddressUpdater, Governed</p> <p>Keeps track of the current address for all unique and special platform contracts.</p> <p>This contract keeps a list of addresses that gets updated by <code>governance</code> every time any of the tracked contracts is redeployed. This list is then used by the <code>FlareContractRegistry</code>, and also by <code>AddressUpdatable</code> to inform all dependent contracts of any address change.</p>"},{"location":"apis/smart-contracts/AddressUpdater/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/AddressUpdater/#fn_addorupdatecontractnamesandaddresses_8246e467","title":"<code>addOrUpdateContractNamesAndAddresses</code>","text":"<p>Defined in <code>AddressUpdater</code> (Docs, Source).</p> <pre><code>function addOrUpdateContractNamesAndAddresses(\n    string[] _contractNames,\n    address[] _contractAddresses\n) external;\n</code></pre> <p>Add or <code>update</code> contract names and addresses that are later used in <code>updateContractAddresses</code> calls.</p> <p>Can only be called by <code>governance</code>.</p> Parameters Type Description <code>_contractNames</code> <code>string[]</code> Contracts names. <code>_contractAddresses</code> <code>address[]</code> Addresses of corresponding contracts names."},{"location":"apis/smart-contracts/AddressUpdater/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/AddressUpdater/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>AddressUpdater</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance\n) public;\n</code></pre>"},{"location":"apis/smart-contracts/AddressUpdater/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>Governed</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance\n) public;\n</code></pre> Parameters Type Description <code>_governance</code> <code>address</code> Governance contract. Must not be zero."},{"location":"apis/smart-contracts/AddressUpdater/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/AddressUpdater/#fn_getcontractaddress_04433bbc","title":"<code>getContractAddress</code>","text":"<p>Defined in <code>AddressUpdater</code> (Docs, Source).</p> <pre><code>function getContractAddress(\n    string _name\n) external view returns (\n    address);\n</code></pre> <p>Returns contract address for the given name, which might be address(0).</p> Parameters Type Description <code>_name</code> <code>string</code> Name of the contract to query. Returns Type Description [0] <code>address</code> Current address for the queried contract."},{"location":"apis/smart-contracts/AddressUpdater/#fn_getcontractaddressbyhash_159354a2","title":"<code>getContractAddressByHash</code>","text":"<p>Defined in <code>AddressUpdater</code> (Docs, Source).</p> <pre><code>function getContractAddressByHash(\n    bytes32 _nameHash\n) external view returns (\n    address);\n</code></pre> <p>Returns contract address for the given name hash, which might be address(0).</p> Parameters Type Description <code>_nameHash</code> <code>bytes32</code> Hash of the contract name: <code>keccak256(abi.encode(name))</code> Returns Type Description [0] <code>address</code> Current address for the queried contract."},{"location":"apis/smart-contracts/AddressUpdater/#fn_getcontractaddresses_ee6f63c3","title":"<code>getContractAddresses</code>","text":"<p>Defined in <code>AddressUpdater</code> (Docs, Source).</p> <pre><code>function getContractAddresses(\n    string[] _names\n) external view returns (\n    address[]);\n</code></pre> <p>Returns contract addresses for the given names, which might be address(0).</p> Parameters Type Description <code>_names</code> <code>string[]</code> Names of the contracts to query. Returns Type Description [0] <code>address[]</code> Current addresses for the queried contracts."},{"location":"apis/smart-contracts/AddressUpdater/#fn_getcontractaddressesbyhash_5e11e2d1","title":"<code>getContractAddressesByHash</code>","text":"<p>Defined in <code>AddressUpdater</code> (Docs, Source).</p> <pre><code>function getContractAddressesByHash(\n    bytes32[] _nameHashes\n) external view returns (\n    address[]);\n</code></pre> <p>Returns contract addresses for the given name hashes, which might be address(0).</p> Parameters Type Description <code>_nameHashes</code> <code>bytes32[]</code> Hashes of the contract names: <code>keccak256(abi.encode(name))</code> Returns Type Description [0] <code>address[]</code> Current addresses for the queried contracts."},{"location":"apis/smart-contracts/AddressUpdater/#fn_getcontractnamesandaddresses_2f26c5c3","title":"<code>getContractNamesAndAddresses</code>","text":"<p>Defined in <code>AddressUpdater</code> (Docs, Source).</p> <pre><code>function getContractNamesAndAddresses(\n) external view returns (\n    string[] _contractNames,\n    address[] _contractAddresses);\n</code></pre> <p>Returns all contract names and corresponding addresses currently being tracked.</p> Returns Type Description <code>_contractNames</code> <code>string[]</code> Array of contract names. <code>_contractAddresses</code> <code>address[]</code> Array of contract addresses."},{"location":"apis/smart-contracts/AddressUpdater/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/AddressUpdater/#fn_removecontracts_70d44f28","title":"<code>removeContracts</code>","text":"<p>Defined in <code>AddressUpdater</code> (Docs, Source).</p> <pre><code>function removeContracts(\n    string[] _contractNames\n) external;\n</code></pre> <p>Remove contracts with given names.</p> <p>Can only be called by <code>governance</code>.</p> Parameters Type Description <code>_contractNames</code> <code>string[]</code> Contract names."},{"location":"apis/smart-contracts/AddressUpdater/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/AddressUpdater/#fn_update_9933dba6","title":"<code>update</code>","text":"<p>Defined in <code>AddressUpdater</code> (Docs, Source).</p> <pre><code>function update(\n    string[] _contractNames,\n    address[] _contractAddresses,\n    contract IIAddressUpdatable[] _contractsToUpdate\n) external;\n</code></pre> <p>Set or <code>update</code> contract names and addresses, and then apply changes to specific contracts.</p> <p>This is a combination of <code>addOrUpdateContractNamesAndAddresses</code> and <code>updateContractAddresses</code>. Can only be called by <code>governance</code>.</p> Parameters Type Description <code>_contractNames</code> <code>string[]</code> Contracts names. <code>_contractAddresses</code> <code>address[]</code> Addresses of corresponding contracts names. <code>_contractsToUpdate</code> <code>contract IIAddressUpdatable[]</code> Contracts to be updated."},{"location":"apis/smart-contracts/AddressUpdater/#fn_updatecontractaddresses_1b0e2960","title":"<code>updateContractAddresses</code>","text":"<p>Defined in <code>AddressUpdater</code> (Docs, Source).</p> <pre><code>function updateContractAddresses(\n    contract IIAddressUpdatable[] _contractsToUpdate\n) external;\n</code></pre> <p>Updates contract addresses on specific contracts.</p> <p>Can only be called by <code>governance</code>.</p> Parameters Type Description <code>_contractsToUpdate</code> <code>contract IIAddressUpdatable[]</code> Contracts to be updated, which must implement the <code>IIAddressUpdatable</code> interface."},{"location":"apis/smart-contracts/AddressUpdater/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/AddressUpdater/#va_governancesettings","title":"<code>governanceSettings</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    contract IGovernanceSettings governanceSettings\n</code></pre> <p>Governance Settings.</p>"},{"location":"apis/smart-contracts/AddressUpdater/#va_productionmode","title":"<code>productionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    bool productionMode\n</code></pre> <p>When true, <code>governance</code> is enabled and cannot be disabled. See <code>switchToProductionMode</code>.</p>"},{"location":"apis/smart-contracts/AddressUpdater/#va_timelockedcalls","title":"<code>timelockedCalls</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    mapping(bytes4 =&gt; struct GovernedBase.TimelockedCall) timelockedCalls\n</code></pre> <p>List of pending timelocked <code>governance</code> calls.</p>"},{"location":"apis/smart-contracts/CheckPointable/","title":"CheckPointable","text":""},{"location":"apis/smart-contracts/CheckPointable/#ct_checkpointable","title":"<code>CheckPointable</code>","text":"<p>Source</p> <p>Check-Pointable ERC20 Behavior.</p> <p>ERC20 behavior that adds balance check-point features.</p>"},{"location":"apis/smart-contracts/CheckPointable/#events","title":"Events","text":""},{"location":"apis/smart-contracts/CheckPointable/#ev_createdtotalsupplycache","title":"<code>CreatedTotalSupplyCache</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>event CreatedTotalSupplyCache(\n    uint256 _blockNumber\n)\n</code></pre> <p>Emitted when a total supply cache entry is created. Allows history cleaners to track total supply cache cleanup opportunities off-chain.</p>"},{"location":"apis/smart-contracts/CheckPointable/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/CheckPointable/#fn_balancehistorycleanup_f0e292c9","title":"<code>balanceHistoryCleanup</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>function balanceHistoryCleanup(\n    address _owner,\n    uint256 _count\n) external returns (\n    uint256);\n</code></pre> <p>Delete balance checkpoints that expired (i.e. are before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_owner</code> <code>address</code> balance owner account address <code>_count</code> <code>uint256</code> maximum number of checkpoints to delete Returns Type Description [0] <code>uint256</code> the number of checkpoints deleted"},{"location":"apis/smart-contracts/CheckPointable/#fn_totalsupplycachecleanup_43ea370b","title":"<code>totalSupplyCacheCleanup</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>function totalSupplyCacheCleanup(\n    uint256 _blockNumber\n) external returns (\n    uint256);\n</code></pre> <p>Delete total supply cache entry that expired (i.e. is before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> the block number for which total supply value was cached Returns Type Description [0] <code>uint256</code> the number of cache entries deleted (always 0 or 1)"},{"location":"apis/smart-contracts/CheckPointable/#fn_totalsupplyhistorycleanup_f62f8f3a","title":"<code>totalSupplyHistoryCleanup</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>function totalSupplyHistoryCleanup(\n    uint256 _count\n) external returns (\n    uint256);\n</code></pre> <p>Delete total supply checkpoints that expired (i.e. are before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_count</code> <code>uint256</code> maximum number of checkpoints to delete Returns Type Description [0] <code>uint256</code> the number of checkpoints deleted"},{"location":"apis/smart-contracts/CheckPointable/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/CheckPointable/#md_notbeforecleanupblock","title":"<code>notBeforeCleanupBlock</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>modifier notBeforeCleanupBlock(    uint256 _blockNumber)\n</code></pre> <p>This method cannot be called for <code>_blockNumber</code> lower than the current cleanup block number.</p>"},{"location":"apis/smart-contracts/CheckPointable/#md_onlycleaner","title":"<code>onlyCleaner</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>modifier onlyCleaner()\n</code></pre> <p>Only the <code>cleanerContract</code> can call this method.</p>"},{"location":"apis/smart-contracts/CheckPointable/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/CheckPointable/#va_cleanercontract","title":"<code>cleanerContract</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>    address cleanerContract\n</code></pre> <p>Address of the contract that is allowed to call methods for history cleaning.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/","title":"ClaimSetupManager","text":""},{"location":"apis/smart-contracts/ClaimSetupManager/#ct_claimsetupmanager","title":"<code>ClaimSetupManager</code>","text":"<p>Source | Inherits from IIClaimSetupManager, Governed, AddressUpdatable, CloneFactory, ReentrancyGuard</p> <p>Manages automation of operations related to reward claiming.</p> <p>Rewards include FTSO rewards and airdrops. Managed operations include Automatic Claiming and Personal Delegation Accounts.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_accounttodelegationaccount_69ea2387","title":"<code>accountToDelegationAccount</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function accountToDelegationAccount(\n    address _owner\n) external view returns (\n    address);\n</code></pre> <p>Gets the PDA of an account.</p> Parameters Type Description <code>_owner</code> <code>address</code> Account to query. Returns Type Description [0] <code>address</code> Address of its PDA or <code>address(0)</code> if it has not been created yet."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_allowedclaimrecipients_dfd14c34","title":"<code>allowedClaimRecipients</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function allowedClaimRecipients(\n    address _owner\n) external view returns (\n    address[]);\n</code></pre> <p>Gets the addresses of recipients allowed to receive rewards on behalf of an account. Beside these, the owner of the rewards is always authorized. See <code>setAllowedClaimRecipients</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> Returns Type Description [0] <code>address[]</code> Addresses of all set authorized recipients."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_batchdelegate_dc4fcda7","title":"<code>batchDelegate</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function batchDelegate(\n    address[] _delegatees,\n    uint256[] _bips\n) external;\n</code></pre> <p>Undelegates all percentage delegations from the caller's PDA and then <code>delegate</code> to a list of accounts.</p> <p>See <code>delegate</code>.</p> Parameters Type Description <code>_delegatees</code> <code>address[]</code> The addresses of the new recipients. <code>_bips</code> <code>uint256[]</code> The percentage of voting power to be delegated to each delegatee, expressed in basis points (1/100 of one percent). Total of all <code>_bips</code> values must be lower than 10000."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_checkexecutorandallowedrecipient_ce2caa57","title":"<code>checkExecutorAndAllowedRecipient</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function checkExecutorAndAllowedRecipient(\n    address _executor,\n    address _claimFor,\n    address _recipient\n) external view;\n</code></pre> <p>Checks if an executor can claim on behalf of a given account and send funds to a given recipient address.</p> <p>Reverts if claiming is not possible, does nothing otherwise.</p> Parameters Type Description <code>_executor</code> <code>address</code> The executor to query. <code>_claimFor</code> <code>address</code> <code>_recipient</code> <code>address</code> The address where the reward would be sent."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_claimexecutors_3f317fe1","title":"<code>claimExecutors</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function claimExecutors(\n    address _owner\n) external view returns (\n    address[]);\n</code></pre> <p>Gets the addresses of executors authorized to claim for an account. See <code>setClaimExecutors</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> The account to query. Returns Type Description [0] <code>address[]</code> Addresses of all set executors."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance,\n    address _addressUpdater,\n    uint256 _feeValueUpdateOffset,\n    uint256 _minFeeValueWei,\n    uint256 _maxFeeValueWei,\n    uint256 _registerExecutorFeeValueWei\n) public;\n</code></pre>"},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>Governed</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance\n) public;\n</code></pre> Parameters Type Description <code>_governance</code> <code>address</code> Governance contract. Must not be zero."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_delegate_026e402b","title":"<code>delegate</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function delegate(\n    address _to,\n    uint256 _bips\n) external;\n</code></pre> <p>Delegates a percentage of the caller's PDA's voting power to another address.</p> Parameters Type Description <code>_to</code> <code>address</code> The address of the recipient. <code>_bips</code> <code>uint256</code> The percentage of voting power to be delegated expressed in basis points (1/100 of one percent). Not cumulative: Every call resets the delegation value. A value of 0 revokes delegation."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_delegategovernance_7a68a508","title":"<code>delegateGovernance</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function delegateGovernance(\n    address _to\n) external;\n</code></pre> <p>Delegates all the governance vote power of the caller's PDA to another account.</p> Parameters Type Description <code>_to</code> <code>address</code> Address of the recipient of the delegation."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_disabledelegationaccount_2394deb1","title":"<code>disableDelegationAccount</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function disableDelegationAccount(\n) external;\n</code></pre> <p>Disables the Personal Delegation Account (PDA).</p> <p>When using automatic claiming, all airdrops and FTSO rewards will be sent to the owner's account. Rewards accrued by the PDA will no longer be automatically claimed.</p> <p>Reverts if there is no PDA.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_enabledelegationaccount_f0977215","title":"<code>enableDelegationAccount</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function enableDelegationAccount(\n) external returns (\n    contract IDelegationAccount);\n</code></pre> <p>Enables (or creates) a Personal Delegation Account (PDA).</p> <p>When using automatic claiming, all airdrops and FTSO rewards will be sent to the PDA, and any rewards accrued by the PDA will be claimed too.</p> Returns Type Description [0] <code>contract IDelegationAccount</code> Address of the delegation account contract."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_getaddressupdater_5267a15d","title":"<code>getAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function getAddressUpdater(\n) public view returns (\n    address _addressUpdater);\n</code></pre> <p>Returns the configured address updater.</p> Returns Type Description <code>_addressUpdater</code> <code>address</code> The <code>AddresUpdater</code> contract that can update our contract address list, as a response to a governance call."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_getautoclaimaddressesandexecutorfee_e24883b2","title":"<code>getAutoClaimAddressesAndExecutorFee</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getAutoClaimAddressesAndExecutorFee(\n    address _executor,\n    address[] _owners\n) external view returns (\n    address[] _recipients,\n    uint256 _executorFeeValue);\n</code></pre> <p>Gets the Personal Delegation Account (PDA) for a list of accounts for which an executor is claiming. Returns owner address instead if the PDA is not created yet or not enabled.</p> Parameters Type Description <code>_executor</code> <code>address</code> Executor to query. <code>_owners</code> <code>address[]</code> Array of reward owners which must have set <code>_executor</code> as their executor. Returns Type Description <code>_recipients</code> <code>address[]</code> Addresses which will receive the claimed rewards. Can be the reward owners or their PDAs. <code>_executorFeeValue</code> <code>uint256</code> Executor's fee value, in wei."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_getdelegationaccountdata_17a1e3fc","title":"<code>getDelegationAccountData</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getDelegationAccountData(\n    address _owner\n) external view returns (\n    contract IDelegationAccount _delegationAccount,\n    bool _enabled);\n</code></pre> <p>Gets PDA data for an account.</p> Parameters Type Description <code>_owner</code> <code>address</code> Account to query. Returns Type Description <code>_delegationAccount</code> <code>contract IDelegationAccount</code> Account's PDA address or <code>address(0)</code> if it has not been created yet. <code>_enabled</code> <code>bool</code> Whether the PDA is enabled."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_getexecutorcurrentfeevalue_e25547f8","title":"<code>getExecutorCurrentFeeValue</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getExecutorCurrentFeeValue(\n    address _executor\n) public view returns (\n    uint256);\n</code></pre> <p>Returns the current fee of a registered executor. Reverts if the executor is not registered.</p> Parameters Type Description <code>_executor</code> <code>address</code> The executor to query. Returns Type Description [0] <code>uint256</code> Fee in wei."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_getexecutorfeevalue_3f8f784c","title":"<code>getExecutorFeeValue</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getExecutorFeeValue(\n    address _executor,\n    uint256 _rewardEpoch\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the fee of an executor at a given reward epoch.</p> Parameters Type Description <code>_executor</code> <code>address</code> The executor to query. <code>_rewardEpoch</code> <code>uint256</code> Reward Epoch ID to query. Returns Type Description [0] <code>uint256</code> Fee in wei at that reward epoch."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_getexecutorinfo_8e28b923","title":"<code>getExecutorInfo</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getExecutorInfo(\n    address _executor\n) external view returns (\n    bool _registered,\n    uint256 _currentFeeValue);\n</code></pre> <p>Returns information about an executor.</p> Parameters Type Description <code>_executor</code> <code>address</code> The executor to query. Returns Type Description <code>_registered</code> <code>bool</code> Whether the executor is registered. <code>_currentFeeValue</code> <code>uint256</code> Executor's current fee value, if registered."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_getexecutorscheduledfeevaluechanges_950b028c","title":"<code>getExecutorScheduledFeeValueChanges</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getExecutorScheduledFeeValueChanges(\n    address _executor\n) external view returns (\n    uint256[] _feeValue,\n    uint256[] _validFromEpoch,\n    bool[] _fixed);\n</code></pre> <p>Returns the currently scheduled fee changes of an executor.</p> Parameters Type Description <code>_executor</code> <code>address</code> Executor to query. Returns Type Description <code>_feeValue</code> <code>uint256[]</code> Array of scheduled fees. <code>_validFromEpoch</code> <code>uint256[]</code> Array of reward epochs ID where the scheduled fees will become effective. <code>_fixed</code> <code>bool[]</code> Array of booleans indicating if an scheduled fee change is fixed or it might still be changed."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_getregisteredexecutors_6e927e61","title":"<code>getRegisteredExecutors</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getRegisteredExecutors(\n    uint256 _start,\n    uint256 _end\n) external view returns (\n    address[] _registeredExecutors,\n    uint256 _totalLength);\n</code></pre> <p>Returns the list of executors registered through <code>registerExecutor</code>. Supports paging.</p> Parameters Type Description <code>_start</code> <code>uint256</code> First executor to return. <code>_end</code> <code>uint256</code> Last executor to return. Returns Type Description <code>_registeredExecutors</code> <code>address[]</code> Addresses of the registered executors. <code>_totalLength</code> <code>uint256</code> Total amount of executors."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_isclaimexecutor_87962abe","title":"<code>isClaimExecutor</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function isClaimExecutor(\n    address _owner,\n    address _executor\n) external view returns (\n    bool);\n</code></pre> <p>Returns whether an executor is authorized to claim on behalf of a reward owner. See <code>setClaimExecutors</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> The reward owner to query. <code>_executor</code> <code>address</code> The executor to query."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_registerexecutor_ccce7e86","title":"<code>registerExecutor</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function registerExecutor(\n    uint256 _feeValue\n) external payable returns (\n    uint256);\n</code></pre> <p>Registers the caller as an executor and sets its initial fee value.</p> <p>If the executor was already registered, this method only updates the fee, which will take effect after <code>feeValueUpdateOffset</code> reward epochs have elapsed.</p> <p>Executor must pay a fee in order to register. See <code>registerExecutorFeeValueWei</code>.</p> Parameters Type Description <code>_feeValue</code> <code>uint256</code> Desired fee, in wei. Must be between <code>minFeeValueWei</code> and <code>maxFeeValueWei</code>. 0 means no fee. Returns Type Description [0] <code>uint256</code> Reward epoch ID when the changes become effective."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_revokedelegationat_bbd6fbf8","title":"<code>revokeDelegationAt</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function revokeDelegationAt(\n    address _who,\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Revokes all delegation from the caller's PDA to a given account at a given block.</p> <p>Only affects the reads via <code>votePowerOfAtCached()</code> in the specified block.</p> <p>This method should be used only to prevent rogue <code>delegate</code> voting in the current voting block. To stop delegating use <code>delegate</code> with percentage of 0 or <code>undelegateAll</code>.</p> Parameters Type Description <code>_who</code> <code>address</code> The account to revoke. <code>_blockNumber</code> <code>uint256</code> Block number where the revoking will take place. Must be in the past."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_setallowedclaimrecipients_d2a4ac61","title":"<code>setAllowedClaimRecipients</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setAllowedClaimRecipients(\n    address[] _recipients\n) external;\n</code></pre> <p>Set the addresses of allowed recipients. The reward owner is always an allowed recipient.</p> Parameters Type Description <code>_recipients</code> <code>address[]</code> The new allowed recipients. All old recipients will be deleted and replaced by these."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_setautoclaiming_e72dcdbb","title":"<code>setAutoClaiming</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setAutoClaiming(\n    address[] _executors,\n    bool _enableDelegationAccount\n) external payable;\n</code></pre> <p>Sets the addresses of executors and optionally enables (creates) a Personal Delegation Account (PDA).</p> <p>If any of the executors is a registered executor, some fee needs to be paid.</p> Parameters Type Description <code>_executors</code> <code>address[]</code> The new executors. All old executors will be deleted and replaced by these. <code>_enableDelegationAccount</code> <code>bool</code> Whether the PDA should be enabled."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_setclaimexecutors_9119c494","title":"<code>setClaimExecutors</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setClaimExecutors(\n    address[] _executors\n) external payable;\n</code></pre> <p>Sets the addresses of executors.</p> <p>If any of the executors is a registered executor, some fee needs to be paid.</p> Parameters Type Description <code>_executors</code> <code>address[]</code> The new executors. All old executors will be deleted and replaced by these."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_setlibraryaddress_4863ba17","title":"<code>setLibraryAddress</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setLibraryAddress(\n    address _libraryAddress\n) external;\n</code></pre> <p>Sets new library address.</p> <p>Only <code>governance</code> can call this.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_setmaxfeevaluewei_2e9b6afa","title":"<code>setMaxFeeValueWei</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setMaxFeeValueWei(\n    uint256 _maxFeeValueWei\n) external;\n</code></pre> <p>Sets maximum fee allowed for executors, in wei.</p> <p>Only <code>governance</code> can call this.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_setminfeevaluewei_d8343550","title":"<code>setMinFeeValueWei</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setMinFeeValueWei(\n    uint256 _minFeeValueWei\n) external;\n</code></pre> <p>Sets minimum fee allowed for executors, in wei.</p> <p>Only <code>governance</code> can call this.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_setregisterexecutorfeevaluewei_869d90a5","title":"<code>setRegisterExecutorFeeValueWei</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setRegisterExecutorFeeValueWei(\n    uint256 _registerExecutorFeeValueWei\n) external;\n</code></pre> <p>Sets the fee required to register an executor, which must be higher than 0.</p> <p>Only <code>governance</code> can call this.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_transferexternaltoken_489a8a47","title":"<code>transferExternalToken</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function transferExternalToken(\n    contract IERC20 _token,\n    uint256 _amount\n) external;\n</code></pre> <p>Allows the caller to transfer ERC-20 tokens from their PDA to the owner account.</p> <p>The main use case is to move ERC-20 tokes received by mistake (by an airdrop, for example) out of the PDA and into the main account, where they can be more easily managed.</p> <p>Reverts if the target token is the <code>WNat</code> contract: use method <code>withdraw</code> for that.</p> Parameters Type Description <code>_token</code> <code>contract IERC20</code> Target token contract address. <code>_amount</code> <code>uint256</code> Amount of tokens to transfer."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_undelegateall_b302f393","title":"<code>undelegateAll</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function undelegateAll(\n) external;\n</code></pre> <p>Removes all delegations from the caller's PDA.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_undelegategovernance_87a2a0dc","title":"<code>undelegateGovernance</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function undelegateGovernance(\n) external;\n</code></pre> <p>Undelegates all governance vote power currently delegated by the caller's PDA.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_unregisterexecutor_868a660f","title":"<code>unregisterExecutor</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function unregisterExecutor(\n) external returns (\n    uint256 _validFromEpoch);\n</code></pre> <p>Unregisters the caller as an executor.</p> Returns Type Description <code>_validFromEpoch</code> <code>uint256</code> Reward epoch ID when the change becomes effective."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_updatecontractaddresses_b00c0b76","title":"<code>updateContractAddresses</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function updateContractAddresses(\n    bytes32[] _contractNameHashes,\n    address[] _contractAddresses\n) external;\n</code></pre> <p>External method called from <code>AddressUpdater</code> only.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_updateexecutorfeevalue_831f16af","title":"<code>updateExecutorFeeValue</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function updateExecutorFeeValue(\n    uint256 _feeValue\n) external returns (\n    uint256);\n</code></pre> <p>Sets the caller's executor fee. The caller must be an executor registered through <code>registerExecutor</code>.</p> <p>When called multiple times inside the same reward epoch, only the last value remains.</p> Parameters Type Description <code>_feeValue</code> <code>uint256</code> Desired fee, in wei. Must be between <code>minFeeValueWei</code> and <code>maxFeeValueWei</code>. 0 means no fee. Returns Type Description [0] <code>uint256</code> Reward epoch ID when the changes become effective."},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_wnat_9edbf007","title":"<code>wNat</code>","text":"<p>Defined in <code>IIClaimSetupManager</code> (Docs, Source).</p> <pre><code>function wNat(\n) external view returns (\n    contract WNat);\n</code></pre> <p>Returns the <code>WNat</code> contract.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#fn_withdraw_2e1a7d4d","title":"<code>withdraw</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>function withdraw(\n    uint256 _amount\n) external;\n</code></pre> <p>Allows the caller to transfer <code>WNat</code> wrapped tokens from their PDA to the owner account.</p> Parameters Type Description <code>_amount</code> <code>uint256</code> Amount of tokens to transfer, in wei."},{"location":"apis/smart-contracts/ClaimSetupManager/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/ClaimSetupManager/#md_nonreentrant","title":"<code>nonReentrant</code>","text":"<p>Defined in <code>ReentrancyGuard</code> (Source).</p> <pre><code>modifier nonReentrant()\n</code></pre> <p>Prevents a contract from calling itself, directly or indirectly. Calling a <code>nonReentrant</code> function from another <code>nonReentrant</code> function is not supported. It is possible to prevent this from happening by making the <code>nonReentrant</code> function external, and make it call a <code>private</code> function that does the actual work.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#md_onlyaddressupdater","title":"<code>onlyAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>modifier onlyAddressUpdater()\n</code></pre> <p>Only the <code>AdressUpdater</code> contract can call this method. Its address is set at construction time but it can also update itself.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#md_onlygovernance","title":"<code>onlyGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/ClaimSetupManager/#md_onlyimmediategovernance","title":"<code>onlyImmediateGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyImmediateGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/ClaimSetupManager/#md_onlyownerorexecutor","title":"<code>onlyOwnerOrExecutor</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>modifier onlyOwnerOrExecutor(    address _executor,\n    address[] _owners)\n</code></pre>"},{"location":"apis/smart-contracts/ClaimSetupManager/#structures","title":"Structures","text":""},{"location":"apis/smart-contracts/ClaimSetupManager/#st_delegationaccountdata","title":"<code>DelegationAccountData</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>struct DelegationAccountData {\n  contract IIDelegationAccount delegationAccount;\n  bool enabled;\n}\n</code></pre>"},{"location":"apis/smart-contracts/ClaimSetupManager/#st_executorfee","title":"<code>ExecutorFee</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>struct ExecutorFee {\n  uint256 value;\n  uint256 validFromEpoch;\n}\n</code></pre>"},{"location":"apis/smart-contracts/ClaimSetupManager/#st_timelockedcall","title":"<code>TimelockedCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>struct TimelockedCall {\n  uint256 allowedAfterTimestamp;\n  bytes encodedCall;\n}\n</code></pre>"},{"location":"apis/smart-contracts/ClaimSetupManager/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/ClaimSetupManager/#va_feevalueupdateoffset","title":"<code>feeValueUpdateOffset</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>    uint256 feeValueUpdateOffset\n</code></pre> <p>Number of reward epochs that must elapse before an executor's fee change takes effect.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#va_ftsomanager","title":"<code>ftsoManager</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>    contract IFtsoManager ftsoManager\n</code></pre> <p>The <code>FtsoManager</code> contract.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#va_governancesettings","title":"<code>governanceSettings</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    contract IGovernanceSettings governanceSettings\n</code></pre> <p>Governance Settings.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#va_governancevp","title":"<code>governanceVP</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>    contract IGovernanceVotePower governanceVP\n</code></pre> <p>The <code>GovernanceVotePower</code> contract.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#va_libraryaddress","title":"<code>libraryAddress</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>    address libraryAddress\n</code></pre>"},{"location":"apis/smart-contracts/ClaimSetupManager/#va_maxfeevaluewei","title":"<code>maxFeeValueWei</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>    uint256 maxFeeValueWei\n</code></pre> <p>Maximum allowed value for an executor's fee.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#va_minfeevaluewei","title":"<code>minFeeValueWei</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>    uint256 minFeeValueWei\n</code></pre> <p>Minimum allowed value for an executor's fee.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#va_productionmode","title":"<code>productionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    bool productionMode\n</code></pre> <p>When true, <code>governance</code> is enabled and cannot be disabled. See <code>switchToProductionMode</code>.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#va_registerexecutorfeevaluewei","title":"<code>registerExecutorFeeValueWei</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>    uint256 registerExecutorFeeValueWei\n</code></pre> <p>Fee that must be paid to register an executor.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#va_timelockedcalls","title":"<code>timelockedCalls</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    mapping(bytes4 =&gt; struct GovernedBase.TimelockedCall) timelockedCalls\n</code></pre> <p>List of pending timelocked <code>governance</code> calls.</p>"},{"location":"apis/smart-contracts/ClaimSetupManager/#va_wnat","title":"<code>wNat</code>","text":"<p>Defined in <code>ClaimSetupManager</code> (Docs, Source).</p> <pre><code>    contract WNat wNat\n</code></pre> <p>The <code>WNat</code> contract.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/","title":"CleanupBlockNumberManager","text":""},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#ct_cleanupblocknumbermanager","title":"<code>CleanupBlockNumberManager</code>","text":"<p>Source | Inherits from Governed, AddressUpdatable</p> <p>Token history cleanup manager.</p> <p>Maintains the list of cleanable tokens for which history cleanup can be collectively executed.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#events","title":"Events","text":""},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#ev_cleanupblocknumberset","title":"<code>CleanupBlockNumberSet</code>","text":"<p>Defined in <code>CleanupBlockNumberManager</code> (Docs, Source).</p> <pre><code>event CleanupBlockNumberSet(\n    contract IICleanable theContract,\n    uint256 blockNumber,\n    bool success\n)\n</code></pre> <p>Emitted when an attempt has been made to set the cleanup block number.</p> Parameters Type Description <code>theContract</code> <code>contract IICleanable</code> The token contract address. <code>blockNumber</code> <code>uint256</code> The block number being set. <code>success</code> <code>bool</code> Whether it succeeded or not."},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#ev_governancecalltimelocked","title":"<code>GovernanceCallTimelocked</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernanceCallTimelocked(\n    bytes4 selector,\n    uint256 allowedAfterTimestamp,\n    bytes encodedCall\n)\n</code></pre> <p>Emitted when a new <code>governance</code> call has been recorded and is now waiting for the time lock to expire.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#ev_governanceinitialised","title":"<code>GovernanceInitialised</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernanceInitialised(\n    address initialGovernance\n)\n</code></pre> <p>Emitted when the <code>governance</code> address is initialized. This address will be used until production mode is entered (see <code>GovernedProductionModeEntered</code>). At that point the <code>governance</code> address is taken from <code>GovernanceSettings</code>.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#ev_governedproductionmodeentered","title":"<code>GovernedProductionModeEntered</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernedProductionModeEntered(\n    address governanceSettings\n)\n</code></pre> <p>Emitted when <code>governance</code> is enabled and the <code>governance</code> address cannot be changed anymore (only through a network fork).</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#ev_registrationupdated","title":"<code>RegistrationUpdated</code>","text":"<p>Defined in <code>CleanupBlockNumberManager</code> (Docs, Source).</p> <pre><code>event RegistrationUpdated(\n    contract IICleanable theContract,\n    bool add\n)\n</code></pre> <p>Emitted when a new token has been registered to have its history managed by us, or an old one unregistered.</p> Parameters Type Description <code>theContract</code> <code>contract IICleanable</code> The token contract address. <code>add</code> <code>bool</code> true is the token has been registered, false if unregistered."},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#ev_timelockedgovernancecallcanceled","title":"<code>TimelockedGovernanceCallCanceled</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event TimelockedGovernanceCallCanceled(\n    bytes4 selector,\n    uint256 timestamp\n)\n</code></pre> <p>Emitted when a timelocked <code>governance</code> call is canceled before execution.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#ev_timelockedgovernancecallexecuted","title":"<code>TimelockedGovernanceCallExecuted</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event TimelockedGovernanceCallExecuted(\n    bytes4 selector,\n    uint256 timestamp\n)\n</code></pre> <p>Emitted when a timelocked <code>governance</code> call is executed.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>CleanupBlockNumberManager</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance,\n    address _addressUpdater,\n    string _triggerContractName\n) public;\n</code></pre> <p>Build a new instance.</p> Parameters Type Description <code>_governance</code> <code>address</code> Contract address that can make governance calls. See <code>Governed</code>. <code>_addressUpdater</code> <code>address</code> Contract address that can update redeployable addresses. See <code>AdressUpdatable</code>. <code>_triggerContractName</code> <code>string</code> Contract name that can trigger history cleanups."},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#fn_getaddressupdater_5267a15d","title":"<code>getAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function getAddressUpdater(\n) public view returns (\n    address _addressUpdater);\n</code></pre> <p>Returns the configured address updater.</p> Returns Type Description <code>_addressUpdater</code> <code>address</code> The <code>AddresUpdater</code> contract that can update our contract address list, as a response to a governance call."},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#fn_registertoken_09824a80","title":"<code>registerToken</code>","text":"<p>Defined in <code>CleanupBlockNumberManager</code> (Docs, Source).</p> <pre><code>function registerToken(\n    contract IICleanable _cleanableToken\n) external;\n</code></pre> <p>Register a token contract whose history cleanup index is to be managed. The registered contracts must allow calling <code>setCleanupBlockNumber</code>.</p> Parameters Type Description <code>_cleanableToken</code> <code>contract IICleanable</code> The address of the contract to be managed."},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#fn_setcleanupblocknumber_cbc31cf7","title":"<code>setCleanUpBlockNumber</code>","text":"<p>Defined in <code>CleanupBlockNumberManager</code> (Docs, Source).</p> <pre><code>function setCleanUpBlockNumber(\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Sets clean up block number on managed cleanable tokens.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> cleanup block number"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#fn_unregistertoken_77860cdd","title":"<code>unregisterToken</code>","text":"<p>Defined in <code>CleanupBlockNumberManager</code> (Docs, Source).</p> <pre><code>function unregisterToken(\n    contract IICleanable _cleanableToken\n) external;\n</code></pre> <p>Unregister a token contract from history cleanup index management.</p> Parameters Type Description <code>_cleanableToken</code> <code>contract IICleanable</code> The address of the contract to unregister."},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#fn_updatecontractaddresses_b00c0b76","title":"<code>updateContractAddresses</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function updateContractAddresses(\n    bytes32[] _contractNameHashes,\n    address[] _contractAddresses\n) external;\n</code></pre> <p>External method called from <code>AddressUpdater</code> only.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#md_onlyaddressupdater","title":"<code>onlyAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>modifier onlyAddressUpdater()\n</code></pre> <p>Only the <code>AdressUpdater</code> contract can call this method. Its address is set at construction time but it can also update itself.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#md_onlygovernance","title":"<code>onlyGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#md_onlyimmediategovernance","title":"<code>onlyImmediateGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyImmediateGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#md_onlytrigger","title":"<code>onlyTrigger</code>","text":"<p>Defined in <code>CleanupBlockNumberManager</code> (Docs, Source).</p> <pre><code>modifier onlyTrigger()\n</code></pre> <p>Only the trigger contract can call this method. This contract is set at construction time and updated through <code>AddressUpdatable</code>.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#va_governancesettings","title":"<code>governanceSettings</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    contract IGovernanceSettings governanceSettings\n</code></pre> <p>Governance Settings.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#va_productionmode","title":"<code>productionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    bool productionMode\n</code></pre> <p>When true, <code>governance</code> is enabled and cannot be disabled. See <code>switchToProductionMode</code>.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#va_registeredtokens","title":"<code>registeredTokens</code>","text":"<p>Defined in <code>CleanupBlockNumberManager</code> (Docs, Source).</p> <pre><code>    contract IICleanable[] registeredTokens\n</code></pre> <p>Current list of token contracts being managed.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#va_timelockedcalls","title":"<code>timelockedCalls</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    mapping(bytes4 =&gt; struct GovernedBase.TimelockedCall) timelockedCalls\n</code></pre> <p>List of pending timelocked <code>governance</code> calls.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#va_triggercontract","title":"<code>triggerContract</code>","text":"<p>Defined in <code>CleanupBlockNumberManager</code> (Docs, Source).</p> <pre><code>    address triggerContract\n</code></pre> <p>Address of the contract that can trigger a cleanup.</p>"},{"location":"apis/smart-contracts/CleanupBlockNumberManager/#va_triggercontractname","title":"<code>triggerContractName</code>","text":"<p>Defined in <code>CleanupBlockNumberManager</code> (Docs, Source).</p> <pre><code>    string triggerContractName\n</code></pre> <p>Name of the contract that can trigger a cleanup. Needed to update the trigger contract address through the <code>AddressUpdater</code>.</p>"},{"location":"apis/smart-contracts/CloneFactory/","title":"CloneFactory","text":""},{"location":"apis/smart-contracts/CloneFactory/#ct_clonefactory","title":"<code>CloneFactory</code>","text":"<p>Source</p> <p>Simple clone contract factory.</p> <p>This code (intended to be called from an implementor factory contract) will allow you to install a master copy of a contract, then easily (cheaply) create clones with separate state. The deployed bytecode just delegates all calls to the master contract address.</p> <p>Source attribution.</p>"},{"location":"apis/smart-contracts/CloneFactory/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/Delegatable/","title":"Delegatable","text":""},{"location":"apis/smart-contracts/Delegatable/#ct_delegatable","title":"<code>Delegatable</code>","text":"<p>Source | Inherits from IVPContractEvents</p> <p><code>Delegatable</code> ERC20 behavior.</p> <p>Adds delegation capabilities to tokens. This contract orchestrates interaction between managing a delegation and the vote power allocations that result.</p>"},{"location":"apis/smart-contracts/Delegatable/#enums","title":"Enums","text":""},{"location":"apis/smart-contracts/Delegatable/#en_delegationmode","title":"<code>DelegationMode</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>enum DelegationMode {\n  NOTSET,\n  PERCENTAGE,\n  AMOUNT\n}\n</code></pre> <p>Delegation mode of an account. Once set, it cannot be changed.</p> <ul> <li><code>NOTSET</code>: Delegation mode not set yet.</li> <li><code>PERCENTAGE</code>: Delegation by percentage.</li> <li><code>AMOUNT</code>: Delegation by amount (explicit).</li> </ul>"},{"location":"apis/smart-contracts/Delegatable/#events","title":"Events","text":""},{"location":"apis/smart-contracts/Delegatable/#ev_createdvotepowercache","title":"<code>CreatedVotePowerCache</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>event CreatedVotePowerCache(\n    address _owner,\n    uint256 _blockNumber\n)\n</code></pre> <p>Emitted when a vote power cache entry is created. Allows history cleaners to track vote power cache cleanup opportunities off-chain.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address whose vote power has just been cached. <code>_blockNumber</code> <code>uint256</code> The block number at which the vote power has been cached."},{"location":"apis/smart-contracts/Delegatable/#ev_delegate","title":"<code>Delegate</code>","text":"<p>Defined in <code>IVPContractEvents</code> (Docs, Source).</p> <pre><code>event Delegate(\n    address from,\n    address to,\n    uint256 priorVotePower,\n    uint256 newVotePower\n)\n</code></pre> <p>Emitted when the amount of vote power delegated from one account to another changes.</p> <p>Note: This event is always emitted from <code>VPToken</code>'s <code>writeVotePowerContract</code>.</p> Parameters Type Description <code>from</code> <code>address</code> The account that has changed the amount of vote power it is delegating. <code>to</code> <code>address</code> The account whose received vote power has changed. <code>priorVotePower</code> <code>uint256</code> The vote power originally delegated. <code>newVotePower</code> <code>uint256</code> The new vote power that triggered this event. It can be 0 if the delegation is completely canceled."},{"location":"apis/smart-contracts/Delegatable/#ev_revoke","title":"<code>Revoke</code>","text":"<p>Defined in <code>IVPContractEvents</code> (Docs, Source).</p> <pre><code>event Revoke(\n    address delegator,\n    address delegatee,\n    uint256 votePower,\n    uint256 blockNumber\n)\n</code></pre> <p>Emitted when an account revokes its vote power delegation to another account for a single current or past block (typically the current vote block).</p> <p>Note: This event is always emitted from <code>VPToken</code>'s <code>writeVotePowerContract</code> or <code>readVotePowerContract</code>.</p> <p>See <code>revokeDelegationAt</code> in <code>IVPToken</code>.</p> Parameters Type Description <code>delegator</code> <code>address</code> The account that revoked the delegation. <code>delegatee</code> <code>address</code> The account that has been revoked. <code>votePower</code> <code>uint256</code> The revoked vote power. <code>blockNumber</code> <code>uint256</code> The block number at which the delegation has been revoked."},{"location":"apis/smart-contracts/Delegatable/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/Delegatable/#fn_explicitdelegationhistorycleanup_cabc4528","title":"<code>explicitDelegationHistoryCleanup</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>function explicitDelegationHistoryCleanup(\n    address _from,\n    address _to,\n    uint256 _count\n) external returns (\n    uint256);\n</code></pre> <p>Delete explicit delegation checkpoints that expired (i.e. are before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_from</code> <code>address</code> Delegator address. <code>_to</code> <code>address</code> Delegatee address. <code>_count</code> <code>uint256</code> Maximum number of checkpoints to delete. Returns Type Description [0] <code>uint256</code> Number of checkpoints deleted."},{"location":"apis/smart-contracts/Delegatable/#fn_percentagedelegationhistorycleanup_7f57d58f","title":"<code>percentageDelegationHistoryCleanup</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>function percentageDelegationHistoryCleanup(\n    address _owner,\n    uint256 _count\n) external returns (\n    uint256);\n</code></pre> <p>Delete percentage delegation checkpoints that expired (i.e. are before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_owner</code> <code>address</code> Balance owner account address. <code>_count</code> <code>uint256</code> Maximum number of checkpoints to delete. Returns Type Description [0] <code>uint256</code> Number of deleted checkpoints."},{"location":"apis/smart-contracts/Delegatable/#fn_revocationcleanup_8c0b6b40","title":"<code>revocationCleanup</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>function revocationCleanup(\n    address _from,\n    address _to,\n    uint256 _blockNumber\n) external returns (\n    uint256);\n</code></pre> <p>Delete revocation entry that expired (i.e. is before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_from</code> <code>address</code> Delegator address. <code>_to</code> <code>address</code> Delegatee address. <code>_blockNumber</code> <code>uint256</code> Block number for which total supply value was cached. Returns Type Description [0] <code>uint256</code> Number of revocation entries deleted (always 0 or 1)."},{"location":"apis/smart-contracts/Delegatable/#fn_votepowercachecleanup_891339a8","title":"<code>votePowerCacheCleanup</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>function votePowerCacheCleanup(\n    address _owner,\n    uint256 _blockNumber\n) external returns (\n    uint256);\n</code></pre> <p>Delete vote power cache entry that expired (i.e. is before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_owner</code> <code>address</code> Vote power owner account address. <code>_blockNumber</code> <code>uint256</code> Block number for which total supply value was cached. Returns Type Description [0] <code>uint256</code> Number of deleted cache entries (always 0 or 1)."},{"location":"apis/smart-contracts/Delegatable/#fn_votepowerhistorycleanup_1a05274c","title":"<code>votePowerHistoryCleanup</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>function votePowerHistoryCleanup(\n    address _owner,\n    uint256 _count\n) external returns (\n    uint256);\n</code></pre> <p>Delete vote power checkpoints that expired (i.e. are before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_owner</code> <code>address</code> Vote power owner account address. <code>_count</code> <code>uint256</code> Maximum number of checkpoints to delete. Returns Type Description [0] <code>uint256</code> Number of deleted checkpoints."},{"location":"apis/smart-contracts/Delegatable/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/Delegatable/#md_notbeforecleanupblock","title":"<code>notBeforeCleanupBlock</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>modifier notBeforeCleanupBlock(    uint256 _blockNumber)\n</code></pre> <p>Reading from history is not allowed before <code>cleanupBlockNumber</code>, since data before that might have been deleted and is thus unreliable.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The block number being checked for validity."},{"location":"apis/smart-contracts/Delegatable/#md_onlycleaner","title":"<code>onlyCleaner</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>modifier onlyCleaner()\n</code></pre> <p>History cleaning methods can be called only from <code>cleanerContract</code>.</p>"},{"location":"apis/smart-contracts/Delegatable/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/Delegatable/#va_cleanercontract","title":"<code>cleanerContract</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>    address cleanerContract\n</code></pre> <p>Address of the contract that is allowed to call methods for history cleaning.</p>"},{"location":"apis/smart-contracts/FlareContractRegistry/","title":"FlareContractRegistry","text":""},{"location":"apis/smart-contracts/FlareContractRegistry/#ct_flarecontractregistry","title":"<code>FlareContractRegistry</code>","text":"<p>Source | Inherits from IFlareContractRegistry, AddressUpdatable</p> <p>The Flare contract registry.</p> <p>Entry point for all external dapps that need the latest contract addresses deployed by Flare.</p>"},{"location":"apis/smart-contracts/FlareContractRegistry/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/FlareContractRegistry/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>FlareContractRegistry</code> (Docs, Source).</p> <pre><code>constructor(\n    address _addressUpdater\n) public;\n</code></pre>"},{"location":"apis/smart-contracts/FlareContractRegistry/#fn_getaddressupdater_5267a15d","title":"<code>getAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function getAddressUpdater(\n) public view returns (\n    address _addressUpdater);\n</code></pre> <p>Returns the configured address updater.</p> Returns Type Description <code>_addressUpdater</code> <code>address</code> The <code>AddresUpdater</code> contract that can update our contract address list, as a response to a governance call."},{"location":"apis/smart-contracts/FlareContractRegistry/#fn_getallcontracts_18d3ce96","title":"<code>getAllContracts</code>","text":"<p>Defined in <code>FlareContractRegistry</code> (Docs, Source).</p> <pre><code>function getAllContracts(\n) external view returns (\n    string[] _names,\n    address[] _addresses);\n</code></pre> <p>Returns all contract names and their corresponding addresses.</p> Returns Type Description <code>_names</code> <code>string[]</code> Array of contract names. <code>_addresses</code> <code>address[]</code> Array of corresponding contract addresses."},{"location":"apis/smart-contracts/FlareContractRegistry/#fn_getcontractaddressbyhash_159354a2","title":"<code>getContractAddressByHash</code>","text":"<p>Defined in <code>FlareContractRegistry</code> (Docs, Source).</p> <pre><code>function getContractAddressByHash(\n    bytes32 _nameHash\n) external view returns (\n    address);\n</code></pre> <p>Returns the address of a given contract hash.</p> Parameters Type Description <code>_nameHash</code> <code>bytes32</code> Hash of the contract name as: <code>keccak256(abi.encode(name))</code>. Returns Type Description [0] <code>address</code> Address of the contract, or <code>address(0)</code> if not found."},{"location":"apis/smart-contracts/FlareContractRegistry/#fn_getcontractaddressbyname_82760fca","title":"<code>getContractAddressByName</code>","text":"<p>Defined in <code>FlareContractRegistry</code> (Docs, Source).</p> <pre><code>function getContractAddressByName(\n    string _name\n) external view returns (\n    address);\n</code></pre> <p>Returns the address of a given contract name.</p> Parameters Type Description <code>_name</code> <code>string</code> Name of the contract. Returns Type Description [0] <code>address</code> Address of the contract, or <code>address(0)</code> if not found."},{"location":"apis/smart-contracts/FlareContractRegistry/#fn_getcontractaddressesbyhash_5e11e2d1","title":"<code>getContractAddressesByHash</code>","text":"<p>Defined in <code>FlareContractRegistry</code> (Docs, Source).</p> <pre><code>function getContractAddressesByHash(\n    bytes32[] _nameHashes\n) external view returns (\n    address[]);\n</code></pre> <p>Returns the addresses of a list of contract hashes.</p> Parameters Type Description <code>_nameHashes</code> <code>bytes32[]</code> Array of contract name hashes as: <code>keccak256(abi.encode(name))</code>. Returns Type Description [0] <code>address[]</code> Array of addresses of the contracts. Any of them might be <code>address(0)</code> if not found."},{"location":"apis/smart-contracts/FlareContractRegistry/#fn_getcontractaddressesbyname_76d2b1af","title":"<code>getContractAddressesByName</code>","text":"<p>Defined in <code>FlareContractRegistry</code> (Docs, Source).</p> <pre><code>function getContractAddressesByName(\n    string[] _names\n) external view returns (\n    address[]);\n</code></pre> <p>Returns the addresses of a list of contract names.</p> Parameters Type Description <code>_names</code> <code>string[]</code> Array of contract names. Returns Type Description [0] <code>address[]</code> Array of addresses of the contracts. Any of them might be <code>address(0)</code> if not found."},{"location":"apis/smart-contracts/FlareContractRegistry/#fn_updatecontractaddresses_b00c0b76","title":"<code>updateContractAddresses</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function updateContractAddresses(\n    bytes32[] _contractNameHashes,\n    address[] _contractAddresses\n) external;\n</code></pre> <p>External method called from <code>AddressUpdater</code> only.</p>"},{"location":"apis/smart-contracts/FlareDaemon/","title":"FlareDaemon","text":""},{"location":"apis/smart-contracts/FlareDaemon/#ct_flaredaemon","title":"<code>FlareDaemon</code>","text":"<p>Source | Inherits from GovernedAtGenesis, AddressUpdatable</p> <p>Flare Daemon contract.</p> <p>This contract exists to coordinate regular daemon-like polling of contracts that are registered to receive said polling. The <code>trigger</code> method is called by the validator right at the end of block state transition.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#events","title":"Events","text":""},{"location":"apis/smart-contracts/FlareDaemon/#ev_contractdaemonizeerrored","title":"<code>ContractDaemonizeErrored</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>event ContractDaemonizeErrored(\n    address theContract,\n    uint256 atBlock,\n    string theMessage,\n    uint256 gasConsumed\n)\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_contractdaemonized","title":"<code>ContractDaemonized</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>event ContractDaemonized(\n    address theContract,\n    uint256 gasConsumed\n)\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_contractheldoff","title":"<code>ContractHeldOff</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>event ContractHeldOff(\n    address theContract,\n    uint256 blockHoldoffsRemaining\n)\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_contractsskippedoutofgas","title":"<code>ContractsSkippedOutOfGas</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>event ContractsSkippedOutOfGas(\n    uint256 numberOfSkippedConstracts\n)\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_governancecalltimelocked","title":"<code>GovernanceCallTimelocked</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernanceCallTimelocked(\n    bytes4 selector,\n    uint256 allowedAfterTimestamp,\n    bytes encodedCall\n)\n</code></pre> <p>Emitted when a new <code>governance</code> call has been recorded and is now waiting for the time lock to expire.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_governanceinitialised","title":"<code>GovernanceInitialised</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernanceInitialised(\n    address initialGovernance\n)\n</code></pre> <p>Emitted when the <code>governance</code> address is initialized. This address will be used until production mode is entered (see <code>GovernedProductionModeEntered</code>). At that point the <code>governance</code> address is taken from <code>GovernanceSettings</code>.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_governedproductionmodeentered","title":"<code>GovernedProductionModeEntered</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernedProductionModeEntered(\n    address governanceSettings\n)\n</code></pre> <p>Emitted when <code>governance</code> is enabled and the <code>governance</code> address cannot be changed anymore (only through a network fork).</p>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_inflationset","title":"<code>InflationSet</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>event InflationSet(\n    contract IInflationGenesis theNewContract,\n    contract IInflationGenesis theOldContract\n)\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_mintingreceived","title":"<code>MintingReceived</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>event MintingReceived(\n    uint256 amountWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_mintingrequestreceived","title":"<code>MintingRequestReceived</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>event MintingRequestReceived(\n    uint256 amountWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_mintingrequesttriggered","title":"<code>MintingRequestTriggered</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>event MintingRequestTriggered(\n    uint256 amountWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_mintingwithdrawn","title":"<code>MintingWithdrawn</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>event MintingWithdrawn(\n    uint256 amountWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_registrationupdated","title":"<code>RegistrationUpdated</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>event RegistrationUpdated(\n    contract IFlareDaemonize theContract,\n    bool add\n)\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_selfdestructreceived","title":"<code>SelfDestructReceived</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>event SelfDestructReceived(\n    uint256 amountWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_timelockedgovernancecallcanceled","title":"<code>TimelockedGovernanceCallCanceled</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event TimelockedGovernanceCallCanceled(\n    bytes4 selector,\n    uint256 timestamp\n)\n</code></pre> <p>Emitted when a timelocked <code>governance</code> call is canceled before execution.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#ev_timelockedgovernancecallexecuted","title":"<code>TimelockedGovernanceCallExecuted</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event TimelockedGovernanceCallExecuted(\n    bytes4 selector,\n    uint256 timestamp\n)\n</code></pre> <p>Emitted when a timelocked <code>governance</code> call is executed.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/FlareDaemon/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/FlareDaemon/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>constructor(\n) public;\n</code></pre> <p>This <code>constructor</code> should contain no code as this contract is pre-loaded into the genesis block.   The super <code>constructor</code> is called for testing convenience.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/FlareDaemon/#fn_getaddressupdater_5267a15d","title":"<code>getAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function getAddressUpdater(\n) public view returns (\n    address _addressUpdater);\n</code></pre> <p>Returns the configured address updater.</p> Returns Type Description <code>_addressUpdater</code> <code>address</code> The <code>AddresUpdater</code> contract that can update our contract address list, as a response to a governance call."},{"location":"apis/smart-contracts/FlareDaemon/#fn_getdaemonizedcontractsdata_ed21b6e4","title":"<code>getDaemonizedContractsData</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>function getDaemonizedContractsData(\n) external view returns (\n    contract IFlareDaemonize[] _daemonizeContracts,\n    uint256[] _gasLimits,\n    uint256[] _blockHoldoffsRemaining);\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#fn_getnextmintrequestallowedts_63903143","title":"<code>getNextMintRequestAllowedTs</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>function getNextMintRequestAllowedTs(\n) external view returns (\n    uint256);\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#fn_initialise_9d6a890f","title":"<code>initialise</code>","text":"<p>Defined in <code>GovernedAtGenesis</code> (Docs, Source).</p> <pre><code>function initialise(\n    address _governance\n) public pure;\n</code></pre> <p>Disallow <code>initialise</code> to be called.</p> Parameters Type Description <code>_governance</code> <code>address</code> The governance address for initial claiming."},{"location":"apis/smart-contracts/FlareDaemon/#fn_initialisefixedaddress_c9f960eb","title":"<code>initialiseFixedAddress</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>function initialiseFixedAddress(\n) public returns (\n    address);\n</code></pre> <p>Set the <code>governance</code> address to a hard-coded known address.</p> <p>This should be done at contract deployment time.</p> Returns Type Description [0] <code>address</code> The governance address."},{"location":"apis/smart-contracts/FlareDaemon/#fn_registertodaemonize_689c4999","title":"<code>registerToDaemonize</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>function registerToDaemonize(\n    struct FlareDaemon.Registration[] _registrations\n) external;\n</code></pre> <p>Register contracts to be polled by the daemon process.</p> <p>A gas limit of zero will set no limit for the contract but the validator has an overall   limit for the <code>trigger</code> method. If any registrations already exist, they will be unregistered. Contracts will be daemonized in the order in which presented via the _registrations array.</p> Parameters Type Description <code>_registrations</code> <code>struct FlareDaemon.Registration[]</code> An array of Registration structures of <code>IFlareDaemonize</code> contracts to daemonize                          and gas limits for each contract."},{"location":"apis/smart-contracts/FlareDaemon/#fn_requestminting_e9de7d60","title":"<code>requestMinting</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>function requestMinting(\n    uint256 _amountWei\n) external;\n</code></pre> <p>Queue up a minting request to send to the validator at next <code>trigger</code>.</p> Parameters Type Description <code>_amountWei</code> <code>uint256</code> The amount to mint."},{"location":"apis/smart-contracts/FlareDaemon/#fn_setaddressupdater_aea36b53","title":"<code>setAddressUpdater</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>function setAddressUpdater(\n    address _addressUpdater\n) external;\n</code></pre> <p>Sets the address udpater contract.</p> Parameters Type Description <code>_addressUpdater</code> <code>address</code> The address updater contract."},{"location":"apis/smart-contracts/FlareDaemon/#fn_setblockholdoff_5042916c","title":"<code>setBlockHoldoff</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>function setBlockHoldoff(\n    uint256 _blockHoldoff\n) external;\n</code></pre> <p>Set number of blocks that must elapse before a daemonized contract exceeding gas limit can have   its daemonize() method called again.</p> Parameters Type Description <code>_blockHoldoff</code> <code>uint256</code> The number of blocks to holdoff."},{"location":"apis/smart-contracts/FlareDaemon/#fn_setmaxmintingrequest_870196b8","title":"<code>setMaxMintingRequest</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>function setMaxMintingRequest(\n    uint256 _maxMintingRequestWei\n) external;\n</code></pre> <p>Set limit on how much can be minted per request. this number can't be udated too often</p> Parameters Type Description <code>_maxMintingRequestWei</code> <code>uint256</code> The request maximum in wei."},{"location":"apis/smart-contracts/FlareDaemon/#fn_showdaemonizederrors_ecdda0dd","title":"<code>showDaemonizedErrors</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>function showDaemonizedErrors(\n    uint256 startIndex,\n    uint256 numErrorTypesToShow\n) public view returns (\n    uint256[] _lastErrorBlock,\n    uint256[] _numErrors,\n    string[] _errorString,\n    address[] _erroringContract,\n    uint256 _totalDaemonizedErrors);\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#fn_showlastdaemonizederror_63d4a53a","title":"<code>showLastDaemonizedError</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>function showLastDaemonizedError(\n) external view returns (\n    uint256[] _lastErrorBlock,\n    uint256[] _numErrors,\n    string[] _errorString,\n    address[] _erroringContract,\n    uint256 _totalDaemonizedErrors);\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#fn_updatecontractaddresses_b00c0b76","title":"<code>updateContractAddresses</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function updateContractAddresses(\n    bytes32[] _contractNameHashes,\n    address[] _contractAddresses\n) external;\n</code></pre> <p>External method called from <code>AddressUpdater</code> only.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/FlareDaemon/#md_inflationset","title":"<code>inflationSet</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>modifier inflationSet()\n</code></pre> <p>As there is not a <code>constructor</code>, this modifier exists to make sure the <code>inflation</code>   contract is set for methods that require it.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#md_onlyaddressupdater","title":"<code>onlyAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>modifier onlyAddressUpdater()\n</code></pre> <p>Only the <code>AdressUpdater</code> contract can call this method. Its address is set at construction time but it can also update itself.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#md_onlygovernance","title":"<code>onlyGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#md_onlyimmediategovernance","title":"<code>onlyImmediateGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyImmediateGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#md_onlyinflation","title":"<code>onlyInflation</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>modifier onlyInflation(    address _inflation)\n</code></pre> <p>Access control to protect methods to allow only minters to call select methods   (like transferring balance out).</p>"},{"location":"apis/smart-contracts/FlareDaemon/#md_onlysystemtrigger","title":"<code>onlySystemTrigger</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>modifier onlySystemTrigger()\n</code></pre> <p>Access control to protect <code>trigger</code> method.  Please note that the sender address is the same as deployed <code>FlareDaemon</code> address in this case.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#structures","title":"Structures","text":""},{"location":"apis/smart-contracts/FlareDaemon/#st_daemonizederror","title":"<code>DaemonizedError</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>struct DaemonizedError {\n  uint192 lastErrorBlock;\n  uint64 numErrors;\n  address fromContract;\n  uint64 errorTypeIndex;\n  string errorMessage;\n}\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#st_lasterrordata","title":"<code>LastErrorData</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>struct LastErrorData {\n  uint192 totalDaemonizedErrors;\n  uint64 lastErrorTypeIndex;\n}\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#st_registration","title":"<code>Registration</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>struct Registration {\n  contract IFlareDaemonize daemonizedContract;\n  uint256 gasLimit;\n}\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#st_timelockedcall","title":"<code>TimelockedCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>struct TimelockedCall {\n  uint256 allowedAfterTimestamp;\n  bytes encodedCall;\n}\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/FlareDaemon/#va_blockholdoff","title":"<code>blockHoldoff</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>    uint256 blockHoldoff\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#va_errordata","title":"<code>errorData</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>    struct FlareDaemon.LastErrorData errorData\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#va_governancesettings","title":"<code>governanceSettings</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    contract IGovernanceSettings governanceSettings\n</code></pre> <p>Governance Settings.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#va_inflation","title":"<code>inflation</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>    contract IInflationGenesis inflation\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#va_lastmintrequestts","title":"<code>lastMintRequestTs</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>    uint256 lastMintRequestTs\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#va_lastupdatemaxmintrequestts","title":"<code>lastUpdateMaxMintRequestTs</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>    uint256 lastUpdateMaxMintRequestTs\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#va_maxmintingrequestwei","title":"<code>maxMintingRequestWei</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>    uint256 maxMintingRequestWei\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#va_productionmode","title":"<code>productionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    bool productionMode\n</code></pre> <p>When true, <code>governance</code> is enabled and cannot be disabled. See <code>switchToProductionMode</code>.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#va_systemlasttriggeredat","title":"<code>systemLastTriggeredAt</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>    uint256 systemLastTriggeredAt\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#va_timelockedcalls","title":"<code>timelockedCalls</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    mapping(bytes4 =&gt; struct GovernedBase.TimelockedCall) timelockedCalls\n</code></pre> <p>List of pending timelocked <code>governance</code> calls.</p>"},{"location":"apis/smart-contracts/FlareDaemon/#va_totalmintingreceivedwei","title":"<code>totalMintingReceivedWei</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>    uint256 totalMintingReceivedWei\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#va_totalmintingrequestedwei","title":"<code>totalMintingRequestedWei</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>    uint256 totalMintingRequestedWei\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#va_totalmintingwithdrawnwei","title":"<code>totalMintingWithdrawnWei</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>    uint256 totalMintingWithdrawnWei\n</code></pre>"},{"location":"apis/smart-contracts/FlareDaemon/#va_totalselfdestructreceivedwei","title":"<code>totalSelfDestructReceivedWei</code>","text":"<p>Defined in <code>FlareDaemon</code> (Docs, Source).</p> <pre><code>    uint256 totalSelfDestructReceivedWei\n</code></pre>"},{"location":"apis/smart-contracts/Ftso/","title":"Ftso","text":""},{"location":"apis/smart-contracts/Ftso/#ct_ftso","title":"<code>Ftso</code>","text":"<p>Source | Inherits from IIFtso</p> <p>Flare Time Series Oracle contract.</p> <p>An instance of this contract is created for each tracked asset, and typically accessed through the <code>FtsoRegistry</code>. Data providers do not access the <code>Ftso</code> instances directly either, and use the <code>PriceSubmitter</code> contract instead.</p>"},{"location":"apis/smart-contracts/Ftso/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/Ftso/#fn_activateftso_2f0a6f3c","title":"<code>activateFtso</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function activateFtso(\n    uint256 _firstEpochStartTs,\n    uint256 _submitPeriodSeconds,\n    uint256 _revealPeriodSeconds\n) external;\n</code></pre> <p>Initializes FTSO immutable settings and activates the contract.</p> <p>Can only be called by the <code>ftsoManager</code>.</p> Parameters Type Description <code>_firstEpochStartTs</code> <code>uint256</code> Timestamp of the first epoch in seconds from UNIX epoch. <code>_submitPeriodSeconds</code> <code>uint256</code> Duration of epoch submission window in seconds. <code>_revealPeriodSeconds</code> <code>uint256</code> Duration of epoch reveal window in seconds."},{"location":"apis/smart-contracts/Ftso/#fn_active_02fb0c5e","title":"<code>active</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function active(\n) external view returns (\n    bool);\n</code></pre> <p>Returns whether FTSO is <code>active</code> or not.</p>"},{"location":"apis/smart-contracts/Ftso/#fn_configureepochs_5a3c9d8e","title":"<code>configureEpochs</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function configureEpochs(\n    uint256 _maxVotePowerNatThresholdFraction,\n    uint256 _maxVotePowerAssetThresholdFraction,\n    uint256 _lowAssetUSDThreshold,\n    uint256 _highAssetUSDThreshold,\n    uint256 _highAssetTurnoutThresholdBIPS,\n    uint256 _lowNatTurnoutThresholdBIPS,\n    uint256 _elasticBandRewardBIPS,\n    uint256 _elasticBandWidthPPM,\n    address[] _trustedAddresses\n) external;\n</code></pre> <p>Sets configurable settings related to epochs.</p> <p>Can only be called by the <code>ftsoManager</code>. Should never revert if called from <code>ftsoManager</code>.</p> Parameters Type Description <code>_maxVotePowerNatThresholdFraction</code> <code>uint256</code> High threshold for native token vote power per voter. <code>_maxVotePowerAssetThresholdFraction</code> <code>uint256</code> High threshold for asset vote power per voter. <code>_lowAssetUSDThreshold</code> <code>uint256</code> Threshold for low asset vote power (in scaled USD). <code>_highAssetUSDThreshold</code> <code>uint256</code> Threshold for high asset vote power (in scaled USD). <code>_highAssetTurnoutThresholdBIPS</code> <code>uint256</code> Threshold for high asset turnout (in BIPS). <code>_lowNatTurnoutThresholdBIPS</code> <code>uint256</code> Threshold for low nat turnout (in BIPS). <code>_elasticBandRewardBIPS</code> <code>uint256</code> Percentage of the rewards (in BIPS) that go to the secondary reward band. The rest go to the primary reward band. <code>_elasticBandWidthPPM</code> <code>uint256</code> Width of the secondary reward band, in parts-per-milion of the median. <code>_trustedAddresses</code> <code>address[]</code> Trusted voters that will be used if low voter turnout is detected."},{"location":"apis/smart-contracts/Ftso/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>constructor(\n    string _symbol,\n    uint256 _decimals,\n    contract IPriceSubmitter _priceSubmitter,\n    contract IIVPToken _wNat,\n    address _ftsoManager,\n    uint256 _firstEpochStartTs,\n    uint256 _submitPeriodSeconds,\n    uint256 _revealPeriodSeconds,\n    uint128 _initialPriceUSD,\n    uint256 _priceDeviationThresholdBIPS,\n    uint256 _cyclicBufferSize\n) public;\n</code></pre>"},{"location":"apis/smart-contracts/Ftso/#fn_deactivateftso_555989da","title":"<code>deactivateFtso</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function deactivateFtso(\n) external;\n</code></pre> <p>Deactivates the contract.</p> <p>Can only be called by the <code>ftsoManager</code>.</p>"},{"location":"apis/smart-contracts/Ftso/#fn_epochsconfiguration_e3749e0c","title":"<code>epochsConfiguration</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function epochsConfiguration(\n) external view returns (\n    uint256 _maxVotePowerNatThresholdFraction,\n    uint256 _maxVotePowerAssetThresholdFraction,\n    uint256 _lowAssetUSDThreshold,\n    uint256 _highAssetUSDThreshold,\n    uint256 _highAssetTurnoutThresholdBIPS,\n    uint256 _lowNatTurnoutThresholdBIPS,\n    uint256 _elasticBandRewardBIPS,\n    uint256 _elasticBandWidthPPM,\n    address[] _trustedAddresses);\n</code></pre> <p>Returns current configuration of epoch state.</p> Returns Type Description <code>_maxVotePowerNatThresholdFraction</code> <code>uint256</code> High threshold for native token vote power per voter. <code>_maxVotePowerAssetThresholdFraction</code> <code>uint256</code> High threshold for asset vote power per voter. <code>_lowAssetUSDThreshold</code> <code>uint256</code> Threshold for low asset vote power (in scaled USD). <code>_highAssetUSDThreshold</code> <code>uint256</code> Threshold for high asset vote power (in scaled USD). <code>_highAssetTurnoutThresholdBIPS</code> <code>uint256</code> Threshold for high asset turnout (in BIPS). <code>_lowNatTurnoutThresholdBIPS</code> <code>uint256</code> Threshold for low nat turnout (in BIPS). <code>_elasticBandRewardBIPS</code> <code>uint256</code> Percentage of the rewards (in BIPS) that go to the secondary reward band. The rest go to the primary reward band. <code>_elasticBandWidthPPM</code> <code>uint256</code> Width of the secondary reward band, in parts-per-milion of the median. <code>_trustedAddresses</code> <code>address[]</code> Trusted voters that will be used if low voter turnout is detected."},{"location":"apis/smart-contracts/Ftso/#fn_fallbackfinalizepriceepoch_4afd5102","title":"<code>fallbackFinalizePriceEpoch</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function fallbackFinalizePriceEpoch(\n    uint256 _epochId\n) external;\n</code></pre> <p>Forces finalization of a price epoch, calculating the median price from trusted addresses only.</p> <p>Used as a fallback method, for example, due to an unexpected error during normal epoch finalization or because the <code>ftsoManager</code> enabled the fallback mode.</p> <p>Can only be called by the <code>ftsoManager</code>.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch to finalize."},{"location":"apis/smart-contracts/Ftso/#fn_finalizepriceepoch_40462a2d","title":"<code>finalizePriceEpoch</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function finalizePriceEpoch(\n    uint256 _epochId,\n    bool _returnRewardData\n) external returns (\n    address[] _eligibleAddresses,\n    uint256[] _natWeights,\n    uint256 _natWeightsSum);\n</code></pre> <p>Computes epoch price based on gathered votes.</p> <ul> <li>If the price reveal window for the epoch has ended, finalize the epoch.</li> <li>Iterate list of price submissions.</li> <li>Find weighted median.</li> <li>Find adjacent 50% of price submissions.</li> <li>Allocate rewards for price submissions.</li> </ul> <p>Can only be called by the <code>ftsoManager</code>, and only at the correct time.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch to finalize. <code>_returnRewardData</code> <code>bool</code> Parameter that determines if the reward data is returned. Returns Type Description <code>_eligibleAddresses</code> <code>address[]</code> List of addresses eligible for reward. <code>_natWeights</code> <code>uint256[]</code> List of native token weights corresponding to the eligible addresses. <code>_natWeightsSum</code> <code>uint256</code>"},{"location":"apis/smart-contracts/Ftso/#fn_forcefinalizepriceepoch_974d7a6b","title":"<code>forceFinalizePriceEpoch</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function forceFinalizePriceEpoch(\n    uint256 _epochId\n) external;\n</code></pre> <p>Forces finalization of a price epoch by copying the price from the previous epoch.</p> <p>Used as a fallback method if <code>fallbackFinalizePriceEpoch</code> fails due to an exception.</p> <p>Can only be called by the <code>ftsoManager</code>.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch to finalize."},{"location":"apis/smart-contracts/Ftso/#fn_ftsomanager_11a7aaaa","title":"<code>ftsoManager</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function ftsoManager(\n) external view returns (\n    address);\n</code></pre> <p>Returns the FTSO manager's address.</p> Returns Type Description [0] <code>address</code> Address of the FTSO manager contract."},{"location":"apis/smart-contracts/Ftso/#fn_getasset_5c222bad","title":"<code>getAsset</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getAsset(\n) external view returns (\n    contract IIVPToken);\n</code></pre> <p>Returns the FTSO asset.</p> Returns Type Description [0] <code>contract IIVPToken</code> Address of the <code>IIVPToken</code> tracked by this FTSO. <code>null</code> in case of multi-asset FTSO."},{"location":"apis/smart-contracts/Ftso/#fn_getassetftsos_18931c35","title":"<code>getAssetFtsos</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getAssetFtsos(\n) external view returns (\n    contract IIFtso[]);\n</code></pre> <p>Returns the asset FTSOs.</p> Returns Type Description [0] <code>contract IIFtso[]</code> Array of <code>IIFtso</code> contract addresses. <code>null</code> in case of single-asset FTSO."},{"location":"apis/smart-contracts/Ftso/#fn_getcurrentepochid_a29a839f","title":"<code>getCurrentEpochId</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getCurrentEpochId(\n) public view returns (\n    uint256);\n</code></pre> <p>Returns the current epoch ID.</p> <p>It never reverts.</p> Returns Type Description [0] <code>uint256</code> Currently running epoch ID. IDs are consecutive numbers starting from zero."},{"location":"apis/smart-contracts/Ftso/#fn_getcurrentprice_eb91d37e","title":"<code>getCurrentPrice</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getCurrentPrice(\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp);\n</code></pre> <p>Returns the current asset price.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Time when price was updated for the last time, in seconds from UNIX epoch."},{"location":"apis/smart-contracts/Ftso/#fn_getcurrentpricedetails_040d73b8","title":"<code>getCurrentPriceDetails</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getCurrentPriceDetails(\n) external view returns (\n    uint256 _price,\n    uint256 _priceTimestamp,\n    enum IFtso.PriceFinalizationType _priceFinalizationType,\n    uint256 _lastPriceEpochFinalizationTimestamp,\n    enum IFtso.PriceFinalizationType _lastPriceEpochFinalizationType);\n</code></pre> <p>Returns asset's current price details. All timestamps are in seconds from UNIX epoch.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_priceTimestamp</code> <code>uint256</code> Time when price was updated for the last time. <code>_priceFinalizationType</code> <code>enum IFtso.PriceFinalizationType</code> Finalization type when price was updated for the last time. <code>_lastPriceEpochFinalizationTimestamp</code> <code>uint256</code> Time when last price epoch was finalized. <code>_lastPriceEpochFinalizationType</code> <code>enum IFtso.PriceFinalizationType</code> Finalization type of last finalized price epoch."},{"location":"apis/smart-contracts/Ftso/#fn_getcurrentpricefromtrustedproviders_af52df08","title":"<code>getCurrentPriceFromTrustedProviders</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getCurrentPriceFromTrustedProviders(\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp);\n</code></pre> <p>Returns current asset price calculated only using input from trusted providers.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Time when price was updated for the last time, in seconds from UNIX epoch."},{"location":"apis/smart-contracts/Ftso/#fn_getcurrentpricewithdecimals_65f5cd86","title":"<code>getCurrentPriceWithDecimals</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getCurrentPriceWithDecimals(\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals);\n</code></pre> <p>Returns current asset price and number of decimals.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>_assetPriceUsdDecimals</code>. <code>_timestamp</code> <code>uint256</code> Time when price was updated for the last time, in seconds from UNIX epoch. <code>_assetPriceUsdDecimals</code> <code>uint256</code> Number of decimals used to return the USD price."},{"location":"apis/smart-contracts/Ftso/#fn_getcurrentpricewithdecimalsfromtrustedproviders_3cacb3ae","title":"<code>getCurrentPriceWithDecimalsFromTrustedProviders</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getCurrentPriceWithDecimalsFromTrustedProviders(\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals);\n</code></pre> <p>Returns current asset price calculated only using input from trusted providers and number of decimals.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Time when price was updated for the last time, in seconds from UNIX epoch. <code>_assetPriceUsdDecimals</code> <code>uint256</code> Number of decimals used to return the USD price."},{"location":"apis/smart-contracts/Ftso/#fn_getcurrentrandom_d89601fd","title":"<code>getCurrentRandom</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getCurrentRandom(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the random number for the previous price epoch, obtained from the random numbers provided by all data providers along with their data submissions.</p> <p>It never reverts.</p>"},{"location":"apis/smart-contracts/Ftso/#fn_getepochid_5303548b","title":"<code>getEpochId</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getEpochId(\n    uint256 _timestamp\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the ID of the epoch that was opened for price submission at the specified timestamp.</p> <p>It never reverts.</p> Parameters Type Description <code>_timestamp</code> <code>uint256</code> Queried timestamp in seconds from UNIX epoch. Returns Type Description [0] <code>uint256</code> Epoch ID corresponding to that timestamp. IDs are consecutive numbers starting from zero."},{"location":"apis/smart-contracts/Ftso/#fn_getepochprice_7d1d6f12","title":"<code>getEpochPrice</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getEpochPrice(\n    uint256 _epochId\n) external view returns (\n    uint256);\n</code></pre> <p>Returns agreed asset price in the specified epoch.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch. Only the last 200 epochs can be queried. Out-of-bounds queries revert. Returns Type Description [0] <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>."},{"location":"apis/smart-contracts/Ftso/#fn_getepochpriceforvoter_c5d8b9e7","title":"<code>getEpochPriceForVoter</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getEpochPriceForVoter(\n    uint256 _epochId,\n    address _voter\n) external view returns (\n    uint256);\n</code></pre> <p>Returns asset price submitted by a voter in the specified epoch.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch being queried. Only the last 200 epochs can be queried. Out-of-bounds queries revert. <code>_voter</code> <code>address</code> Address of the voter being queried. Returns Type Description [0] <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>."},{"location":"apis/smart-contracts/Ftso/#fn_getpriceepochconfiguration_144e1591","title":"<code>getPriceEpochConfiguration</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getPriceEpochConfiguration(\n) external view returns (\n    uint256 _firstEpochStartTs,\n    uint256 _submitPeriodSeconds,\n    uint256 _revealPeriodSeconds);\n</code></pre> <p>Returns current epoch's configuration.</p> Returns Type Description <code>_firstEpochStartTs</code> <code>uint256</code> First epoch start timestamp in seconds from UNIX epoch. <code>_submitPeriodSeconds</code> <code>uint256</code> Submit period in seconds. <code>_revealPeriodSeconds</code> <code>uint256</code> Reveal period in seconds."},{"location":"apis/smart-contracts/Ftso/#fn_getpriceepochdata_e3b3a3b3","title":"<code>getPriceEpochData</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getPriceEpochData(\n) external view returns (\n    uint256 _epochId,\n    uint256 _epochSubmitEndTime,\n    uint256 _epochRevealEndTime,\n    uint256 _votePowerBlock,\n    bool _fallbackMode);\n</code></pre> <p>Returns current epoch data. Intervals are open on the right: End times are not included.</p> Returns Type Description <code>_epochId</code> <code>uint256</code> Current epoch ID. <code>_epochSubmitEndTime</code> <code>uint256</code> End time of the price submission window in seconds from UNIX epoch. <code>_epochRevealEndTime</code> <code>uint256</code> End time of the price reveal window in seconds from UNIX epoch. <code>_votePowerBlock</code> <code>uint256</code> Vote power block for the current epoch. <code>_fallbackMode</code> <code>bool</code> Whether the current epoch is in fallback mode. Only votes from trusted addresses are used in this mode."},{"location":"apis/smart-contracts/Ftso/#fn_getrandom_cd4b6914","title":"<code>getRandom</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function getRandom(\n    uint256 _epochId\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the random number used in a specific past epoch, obtained from the random numbers provided by all data providers along with their data submissions.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the queried epoch. Current epoch cannot be queried, and the previous epoch is constantly updated as data providers reveal their prices and random numbers. Only the last 50 epochs can be queried and there is no bounds checking for this parameter. Out-of-bounds queries return undefined values. Returns Type Description [0] <code>uint256</code> The random number used in that epoch."},{"location":"apis/smart-contracts/Ftso/#fn_getvoteweightingparameters_8357d08c","title":"<code>getVoteWeightingParameters</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function getVoteWeightingParameters(\n) external view returns (\n    contract IIVPToken[] _assets,\n    uint256[] _assetMultipliers,\n    uint256 _totalVotePowerNat,\n    uint256 _totalVotePowerAsset,\n    uint256 _assetWeightRatio,\n    uint256 _votePowerBlock);\n</code></pre> <p>Returns parameters necessary for replicating vote weighting (used in <code>VoterWhitelister</code>).</p> Returns Type Description <code>_assets</code> <code>contract IIVPToken[]</code> The list of assets that are accounted in vote. <code>_assetMultipliers</code> <code>uint256[]</code> Weight multiplier of each asset in (multiasset) FTSO. <code>_totalVotePowerNat</code> <code>uint256</code> Total native token vote power at block. <code>_totalVotePowerAsset</code> <code>uint256</code> Total combined asset vote power at block. <code>_assetWeightRatio</code> <code>uint256</code> Ratio of combined asset vote power vs. native token vp (in BIPS). <code>_votePowerBlock</code> <code>uint256</code> Vote power block for the epoch."},{"location":"apis/smart-contracts/Ftso/#fn_initializecurrentepochstateforreveal_f670ebe3","title":"<code>initializeCurrentEpochStateForReveal</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function initializeCurrentEpochStateForReveal(\n    uint256 _circulatingSupplyNat,\n    bool _fallbackMode\n) external;\n</code></pre> <p>Initializes current epoch instance for reveal.</p> <p>Can only be called by the <code>ftsoManager</code>.</p> Parameters Type Description <code>_circulatingSupplyNat</code> <code>uint256</code> Epoch native token circulating supply. <code>_fallbackMode</code> <code>bool</code> Whether the current epoch is in fallback mode."},{"location":"apis/smart-contracts/Ftso/#fn_revealpricesubmitter_c1f6c36e","title":"<code>revealPriceSubmitter</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function revealPriceSubmitter(\n    address _voter,\n    uint256 _epochId,\n    uint256 _price,\n    uint256 _voterWNatVP\n) external;\n</code></pre> <p>Reveals the price submitted by a voter on a specific epoch. The hash of _price and _random must be equal to the submitted hash</p> <p>Emits a <code>PriceRevealed</code> event. Can only be called by the <code>priceSubmitter</code>.</p> Parameters Type Description <code>_voter</code> <code>address</code> Voter address. <code>_epochId</code> <code>uint256</code> ID of the epoch in which the price hash was submitted. <code>_price</code> <code>uint256</code> Submitted price. <code>_voterWNatVP</code> <code>uint256</code> Voter's vote power in <code>WNat</code> units."},{"location":"apis/smart-contracts/Ftso/#fn_setasset_d0d552dd","title":"<code>setAsset</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function setAsset(\n    contract IIVPToken _asset\n) external;\n</code></pre> <p>Sets asset for FTSO to operate as single-asset oracle.</p> <p>Can only be called by the <code>ftsoManager</code>.</p> Parameters Type Description <code>_asset</code> <code>contract IIVPToken</code> Address of the <code>IIVPToken</code> contract that will be the asset tracked by this FTSO."},{"location":"apis/smart-contracts/Ftso/#fn_setassetftsos_131fdee2","title":"<code>setAssetFtsos</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function setAssetFtsos(\n    contract IIFtso[] _assetFtsos\n) external;\n</code></pre> <p>Sets an array of FTSOs for FTSO to operate as multi-asset oracle. FTSOs implicitly determine the FTSO <code>assets</code>.</p> <p>Can only be called by the <code>ftsoManager</code>.</p> Parameters Type Description <code>_assetFtsos</code> <code>contract IIFtso[]</code> Array of FTSOs."},{"location":"apis/smart-contracts/Ftso/#fn_setvotepowerblock_e536f396","title":"<code>setVotePowerBlock</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function setVotePowerBlock(\n    uint256 _votePowerBlock\n) external;\n</code></pre> <p>Sets the current vote power block. Current vote power block will update per reward epoch. The FTSO doesn't have notion of reward epochs.</p> <p>Can only be called by the <code>ftsoManager</code>.</p> Parameters Type Description <code>_votePowerBlock</code> <code>uint256</code>"},{"location":"apis/smart-contracts/Ftso/#fn_symbol_95d89b41","title":"<code>symbol</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function symbol(\n) external view returns (\n    string);\n</code></pre> <p>Returns the FTSO <code>symbol</code>.</p>"},{"location":"apis/smart-contracts/Ftso/#fn_updateinitialprice_306ba253","title":"<code>updateInitialPrice</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function updateInitialPrice(\n    uint256 _initialPriceUSD,\n    uint256 _initialPriceTimestamp\n) external;\n</code></pre> <p>Updates initial asset price when the contract is not <code>active</code> yet.</p> <p>Can only be called by the <code>ftsoManager</code>.</p>"},{"location":"apis/smart-contracts/Ftso/#fn_wnat_9edbf007","title":"<code>wNat</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function wNat(\n) external view returns (\n    contract IIVPToken);\n</code></pre> <p>Address of the <code>WNat</code> contract.</p> Returns Type Description [0] <code>contract IIVPToken</code> Address of the <code>WNat</code> contract."},{"location":"apis/smart-contracts/Ftso/#fn_wnatvotepowercached_f72cab28","title":"<code>wNatVotePowerCached</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>function wNatVotePowerCached(\n    address _owner,\n    uint256 _epochId\n) public returns (\n    uint256);\n</code></pre> <p>Get and cache the vote power of a voter on a specific epoch, in <code>WNat</code> units.</p> Parameters Type Description <code>_owner</code> <code>address</code> <code>_epochId</code> <code>uint256</code> ID of the epoch in which the price hash was submitted. Returns Type Description [0] <code>uint256</code> Voter's vote power in <code>WNat</code> units."},{"location":"apis/smart-contracts/Ftso/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/Ftso/#md_onlyftsomanager","title":"<code>onlyFtsoManager</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>modifier onlyFtsoManager()\n</code></pre> <p>Only the <code>ftsoManager</code> can call this method.</p>"},{"location":"apis/smart-contracts/Ftso/#md_onlypricesubmitter","title":"<code>onlyPriceSubmitter</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>modifier onlyPriceSubmitter()\n</code></pre> <p>Only the <code>priceSubmitter</code> can call this method.</p>"},{"location":"apis/smart-contracts/Ftso/#md_whenactive","title":"<code>whenActive</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>modifier whenActive()\n</code></pre> <p>This method can only be called when the FTSO is <code>active</code>.</p>"},{"location":"apis/smart-contracts/Ftso/#structures","title":"Structures","text":""},{"location":"apis/smart-contracts/Ftso/#st_rewarddata","title":"<code>RewardData</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>struct RewardData {\n  uint256[] weightIQR;\n  uint256[] weightElasticBand;\n  uint256 weightsIQRSum;\n  uint256 weightsElasticBandSum;\n  uint256 numberOfVotes;\n  uint256 elasticBandRewardBIPS;\n}\n</code></pre>"},{"location":"apis/smart-contracts/Ftso/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/Ftso/#va_asset_price_usd_decimals","title":"<code>ASSET_PRICE_USD_DECIMALS</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>    uint256 ASSET_PRICE_USD_DECIMALS\n</code></pre> <p>Number of decimal places in an asset's USD price. Actual USD price is the integer value divided by 10^<code>ASSET_PRICE_USD_DECIMALS</code></p>"},{"location":"apis/smart-contracts/Ftso/#va_active","title":"<code>active</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>    bool active\n</code></pre> <p>Activation status of this FTSO.</p>"},{"location":"apis/smart-contracts/Ftso/#va_assetftsos","title":"<code>assetFtsos</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>    contract IIFtso[] assetFtsos\n</code></pre> <p>Array of addresses of other <code>Ftso</code> contracts tracked by this multi-asset FTSO.</p>"},{"location":"apis/smart-contracts/Ftso/#va_assets","title":"<code>assets</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>    contract IIVPToken[] assets\n</code></pre> <p>Array of addresses of the tracked <code>assets</code>.</p>"},{"location":"apis/smart-contracts/Ftso/#va_ftsomanager","title":"<code>ftsoManager</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>    address ftsoManager\n</code></pre> <p>Address of the <code>FtsoManager</code> contract.</p>"},{"location":"apis/smart-contracts/Ftso/#va_pricedeviationthresholdbips","title":"<code>priceDeviationThresholdBIPS</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>    uint256 priceDeviationThresholdBIPS\n</code></pre> <p>Threshold for price deviation between consecutive epochs.</p>"},{"location":"apis/smart-contracts/Ftso/#va_priceepochcyclicbuffersize","title":"<code>priceEpochCyclicBufferSize</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>    uint256 priceEpochCyclicBufferSize\n</code></pre> <p>Amount of stored prices for past epochs, set at construction time.</p>"},{"location":"apis/smart-contracts/Ftso/#va_pricesubmitter","title":"<code>priceSubmitter</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>    contract IPriceSubmitter priceSubmitter\n</code></pre> <p>Address of the <code>PriceSubmitter</code> contract.</p>"},{"location":"apis/smart-contracts/Ftso/#va_symbol","title":"<code>symbol</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>    string symbol\n</code></pre> <p>Asset <code>symbol</code> that identifies this FTSO.</p>"},{"location":"apis/smart-contracts/Ftso/#va_wnat","title":"<code>wNat</code>","text":"<p>Defined in <code>Ftso</code> (Docs, Source).</p> <pre><code>    contract IIVPToken wNat\n</code></pre> <p>Address of the wrapped native token (<code>WNat</code>) contract.</p>"},{"location":"apis/smart-contracts/FtsoManager/","title":"FtsoManager","text":""},{"location":"apis/smart-contracts/FtsoManager/#ct_ftsomanager","title":"<code>FtsoManager</code>","text":"<p>Source | Inherits from IIFtsoManager, GovernedAndFlareDaemonized, AddressUpdatable, RevertErrorTracking</p> <p>FTSO Manager contract.</p> <p>It is in charge of:</p> <ul> <li>Defining reward epochs (few days).</li> <li>Choosing a single block each reward epoch that represents vote power of this epoch.</li> <li>Keeping track of all FTSO contracts.</li> <li>Every price epoch (few minutes):<ul> <li>Randomly choose one FTSO for rewarding calculations.</li> <li>Trigger finalize price reveal epoch.</li> <li>Determine addresses and reward weights and triggers reward distribution.</li> </ul> </li> </ul>"},{"location":"apis/smart-contracts/FtsoManager/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/FtsoManager/#fn_activate_0f15f4c0","title":"<code>activate</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function activate(\n) external;\n</code></pre> <p>Activates FTSO manager (<code>daemonize</code> will run jobs).</p> <p>Only <code>governance</code> can call this method.</p>"},{"location":"apis/smart-contracts/FtsoManager/#fn_active_02fb0c5e","title":"<code>active</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function active(\n) external view returns (\n    bool);\n</code></pre> <p>Returns whether the FTSO Manager is <code>active</code> or not.</p> Returns Type Description [0] <code>bool</code> bool Active status."},{"location":"apis/smart-contracts/FtsoManager/#fn_addftso_2663f1b4","title":"<code>addFtso</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function addFtso(\n    contract IIFtso _ftso\n) external;\n</code></pre> <p>Adds FTSO to the list of managed FTSOs, to support a new price pair. All FTSOs in a multi-asset FTSO must be managed by the same FTSO manager.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_ftso</code> <code>contract IIFtso</code> FTSO contract address to add."},{"location":"apis/smart-contracts/FtsoManager/#fn_addftsosbulk_d429cfe5","title":"<code>addFtsosBulk</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function addFtsosBulk(\n    contract IIFtso[] _ftsos\n) external;\n</code></pre> <p>Adds a list of FTSOs to the list of managed FTSOs, to support new price pairs. All FTSOs in a multi-asset FTSO must be managed by the same FTSO manager.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_ftsos</code> <code>contract IIFtso[]</code> Array of FTSO contract addresses to add."},{"location":"apis/smart-contracts/FtsoManager/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/FtsoManager/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance,\n    contract FlareDaemon _flareDaemon,\n    address _addressUpdater,\n    contract IIFtsoManagerV1 _oldFtsoManager,\n    uint256 _firstPriceEpochStartTs,\n    uint256 _priceEpochDurationSeconds,\n    uint256 _revealEpochDurationSeconds,\n    uint256 _firstRewardEpochStartTs,\n    uint256 _rewardEpochDurationSeconds,\n    uint256 _votePowerIntervalFraction\n) public;\n</code></pre>"},{"location":"apis/smart-contracts/FtsoManager/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>GovernedAndFlareDaemonized</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance,\n    contract FlareDaemon _flareDaemon\n) public;\n</code></pre>"},{"location":"apis/smart-contracts/FtsoManager/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>Governed</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance\n) public;\n</code></pre> Parameters Type Description <code>_governance</code> <code>address</code> Governance contract. Must not be zero."},{"location":"apis/smart-contracts/FtsoManager/#fn_currentrewardepochends_d89c39e6","title":"<code>currentRewardEpochEnds</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function currentRewardEpochEnds(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns when the current reward epoch finishes.</p> Returns Type Description [0] <code>uint256</code> uint256 Time in seconds since the UNIX epoch when the current reward epoch will finish."},{"location":"apis/smart-contracts/FtsoManager/#fn_daemonize_6d0e8c34","title":"<code>daemonize</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function daemonize(\n) external returns (\n    bool);\n</code></pre> <p>Implement this function to receive a trigger from the <code>FlareDaemon</code>. The trigger method is called by the validator right at the end of block state transition.</p> <p>Only <code>flareDaemon</code> can call this method.</p> Returns Type Description [0] <code>bool</code> bool Whether the contract is still active after the call. Currently unused."},{"location":"apis/smart-contracts/FtsoManager/#fn_deactivateftsos_8de306b1","title":"<code>deactivateFtsos</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function deactivateFtsos(\n    contract IIFtso[] _ftsos\n) external;\n</code></pre> <p>Deactivates FTSOs that are no longer used on FTSO registry. Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_ftsos</code> <code>contract IIFtso[]</code> Array of FTSO contract addresses to deactivate."},{"location":"apis/smart-contracts/FtsoManager/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/FtsoManager/#fn_ftsoregistry_38b5f869","title":"<code>ftsoRegistry</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function ftsoRegistry(\n) external view returns (\n    contract IIFtsoRegistry);\n</code></pre> <p>Returns the <code>FtsoRegistry</code> contract address.</p>"},{"location":"apis/smart-contracts/FtsoManager/#fn_getaddressupdater_5267a15d","title":"<code>getAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function getAddressUpdater(\n) public view returns (\n    address _addressUpdater);\n</code></pre> <p>Returns the configured address updater.</p> Returns Type Description <code>_addressUpdater</code> <code>address</code> The <code>AddresUpdater</code> contract that can update our contract address list, as a response to a governance call."},{"location":"apis/smart-contracts/FtsoManager/#fn_getcontractname_f5f5ba72","title":"<code>getContractName</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getContractName(\n) external pure returns (\n    string);\n</code></pre> <p>Implement this function to allow updating daemonized contracts through the <code>AddressUpdater</code>.</p> Returns Type Description [0] <code>string</code> string Contract name."},{"location":"apis/smart-contracts/FtsoManager/#fn_getcurrentpriceepochdata_93a79025","title":"<code>getCurrentPriceEpochData</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getCurrentPriceEpochData(\n) external view returns (\n    uint256 _priceEpochId,\n    uint256 _priceEpochStartTimestamp,\n    uint256 _priceEpochEndTimestamp,\n    uint256 _priceEpochRevealEndTimestamp,\n    uint256 _currentTimestamp);\n</code></pre> <p>Returns timing information for the current price epoch. All intervals are half-closed: end time is not included. All timestamps are in seconds since UNIX epoch.</p> <p>See the FTSO page for information about the different submission phases.</p> Returns Type Description <code>_priceEpochId</code> <code>uint256</code> Price epoch ID. <code>_priceEpochStartTimestamp</code> <code>uint256</code> Beginning of the commit phase. <code>_priceEpochEndTimestamp</code> <code>uint256</code> End of the commit phase. <code>_priceEpochRevealEndTimestamp</code> <code>uint256</code> End of the reveal phase. <code>_currentTimestamp</code> <code>uint256</code> Current time."},{"location":"apis/smart-contracts/FtsoManager/#fn_getcurrentpriceepochid_08a7f402","title":"<code>getCurrentPriceEpochId</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getCurrentPriceEpochId(\n) external view returns (\n    uint256 _priceEpochId);\n</code></pre> <p>Returns current price epoch ID.</p> Returns Type Description <code>_priceEpochId</code> <code>uint256</code> Currently running epoch ID. IDs are consecutive numbers starting from zero."},{"location":"apis/smart-contracts/FtsoManager/#fn_getcurrentrewardepoch_e7c830d4","title":"<code>getCurrentRewardEpoch</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getCurrentRewardEpoch(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns current reward epoch ID (the one currently running).</p> Returns Type Description [0] <code>uint256</code> Reward epoch ID. A monotonically increasing integer."},{"location":"apis/smart-contracts/FtsoManager/#fn_getelasticbandwidthppmftso_5bb44e9a","title":"<code>getElasticBandWidthPPMFtso</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getElasticBandWidthPPMFtso(\n    contract IIFtso _ftso\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the secondary band's width in PPM (parts-per-million) of the median value, for a given FTSO.</p> Parameters Type Description <code>_ftso</code> <code>contract IIFtso</code> The queried FTSO contract address. Returns Type Description [0] <code>uint256</code> uint256 Secondary band width in PPM. To obtain the actual band width, divide this number by 10^6 and multiply by the price median value."},{"location":"apis/smart-contracts/FtsoManager/#fn_getfallbackmode_4b48dd5e","title":"<code>getFallbackMode</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getFallbackMode(\n) external view returns (\n    bool _fallbackMode,\n    contract IIFtso[] _ftsos,\n    bool[] _ftsoInFallbackMode);\n</code></pre> <p>Returns whether the FTSO Manager is currently in fallback mode.</p> <p>In this mode only submissions from trusted providers are used.</p> Returns Type Description <code>_fallbackMode</code> <code>bool</code> True if fallback mode is enabled for the manager. <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all currently active FTSO assets. <code>_ftsoInFallbackMode</code> <code>bool[]</code> Boolean array indicating which FTSO assets are in fallback mode. If the FTSO Manager is in fallback mode then ALL FTSOs are in fallback mode."},{"location":"apis/smart-contracts/FtsoManager/#fn_getftsos_ce69f833","title":"<code>getFtsos</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getFtsos(\n) external view returns (\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Returns the list of currently <code>active</code> FTSOs.</p> Returns Type Description <code>_ftsos</code> <code>contract IIFtso[]</code> Array of contract addresses for the FTSOs."},{"location":"apis/smart-contracts/FtsoManager/#fn_getgovernanceparameters_5835cf30","title":"<code>getGovernanceParameters</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getGovernanceParameters(\n) external view returns (\n    uint256 _maxVotePowerNatThresholdFraction,\n    uint256 _maxVotePowerAssetThresholdFraction,\n    uint256 _lowAssetUSDThreshold,\n    uint256 _highAssetUSDThreshold,\n    uint256 _highAssetTurnoutThresholdBIPS,\n    uint256 _lowNatTurnoutThresholdBIPS,\n    uint256 _elasticBandRewardBIPS,\n    uint256 _rewardExpiryOffsetSeconds,\n    address[] _trustedAddresses,\n    bool _initialized,\n    bool _changed);\n</code></pre> <p>Returns <code>governance</code> parameters for FTSOs.</p> Returns Type Description <code>_maxVotePowerNatThresholdFraction</code> <code>uint256</code> High threshold for native token vote power per voter. <code>_maxVotePowerAssetThresholdFraction</code> <code>uint256</code> High threshold for asset vote power per voter <code>_lowAssetUSDThreshold</code> <code>uint256</code> Threshold for low asset vote power (in scaled USD). <code>_highAssetUSDThreshold</code> <code>uint256</code> Threshold for high asset vote power (in scaled USD). <code>_highAssetTurnoutThresholdBIPS</code> <code>uint256</code> Threshold for high asset turnout (in BIPS). <code>_lowNatTurnoutThresholdBIPS</code> <code>uint256</code> Threshold for low nat turnout (in BIPS). <code>_elasticBandRewardBIPS</code> <code>uint256</code> Secondary reward band, where _elasticBandRewardBIPS goes to the secondary band and 10000 - _elasticBandRewardBIPS to the primary (IQR) band. <code>_rewardExpiryOffsetSeconds</code> <code>uint256</code> Reward epochs closed earlier than block.timestamp - _rewardExpiryOffsetSeconds expire. <code>_trustedAddresses</code> <code>address[]</code> Trusted addresses will be used as a fallback mechanism for setting the price. <code>_initialized</code> <code>bool</code> <code>_changed</code> <code>bool</code>"},{"location":"apis/smart-contracts/FtsoManager/#fn_getlastunprocessedpriceepochdata_6ca051e6","title":"<code>getLastUnprocessedPriceEpochData</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getLastUnprocessedPriceEpochData(\n) external view returns (\n    uint256 _lastUnprocessedPriceEpoch,\n    uint256 _lastUnprocessedPriceEpochRevealEnds,\n    bool _lastUnprocessedPriceEpochInitialized);\n</code></pre> <p>Returns information regarding the currently unprocessed price epoch. This epoch is not necessarily the last one, in case the network halts for some time due to validator node problems, for example.</p> Returns Type Description <code>_lastUnprocessedPriceEpoch</code> <code>uint256</code> ID of the price epoch that is currently waiting finalization. <code>_lastUnprocessedPriceEpochRevealEnds</code> <code>uint256</code> When that price epoch can be finalized, in seconds since UNIX epoch. <code>_lastUnprocessedPriceEpochInitialized</code> <code>bool</code> Whether this price epoch has been already initialized and therefore it must be finalized before the corresponding reward epoch can be finalized."},{"location":"apis/smart-contracts/FtsoManager/#fn_getpriceepochconfiguration_144e1591","title":"<code>getPriceEpochConfiguration</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getPriceEpochConfiguration(\n) external view returns (\n    uint256 _firstPriceEpochStartTs,\n    uint256 _priceEpochDurationSeconds,\n    uint256 _revealEpochDurationSeconds);\n</code></pre> <p>Returns the current values for price epoch timing configuration.</p> <p>See the FTSO page for information about the different submission phases.</p> Returns Type Description <code>_firstPriceEpochStartTs</code> <code>uint256</code> Timestamp, in seconds since UNIX epoch, of the first price epoch. <code>_priceEpochDurationSeconds</code> <code>uint256</code> Duration in seconds of the commit phase. <code>_revealEpochDurationSeconds</code> <code>uint256</code> Duration in seconds of the reveal phase."},{"location":"apis/smart-contracts/FtsoManager/#fn_getpricesubmitter_0e063d7d","title":"<code>getPriceSubmitter</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getPriceSubmitter(\n) external view returns (\n    contract IIPriceSubmitter);\n</code></pre> <p>Returns the <code>PriceSubmitter</code> contract.</p>"},{"location":"apis/smart-contracts/FtsoManager/#fn_getrewardepochconfiguration_1cb513f7","title":"<code>getRewardEpochConfiguration</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochConfiguration(\n) external view returns (\n    uint256 _firstRewardEpochStartTs,\n    uint256 _rewardEpochDurationSeconds);\n</code></pre> <p>Returns the current values for reward epoch timing configuration.</p> <p>See the Reward epochs box.</p> Returns Type Description <code>_firstRewardEpochStartTs</code> <code>uint256</code> Timestamp, in seconds since UNIX epoch, of the first reward epoch. <code>_rewardEpochDurationSeconds</code> <code>uint256</code> Duration in seconds of the reward epochs."},{"location":"apis/smart-contracts/FtsoManager/#fn_getrewardepochdata_e5399da3","title":"<code>getRewardEpochData</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochData(\n    uint256 _rewardEpochId\n) public view returns (\n    struct IIFtsoManager.RewardEpochData);\n</code></pre> <p>Returns data regarding a specific reward epoch ID.</p> Parameters Type Description <code>_rewardEpochId</code> <code>uint256</code> Epoch ID. Returns Type Description [0] <code>struct IIFtsoManager.RewardEpochData</code> RewardEpochData Its associated data."},{"location":"apis/smart-contracts/FtsoManager/#fn_getrewardepochtoexpirenext_3e7ff857","title":"<code>getRewardEpochToExpireNext</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochToExpireNext(\n) external view returns (\n    uint256);\n</code></pre> <p>Return reward epoch that will expire next, when a new reward epoch is initialized.</p> <p>Reward epochs older than 90 days expire, and any unclaimed rewards in them become inaccessible.</p> Returns Type Description [0] <code>uint256</code> uint256 Reward epoch ID."},{"location":"apis/smart-contracts/FtsoManager/#fn_getrewardepochvotepowerblock_f2edab5a","title":"<code>getRewardEpochVotePowerBlock</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochVotePowerBlock(\n    uint256 _rewardEpoch\n) external view returns (\n    uint256 _votepowerBlock);\n</code></pre> <p>Returns the vote power block that was used for a past reward epoch.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> The queried reward epoch ID. Returns Type Description <code>_votepowerBlock</code> <code>uint256</code> uint256 The block number of that reward epoch's vote power block."},{"location":"apis/smart-contracts/FtsoManager/#fn_getrewardexpiryoffsetseconds_ec31db0c","title":"<code>getRewardExpiryOffsetSeconds</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getRewardExpiryOffsetSeconds(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the currently configured reward expiration time.</p> Returns Type Description [0] <code>uint256</code> uint256 Unclaimed rewards accrued in reward epochs more than this amount of seconds in the past expire and become inaccessible."},{"location":"apis/smart-contracts/FtsoManager/#fn_getupdategovernanceparametersts_a157713b","title":"<code>getUpdateGovernanceParametersTs</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getUpdateGovernanceParametersTs(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the timestamp, in seconds since UNIX epoch, when the scheduled new settings will take effect.</p>"},{"location":"apis/smart-contracts/FtsoManager/#fn_getvotepowerintervalfraction_60f2c5b2","title":"<code>getVotePowerIntervalFraction</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function getVotePowerIntervalFraction(\n) external view returns (\n    uint256);\n</code></pre>"},{"location":"apis/smart-contracts/FtsoManager/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/FtsoManager/#fn_notinitializedftsos_823033a9","title":"<code>notInitializedFtsos</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function notInitializedFtsos(\n    contract IIFtso _ftso\n) external view returns (\n    bool);\n</code></pre> <p>Returns whether an FTSO has been initialized.</p> Returns Type Description [0] <code>bool</code> bool Initialization state."},{"location":"apis/smart-contracts/FtsoManager/#fn_removeftso_a670ff87","title":"<code>removeFtso</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function removeFtso(\n    contract IIFtso _ftso\n) external;\n</code></pre> <p>Removes an FTSO from the list of managed FTSOs. Reverts if FTSO is used in a multi-asset FTSO. Deactivates the <code>_ftso</code>.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_ftso</code> <code>contract IIFtso</code> FTSO contract address to remove."},{"location":"apis/smart-contracts/FtsoManager/#fn_replaceftso_3758e679","title":"<code>replaceFtso</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function replaceFtso(\n    contract IIFtso _ftsoToAdd,\n    bool _copyCurrentPrice,\n    bool _copyAssetOrAssetFtsos\n) external;\n</code></pre> <p>Replaces one FTSO with another with the same symbol. All FTSOs in a multi-asset FTSO must be managed by the same FTSO manager. Deactivates the old FTSO.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_ftsoToAdd</code> <code>contract IIFtso</code> FTSO contract address to add. An existing FTSO with the same symbol will be removed. <code>_copyCurrentPrice</code> <code>bool</code> <code>_copyAssetOrAssetFtsos</code> <code>bool</code>"},{"location":"apis/smart-contracts/FtsoManager/#fn_replaceftsosbulk_758ff1da","title":"<code>replaceFtsosBulk</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function replaceFtsosBulk(\n    contract IIFtso[] _ftsosToAdd,\n    bool _copyCurrentPrice,\n    bool _copyAssetOrAssetFtsos\n) external;\n</code></pre> <p>Replaces a list of FTSOs with other FTSOs with the same symbol. All FTSOs in a multi-asset FTSO must be managed by the same FTSO manager. Deactivates the old FTSOs.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_ftsosToAdd</code> <code>contract IIFtso[]</code> Array of FTSO contract addresses to add. Every existing FTSO with the same symbols will be removed. <code>_copyCurrentPrice</code> <code>bool</code> <code>_copyAssetOrAssetFtsos</code> <code>bool</code>"},{"location":"apis/smart-contracts/FtsoManager/#fn_rewardepochdurationseconds_85f3c9c9","title":"<code>rewardEpochDurationSeconds</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function rewardEpochDurationSeconds(\n) external view returns (\n    uint256);\n</code></pre> <p>Currently configured reward epoch duration.</p> Returns Type Description [0] <code>uint256</code> uint256 Reward epoch duration, in seconds."},{"location":"apis/smart-contracts/FtsoManager/#fn_rewardepochs_a795f409","title":"<code>rewardEpochs</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function rewardEpochs(\n    uint256 _rewardEpochId\n) external view returns (\n    uint256 _votepowerBlock,\n    uint256 _startBlock,\n    uint256 _startTimestamp);\n</code></pre> <p>Returns information about a reward epoch.</p> Parameters Type Description <code>_rewardEpochId</code> <code>uint256</code> The epoch ID to query. Returns Type Description <code>_votepowerBlock</code> <code>uint256</code> The vote power block of the epoch. <code>_startBlock</code> <code>uint256</code> The first block of the epoch. <code>_startTimestamp</code> <code>uint256</code> Timestamp of the epoch start, in seconds since UNIX epoch."},{"location":"apis/smart-contracts/FtsoManager/#fn_rewardepochsstartts_a578f55b","title":"<code>rewardEpochsStartTs</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function rewardEpochsStartTs(\n) external view returns (\n    uint256);\n</code></pre> <p>Time when the current reward epoch started.</p> Returns Type Description [0] <code>uint256</code> uint256 Timestamp, in seconds since UNIX epoch."},{"location":"apis/smart-contracts/FtsoManager/#fn_setelasticbandwidthppmftsos_882376c3","title":"<code>setElasticBandWidthPPMFtsos</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function setElasticBandWidthPPMFtsos(\n    uint256 _updateTs,\n    contract IIFtso[] _ftsos,\n    uint256[] _widths\n) external;\n</code></pre> <p>Sets elastic band widths in PPM (parts-per-million) for given FTSOs. Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_updateTs</code> <code>uint256</code> Timestamp when the changes will take effect, in seconds from UNIX epoch. <code>_ftsos</code> <code>contract IIFtso[]</code> Array of FTSO contract addresses to update. <code>_widths</code> <code>uint256[]</code> Array of secondary band widths in PPM. To obtain the actual band width, this number is divided by 10^6 and multiplied by the price median value."},{"location":"apis/smart-contracts/FtsoManager/#fn_setfallbackmode_ff882fbb","title":"<code>setFallbackMode</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function setFallbackMode(\n    bool _fallbackMode\n) external;\n</code></pre> <p>Sets whether the FTSO Manager is currently in fallback mode. In this mode only submissions from trusted providers are used.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_fallbackMode</code> <code>bool</code> True if fallback mode is enabled."},{"location":"apis/smart-contracts/FtsoManager/#fn_setftsoasset_6b65cc34","title":"<code>setFtsoAsset</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function setFtsoAsset(\n    contract IIFtso _ftso,\n    contract IIVPToken _asset\n) external;\n</code></pre> <p>Sets the asset tracked by an FTSO.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_ftso</code> <code>contract IIFtso</code> The FTSO contract address. <code>_asset</code> <code>contract IIVPToken</code> The <code>VPToken</code> contract address of the asset to track."},{"location":"apis/smart-contracts/FtsoManager/#fn_setftsoassetftsos_a93a6f42","title":"<code>setFtsoAssetFtsos</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function setFtsoAssetFtsos(\n    contract IIFtso _ftso,\n    contract IIFtso[] _assetFtsos\n) external;\n</code></pre> <p>Sets an array of FTSOs to be tracked by a multi-asset FTSO. FTSOs implicitly determine the FTSO assets.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_ftso</code> <code>contract IIFtso</code> The multi-asset FTSO contract address. <code>_assetFtsos</code> <code>contract IIFtso[]</code> Array of FTSOs to be tracked."},{"location":"apis/smart-contracts/FtsoManager/#fn_setftsofallbackmode_af946af7","title":"<code>setFtsoFallbackMode</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function setFtsoFallbackMode(\n    contract IIFtso _ftso,\n    bool _fallbackMode\n) external;\n</code></pre> <p>Sets whether an FTSO is currently in fallback mode. In this mode only submissions from trusted providers are used.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_ftso</code> <code>contract IIFtso</code> The FTSO contract address. <code>_fallbackMode</code> <code>bool</code> Fallback mode."},{"location":"apis/smart-contracts/FtsoManager/#fn_setgovernanceparameters_13226793","title":"<code>setGovernanceParameters</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function setGovernanceParameters(\n    uint256 _updateTs,\n    uint256 _maxVotePowerNatThresholdFraction,\n    uint256 _maxVotePowerAssetThresholdFraction,\n    uint256 _lowAssetUSDThreshold,\n    uint256 _highAssetUSDThreshold,\n    uint256 _highAssetTurnoutThresholdBIPS,\n    uint256 _lowNatTurnoutThresholdBIPS,\n    uint256 _elasticBandRewardBIPS,\n    uint256 _rewardExpiryOffsetSeconds,\n    address[] _trustedAddresses\n) external;\n</code></pre> <p>Sets <code>governance</code> parameters for FTSOs</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_updateTs</code> <code>uint256</code> Time, in seconds since UNIX epoch, when updated settings should be pushed to FTSOs. <code>_maxVotePowerNatThresholdFraction</code> <code>uint256</code> High threshold for native token vote power per voter. <code>_maxVotePowerAssetThresholdFraction</code> <code>uint256</code> High threshold for asset vote power per voter <code>_lowAssetUSDThreshold</code> <code>uint256</code> Threshold for low asset vote power (in scaled USD). <code>_highAssetUSDThreshold</code> <code>uint256</code> Threshold for high asset vote power (in scaled USD). <code>_highAssetTurnoutThresholdBIPS</code> <code>uint256</code> Threshold for high asset turnout (in BIPS). <code>_lowNatTurnoutThresholdBIPS</code> <code>uint256</code> Threshold for low nat turnout (in BIPS). <code>_elasticBandRewardBIPS</code> <code>uint256</code> Secondary reward band, where _elasticBandRewardBIPS goes to the secondary band and 10000 - _elasticBandRewardBIPS to the primary (IQR) band. <code>_rewardExpiryOffsetSeconds</code> <code>uint256</code> Reward epochs closed earlier than block.timestamp - _rewardExpiryOffsetSeconds expire. <code>_trustedAddresses</code> <code>address[]</code> Trusted addresses will be used as a fallback mechanism for setting the price."},{"location":"apis/smart-contracts/FtsoManager/#fn_setinitialrewarddata_e080a970","title":"<code>setInitialRewardData</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function setInitialRewardData(\n    uint256 _nextRewardEpochToExpire,\n    uint256 _rewardEpochsLength,\n    uint256 _currentRewardEpochEnds\n) external;\n</code></pre> <p>Set reward data to values from old ftso manager. Can only be called before activation.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_nextRewardEpochToExpire</code> <code>uint256</code> See <code>getRewardEpochToExpireNext</code>. <code>_rewardEpochsLength</code> <code>uint256</code> See <code>getRewardEpochConfiguration</code>. <code>_currentRewardEpochEnds</code> <code>uint256</code> See <code>getCurrentRewardEpoch</code>."},{"location":"apis/smart-contracts/FtsoManager/#fn_setrewardepochdurationseconds_132c7e1f","title":"<code>setRewardEpochDurationSeconds</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function setRewardEpochDurationSeconds(\n    uint256 _rewardEpochDurationSeconds\n) external;\n</code></pre> <p>Sets the reward epoch duration. Only <code>governance</code> can call this method.</p> <p>If the reward epoch is very short and the expiry offset is very long, the list of reward epochs to be checked becomes very long. Therefore reward epoch time has to be capped to expiry offset.</p>"},{"location":"apis/smart-contracts/FtsoManager/#fn_setupdateonrewardepochswitchover_3fdeb7e1","title":"<code>setUpdateOnRewardEpochSwitchover</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function setUpdateOnRewardEpochSwitchover(\n    contract IUpdateValidators _updateValidators\n) external;\n</code></pre> <p>Unused.</p>"},{"location":"apis/smart-contracts/FtsoManager/#fn_setusegoodrandom_a90a38e1","title":"<code>setUseGoodRandom</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function setUseGoodRandom(\n    bool _useGoodRandom,\n    uint256 _maxWaitForGoodRandomSeconds\n) external;\n</code></pre> <p>Allow <code>governance</code> to switch to good random numbers only. Only <code>governance</code> can call this method.</p> <p>See <code>IFtsoManager</code>.<code>UseGoodRandomSet</code>.</p> Parameters Type Description <code>_useGoodRandom</code> <code>bool</code> Whether good random numbers should be used or not. <code>_maxWaitForGoodRandomSeconds</code> <code>uint256</code> Max time in seconds to wait for the good random. If there is none after given time, reward epoch finalization should proceed anyway."},{"location":"apis/smart-contracts/FtsoManager/#fn_setvotepowerintervalfraction_361b5459","title":"<code>setVotePowerIntervalFraction</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function setVotePowerIntervalFraction(\n    uint256 _votePowerIntervalFraction\n) external;\n</code></pre>"},{"location":"apis/smart-contracts/FtsoManager/#fn_showlastrevertederror_2b3c41a4","title":"<code>showLastRevertedError</code>","text":"<p>Defined in <code>RevertErrorTracking</code> (Docs, Source).</p> <pre><code>function showLastRevertedError(\n) external view returns (\n    uint256[] _lastErrorBlock,\n    uint256[] _numErrors,\n    string[] _errorString,\n    address[] _erroringContract,\n    uint256 _totalRevertedErrors);\n</code></pre> <p>Returns latest error information. All arrays will contain only one entry.</p> Returns Type Description <code>_lastErrorBlock</code> <code>uint256[]</code> Array of block numbers where the errors occurred. <code>_numErrors</code> <code>uint256[]</code> Array of number of times same error with same contract address has been reverted. <code>_errorString</code> <code>string[]</code> Array of revert error messages. <code>_erroringContract</code> <code>address[]</code> Array of addresses of the reverting contracts. <code>_totalRevertedErrors</code> <code>uint256</code> Total number of revert errors across all contracts."},{"location":"apis/smart-contracts/FtsoManager/#fn_showrevertederrors_6ea0aa31","title":"<code>showRevertedErrors</code>","text":"<p>Defined in <code>RevertErrorTracking</code> (Docs, Source).</p> <pre><code>function showRevertedErrors(\n    uint256 startIndex,\n    uint256 numErrorTypesToShow\n) public view returns (\n    uint256[] _lastErrorBlock,\n    uint256[] _numErrors,\n    string[] _errorString,\n    address[] _erroringContract,\n    uint256 _totalRevertedErrors);\n</code></pre> <p>Returns latest errors.</p> Parameters Type Description <code>startIndex</code> <code>uint256</code> Starting index in the error list array. <code>numErrorTypesToShow</code> <code>uint256</code> Number of errors to show. The total amount can be found in <code>errorData</code>. Returns Type Description <code>_lastErrorBlock</code> <code>uint256[]</code> Array of block numbers where the errors occurred. <code>_numErrors</code> <code>uint256[]</code> Array of number of times same error with same contract address has been reverted. <code>_errorString</code> <code>string[]</code> Array of revert error messages. <code>_erroringContract</code> <code>address[]</code> Array of addresses of the reverting contracts. <code>_totalRevertedErrors</code> <code>uint256</code> Total number of revert errors across all contracts."},{"location":"apis/smart-contracts/FtsoManager/#fn_switchtofallbackmode_e22fdece","title":"<code>switchToFallbackMode</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function switchToFallbackMode(\n) external returns (\n    bool);\n</code></pre> <p>This function will be called after an error is caught in <code>daemonize</code>. It will switch the contract to a simpler fallback mode, which hopefully works when full mode doesn't. Not every contract needs to support fallback mode (<code>FtsoManager</code> does), so this method may be empty. Switching back to normal mode is left to the contract (typically a governed method call). This function may be called due to low-gas error, so it shouldn't use more than ~30.000 gas.</p> <p>Only <code>flareDaemon</code> can call this method.</p> Returns Type Description [0] <code>bool</code> True if switched to fallback mode, false if already in fallback mode or if fallback mode is not supported."},{"location":"apis/smart-contracts/FtsoManager/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/FtsoManager/#fn_updatecontractaddresses_b00c0b76","title":"<code>updateContractAddresses</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function updateContractAddresses(\n    bytes32[] _contractNameHashes,\n    address[] _contractAddresses\n) external;\n</code></pre> <p>External method called from <code>AddressUpdater</code> only.</p>"},{"location":"apis/smart-contracts/FtsoManager/#fn_voterwhitelister_c2b0d47b","title":"<code>voterWhitelister</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>function voterWhitelister(\n) external view returns (\n    contract IIVoterWhitelister);\n</code></pre> <p>Returns the <code>VoterWhitelister</code> contract address.</p>"},{"location":"apis/smart-contracts/FtsoManager/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/FtsoManager/#va_max_trusted_addresses_length","title":"<code>MAX_TRUSTED_ADDRESSES_LENGTH</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    uint256 MAX_TRUSTED_ADDRESSES_LENGTH\n</code></pre> <p>Maximum number of trusted addresses allowed.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_active","title":"<code>active</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    bool active\n</code></pre> <p>Whether the FTSO Manager is <code>active</code> or not.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_cleanupblocknumbermanager","title":"<code>cleanupBlockNumberManager</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    contract CleanupBlockNumberManager cleanupBlockNumberManager\n</code></pre> <p>Address of the <code>CleanupBlockNumberManager</code> contract.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_currentrewardepochends","title":"<code>currentRewardEpochEnds</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    uint256 currentRewardEpochEnds\n</code></pre> <p>Timestamp when the current reward epoch finishes, in seconds since UNIX epoch.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_errordata","title":"<code>errorData</code>","text":"<p>Defined in <code>RevertErrorTracking</code> (Docs, Source).</p> <pre><code>    struct RevertErrorTracking.LastErrorData errorData\n</code></pre> <p>Most recent error information.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_flaredaemon","title":"<code>flareDaemon</code>","text":"<p>Defined in <code>GovernedAndFlareDaemonized</code> (Docs, Source).</p> <pre><code>    contract FlareDaemon flareDaemon\n</code></pre> <p>The <code>FlareDaemon</code> contract, set at construction time.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_governancesettings","title":"<code>governanceSettings</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    contract IGovernanceSettings governanceSettings\n</code></pre> <p>Governance Settings.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_lastrewardedftsoaddress","title":"<code>lastRewardedFtsoAddress</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    address lastRewardedFtsoAddress\n</code></pre> <p>Address of the FTSO contract that was last chosen for reward calculations.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_maxwaitforgoodrandomseconds","title":"<code>maxWaitForGoodRandomSeconds</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    uint256 maxWaitForGoodRandomSeconds\n</code></pre> <p>Used only when <code>useGoodRandom</code> flag is set.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_oldftsomanager","title":"<code>oldFtsoManager</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    contract IIFtsoManagerV1 oldFtsoManager\n</code></pre> <p>Previous FTSO Manager, in case of a redeployment.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_pricesubmitter","title":"<code>priceSubmitter</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    contract IIPriceSubmitter priceSubmitter\n</code></pre> <p>Address of the <code>PriceSubmitter</code> contract.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_productionmode","title":"<code>productionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    bool productionMode\n</code></pre> <p>When true, <code>governance</code> is enabled and cannot be disabled. See <code>switchToProductionMode</code>.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_rewardepochdurationseconds","title":"<code>rewardEpochDurationSeconds</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    uint256 rewardEpochDurationSeconds\n</code></pre> <p>Duration of reward epochs, in seconds.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_rewardepochsstartts","title":"<code>rewardEpochsStartTs</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    uint256 rewardEpochsStartTs\n</code></pre> <p>Timestamp when the first reward epoch started, in seconds since UNIX epoch.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_rewardmanager","title":"<code>rewardManager</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    contract IIFtsoRewardManager rewardManager\n</code></pre> <p>Address of the <code>RewardManager</code> contract.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_supply","title":"<code>supply</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    contract IISupply supply\n</code></pre>"},{"location":"apis/smart-contracts/FtsoManager/#va_timelockedcalls","title":"<code>timelockedCalls</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    mapping(bytes4 =&gt; struct GovernedBase.TimelockedCall) timelockedCalls\n</code></pre> <p>List of pending timelocked <code>governance</code> calls.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_updateonrewardepochswitchover","title":"<code>updateOnRewardEpochSwitchover</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    contract IUpdateValidators updateOnRewardEpochSwitchover\n</code></pre> <p>Unused.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_usegoodrandom","title":"<code>useGoodRandom</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    bool useGoodRandom\n</code></pre> <p>Whether use of good random numbers is enforced. See <code>IFtsoManager</code>.<code>UseGoodRandomSet</code>.</p>"},{"location":"apis/smart-contracts/FtsoManager/#va_waitingforgoodrandomsincets","title":"<code>waitingForGoodRandomSinceTs</code>","text":"<p>Defined in <code>FtsoManager</code> (Docs, Source).</p> <pre><code>    uint256 waitingForGoodRandomSinceTs\n</code></pre> <p>Used only when <code>useGoodRandom</code> flag is set.</p>"},{"location":"apis/smart-contracts/FtsoRegistry/","title":"FtsoRegistry","text":""},{"location":"apis/smart-contracts/FtsoRegistry/#ct_ftsoregistry","title":"<code>FtsoRegistry</code>","text":"<p>Source | Inherits from IIFtsoRegistry, AddressUpdatable, GovernedBase</p> <p>Handles registration of assets to the FTSO system.</p>"},{"location":"apis/smart-contracts/FtsoRegistry/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/FtsoRegistry/#fn_addftso_2663f1b4","title":"<code>addFtso</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function addFtso(\n    contract IIFtso _ftsoContract\n) external returns (\n    uint256 _assetIndex);\n</code></pre> <p>Add a new FTSO contract to the registry.</p> <p>Only the <code>ftsoManager</code> can call this method.</p> Parameters Type Description <code>_ftsoContract</code> <code>contract IIFtso</code> New target FTSO contract. Returns Type Description <code>_assetIndex</code> <code>uint256</code> The FTSO index assigned to the new asset."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>constructor(\n) public;\n</code></pre>"},{"location":"apis/smart-contracts/FtsoRegistry/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getaddressupdater_5267a15d","title":"<code>getAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function getAddressUpdater(\n) public view returns (\n    address _addressUpdater);\n</code></pre> <p>Returns the configured address updater.</p> Returns Type Description <code>_addressUpdater</code> <code>address</code> The <code>AddresUpdater</code> contract that can update our contract address list, as a response to a governance call."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getallcurrentprices_58f9296f","title":"<code>getAllCurrentPrices</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getAllCurrentPrices(\n) external view returns (\n    struct IFtsoRegistry.PriceInfo[]);\n</code></pre> <p>Returns the current price of all supported assets.</p> Returns Type Description [0] <code>struct IFtsoRegistry.PriceInfo[]</code> Array of <code>PriceInfo</code> structures."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getallftsos_2bcdd6ab","title":"<code>getAllFtsos</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getAllFtsos(\n) external view returns (\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Return all currently supported FTSO contracts.</p> Returns Type Description <code>_ftsos</code> <code>contract IIFtso[]</code> Array of FTSO contract addresses."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getcurrentprice_c55d0f56","title":"<code>getCurrentPrice</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPrice(\n    uint256 _assetIndex\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp);\n</code></pre> <p>Public view function to get the current price of a given active FTSO index. Reverts if the index is not supported.</p> Parameters Type Description <code>_assetIndex</code> <code>uint256</code> Returns Type Description <code>_price</code> <code>uint256</code> Current price of the asset in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Timestamp for when this price was updated, in seconds since UNIX epoch."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getcurrentprice_42a0f243","title":"<code>getCurrentPrice</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPrice(\n    string _symbol\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp);\n</code></pre> <p>Public view function to get the current price of a given active asset symbol. Reverts if the symbol is not supported.</p> Parameters Type Description <code>_symbol</code> <code>string</code> Symbol to query. Returns Type Description <code>_price</code> <code>uint256</code> Current price of the asset in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Timestamp for when this price was updated, in seconds since UNIX epoch."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getcurrentpricewithdecimals_257cbd3a","title":"<code>getCurrentPriceWithDecimals</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPriceWithDecimals(\n    uint256 _assetIndex\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals);\n</code></pre> <p>Public view function to get the current price and decimals of a given active FTSO index. Reverts if the index is not supported.</p> Parameters Type Description <code>_assetIndex</code> <code>uint256</code> Index to query. Returns Type Description <code>_price</code> <code>uint256</code> Current price of the asset in USD multiplied by 10^<code>_assetPriceUsdDecimals</code>. <code>_timestamp</code> <code>uint256</code> Timestamp for when this price was updated, in seconds since UNIX epoch. <code>_assetPriceUsdDecimals</code> <code>uint256</code> Number of decimals used to return the <code>_price</code>."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getcurrentpricewithdecimals_a69afdc6","title":"<code>getCurrentPriceWithDecimals</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPriceWithDecimals(\n    string _symbol\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals);\n</code></pre> <p>Public view function to get the current price and decimals of a given active asset symbol. Reverts if the symbol is not supported.</p> Parameters Type Description <code>_symbol</code> <code>string</code> Symbol to query. Returns Type Description <code>_price</code> <code>uint256</code> Current price of the asset in USD multiplied by 10^<code>_assetPriceUsdDecimals</code>. <code>_timestamp</code> <code>uint256</code> Timestamp for when this price was updated, in seconds since UNIX epoch. <code>_assetPriceUsdDecimals</code> <code>uint256</code> Number of decimals used to return the <code>_price</code>."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getcurrentpricesbyindices_6ba31fa1","title":"<code>getCurrentPricesByIndices</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPricesByIndices(\n    uint256[] _indices\n) external view returns (\n    struct IFtsoRegistry.PriceInfo[]);\n</code></pre> <p>Returns the current price of a list of indices. Reverts if any of the indices is not supported.</p> Parameters Type Description <code>_indices</code> <code>uint256[]</code> Array of indices to query. Returns Type Description [0] <code>struct IFtsoRegistry.PriceInfo[]</code> Array of <code>PriceInfo</code> structures."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getcurrentpricesbysymbols_79d5ea4b","title":"<code>getCurrentPricesBySymbols</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPricesBySymbols(\n    string[] _symbols\n) external view returns (\n    struct IFtsoRegistry.PriceInfo[]);\n</code></pre> <p>Returns the current price of a list of asset symbols. Reverts if any of the symbols is not supported.</p> Parameters Type Description <code>_symbols</code> <code>string[]</code> Array of symbols to query. Returns Type Description [0] <code>struct IFtsoRegistry.PriceInfo[]</code> Array of <code>PriceInfo</code> structures."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getftso_d75f6d81","title":"<code>getFtso</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getFtso(\n    uint256 _assetIndex\n) external view returns (\n    contract IIFtso _activeFtso);\n</code></pre> <p>Returns the address of the FTSO contract for a given index. Reverts if unsupported index is passed.</p> Parameters Type Description <code>_assetIndex</code> <code>uint256</code> Returns Type Description <code>_activeFtso</code> <code>contract IIFtso</code>"},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getftsobysymbol_97da6af4","title":"<code>getFtsoBySymbol</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getFtsoBySymbol(\n    string _symbol\n) external view returns (\n    contract IIFtso _activeFtso);\n</code></pre> <p>Returns the address of the FTSO contract for a given symbol. Reverts if unsupported symbol is passed.</p> Parameters Type Description <code>_symbol</code> <code>string</code> The queried symbol. Returns Type Description <code>_activeFtso</code> <code>contract IIFtso</code>"},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getftsohistory_c71a1b20","title":"<code>getFtsoHistory</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getFtsoHistory(\n    uint256 _assetIndex\n) external view returns (\n    contract IIFtso[5] _ftsoAddressHistory);\n</code></pre> <p>Get the history of FTSOs for given index. If there are less then MAX_HISTORY_LENGTH the remaining addresses will be 0 addresses. Reverts if index is not supported.</p> Parameters Type Description <code>_assetIndex</code> <code>uint256</code> Asset index to query. Returns Type Description <code>_ftsoAddressHistory</code> <code>contract IIFtso[5]</code> History of FTSOs contract for provided index."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getftsoindex_e848da30","title":"<code>getFtsoIndex</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getFtsoIndex(\n    string _symbol\n) external view returns (\n    uint256 _assetIndex);\n</code></pre> <p>Returns the FTSO index corresponding to a given asset symbol. Reverts if the symbol is not supported.</p> Parameters Type Description <code>_symbol</code> <code>string</code> Symbol to query. Returns Type Description <code>_assetIndex</code> <code>uint256</code> The corresponding asset index."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getftsosymbol_136d3f64","title":"<code>getFtsoSymbol</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getFtsoSymbol(\n    uint256 _assetIndex\n) external view returns (\n    string _symbol);\n</code></pre> <p>Returns the asset symbol corresponding to a given FTSO index. Reverts if the index is not supported.</p> Parameters Type Description <code>_assetIndex</code> <code>uint256</code> Returns Type Description <code>_symbol</code> <code>string</code> The corresponding asset symbol."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getftsos_9cb47538","title":"<code>getFtsos</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getFtsos(\n    uint256[] _assetIndices\n) external view returns (\n    contract IFtsoGenesis[] _ftsos);\n</code></pre> <p>Get the addresses of the active FTSOs at the given indices. Reverts if any of the provided indices is non-existing or inactive.</p> Parameters Type Description <code>_assetIndices</code> <code>uint256[]</code> Returns Type Description <code>_ftsos</code> <code>contract IFtsoGenesis[]</code> The array of FTSO addresses."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getsupportedftsos_a40060ba","title":"<code>getSupportedFtsos</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedFtsos(\n) external view returns (\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Get array of all FTSO contracts for all supported asset indices. The index of FTSO in returned array does not necessarily correspond to the asset's index. Due to deletion, some indices might be unsupported.</p> <p>Use <code>getSupportedIndicesAndFtsos</code> to retrieve pairs of correct indices and FTSOs, where possible \"null\" holes are readily apparent.</p> Returns Type Description <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all supported FTSOs."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getsupportedindices_798aac5b","title":"<code>getSupportedIndices</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedIndices(\n) external view returns (\n    uint256[] _supportedIndices);\n</code></pre> <p>Returns the indices of the currently supported FTSOs. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of all active FTSO indices in increasing order."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getsupportedindicesandftsos_06a2ba29","title":"<code>getSupportedIndicesAndFtsos</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedIndicesAndFtsos(\n) external view returns (\n    uint256[] _supportedIndices,\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Get all supported indices and corresponding FTSO addresses. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of all supported indices. <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all supported FTSO addresses."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getsupportedindicesandsymbols_e68f283b","title":"<code>getSupportedIndicesAndSymbols</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedIndicesAndSymbols(\n) external view returns (\n    uint256[] _supportedIndices,\n    string[] _supportedSymbols);\n</code></pre> <p>Get all supported indices and corresponding symbols. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of all supported indices. <code>_supportedSymbols</code> <code>string[]</code> Array of all supported symbols."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getsupportedindicessymbolsandftsos_7687542c","title":"<code>getSupportedIndicesSymbolsAndFtsos</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedIndicesSymbolsAndFtsos(\n) external view returns (\n    uint256[] _supportedIndices,\n    string[] _supportedSymbols,\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Get all supported indices, symbols, and corresponding FTSO addresses. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of all supported indices. <code>_supportedSymbols</code> <code>string[]</code> Array of all supported symbols. <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all supported FTSO addresses."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getsupportedsymbols_ce1c0e4d","title":"<code>getSupportedSymbols</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedSymbols(\n) external view returns (\n    string[] _supportedSymbols);\n</code></pre> <p>Returns the symbols of the currently supported FTSOs. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedSymbols</code> <code>string[]</code> Array of all active FTSO symbols in increasing order."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_getsupportedsymbolsandftsos_0cf48497","title":"<code>getSupportedSymbolsAndFtsos</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedSymbolsAndFtsos(\n) external view returns (\n    string[] _supportedSymbols,\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Get all supported symbols and corresponding FTSO addresses. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedSymbols</code> <code>string[]</code> Array of all supported symbols. <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all supported FTSO addresses."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/FtsoRegistry/#fn_initialiseregistry_ffc880fd","title":"<code>initialiseRegistry</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function initialiseRegistry(\n    address _addressUpdater\n) external;\n</code></pre>"},{"location":"apis/smart-contracts/FtsoRegistry/#fn_removeftso_a670ff87","title":"<code>removeFtso</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>function removeFtso(\n    contract IIFtso _ftso\n) external;\n</code></pre> <p>Removes the FTSO and keeps part of the history. Reverts if the provided address is not supported.</p> <p>From now on, the index this asset was using is \"reserved\" and cannot be used again. It will not be returned in any list of currently supported assets.</p> <p>Only the <code>ftsoManager</code> can call this method.</p> Parameters Type Description <code>_ftso</code> <code>contract IIFtso</code> Address of the FTSO contract to remove."},{"location":"apis/smart-contracts/FtsoRegistry/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/FtsoRegistry/#fn_updatecontractaddresses_b00c0b76","title":"<code>updateContractAddresses</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function updateContractAddresses(\n    bytes32[] _contractNameHashes,\n    address[] _contractAddresses\n) external;\n</code></pre> <p>External method called from <code>AddressUpdater</code> only.</p>"},{"location":"apis/smart-contracts/FtsoRegistry/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/FtsoRegistry/#md_onlyaddressupdater","title":"<code>onlyAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>modifier onlyAddressUpdater()\n</code></pre> <p>Only the <code>AdressUpdater</code> contract can call this method. Its address is set at construction time but it can also update itself.</p>"},{"location":"apis/smart-contracts/FtsoRegistry/#md_onlyftsomanager","title":"<code>onlyFtsoManager</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>modifier onlyFtsoManager()\n</code></pre> <p>Only the <code>ftsoManager</code> can call this method.</p>"},{"location":"apis/smart-contracts/FtsoRegistry/#md_onlygovernance","title":"<code>onlyGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/FtsoRegistry/#md_onlyimmediategovernance","title":"<code>onlyImmediateGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyImmediateGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/FtsoRegistry/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/FtsoRegistry/#va_ftsomanager","title":"<code>ftsoManager</code>","text":"<p>Defined in <code>FtsoRegistry</code> (Docs, Source).</p> <pre><code>    contract IIFtsoManager ftsoManager\n</code></pre> <p><code>FtsoManager</code> contract that can add and remove assets to the registry.</p>"},{"location":"apis/smart-contracts/FtsoRegistry/#va_governancesettings","title":"<code>governanceSettings</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    contract IGovernanceSettings governanceSettings\n</code></pre> <p>Governance Settings.</p>"},{"location":"apis/smart-contracts/FtsoRegistry/#va_productionmode","title":"<code>productionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    bool productionMode\n</code></pre> <p>When true, <code>governance</code> is enabled and cannot be disabled. See <code>switchToProductionMode</code>.</p>"},{"location":"apis/smart-contracts/FtsoRegistry/#va_timelockedcalls","title":"<code>timelockedCalls</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    mapping(bytes4 =&gt; struct GovernedBase.TimelockedCall) timelockedCalls\n</code></pre> <p>List of pending timelocked <code>governance</code> calls.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/","title":"FtsoRewardManager","text":""},{"location":"apis/smart-contracts/FtsoRewardManager/#ct_ftsorewardmanager","title":"<code>FtsoRewardManager</code>","text":"<p>Source | Inherits from IIFtsoRewardManager, Governed, ReentrancyGuard, AddressUpdatable</p> <p>Handles reward distribution and claiming related to the FTSO system.</p> <p>More specifically, this contract:</p> <ul> <li>Distributes rewards according to instructions from the <code>FtsoManager</code>.</li> <li>Allows data providers, delegators and executors to <code>claim</code> rewards.</li> </ul>"},{"location":"apis/smart-contracts/FtsoRewardManager/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_accrueunearnedrewards_67dcac53","title":"<code>accrueUnearnedRewards</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function accrueUnearnedRewards(\n    uint256 _epochId,\n    uint256 _priceEpochDurationSeconds,\n    uint256 _priceEpochEndTime\n) external;\n</code></pre> <p>Accrue unearned rewards for a given price epoch. Typically done when the FTSO is in fallback mode or because of insufficient vote power. Simply accrue them so they will not be distributed and will be burned later.</p> <p>The amount of rewards that will be burned is calculated in the same way as in <code>distributeRewards</code>.</p> <p>Only the FTSO Manager can call this method.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> <code>_priceEpochDurationSeconds</code> <code>uint256</code> <code>_priceEpochEndTime</code> <code>uint256</code>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_activate_0f15f4c0","title":"<code>activate</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function activate(\n) external;\n</code></pre> <p>Activates reward manager (allows claiming rewards).</p> <p>Only <code>governance</code> can call this method.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_active_02fb0c5e","title":"<code>active</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function active(\n) external view returns (\n    bool);\n</code></pre> <p>Whether rewards can be claimed from this reward manager.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_autoclaim_8dc305fa","title":"<code>autoClaim</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function autoClaim(\n    address[] _rewardOwners,\n    uint256 _rewardEpoch\n) external;\n</code></pre> <p>Allows claiming rewards simultaneously for a list of reward owners and all unclaimed epochs before the specified one.</p> <p>This is meant as a convenience all-in-one reward claiming method to be used both by reward owners and registered executors. It performs a series of operations, besides claiming rewards:</p> <ul> <li> <p>If a reward owner has enabled its Personal Delegation Account, rewards are also claimed for the PDA and the total claimed amount is sent to that PDA. Otherwise, the claimed amount is sent to the reward owner's account.</p> </li> <li> <p>Claimed amount is automatically wrapped through the <code>WNat</code> contract.</p> </li> <li> <p>If the caller is a registered executor with a non-zero fee, the fee is paid to the executor for each claimed address.</p> </li> </ul> Parameters Type Description <code>_rewardOwners</code> <code>address[]</code> List of reward owners to claim for. <code>_rewardEpoch</code> <code>uint256</code> Last reward epoch ID to claim for. All previous epochs with pending rewards will be claimed too."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_claim_b2c12192","title":"<code>claim</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function claim(\n    address _rewardOwner,\n    address payable _recipient,\n    uint256 _rewardEpoch,\n    bool _wrap\n) external returns (\n    uint256 _rewardAmount);\n</code></pre> <p>Allows the caller to <code>claim</code> rewards for a reward owner. The caller does not have to be the owner of the rewards, but must be approved by the owner to <code>claim</code> on his behalf by using <code>setClaimExecutors</code> on the <code>claimSetupManager</code>.</p> <p>This function is intended to be used to <code>claim</code> rewards in case of delegation by percentage. Reverts if <code>msg.sender</code> is delegating by amount.</p> <p>Anybody can call this method, but rewards can only be sent to the reward owner, therefore no funds can be stolen. However, by limiting the authorized callers, the owner can control the timing of the calls.</p> <p>When the reward owner is the caller, rewards can be sent to any recipient set by <code>setAllowedClaimRecipients</code> on the <code>claimSetupManager</code>. The reward owner's Personal Delegation Account is always an authorized recipient.</p> Parameters Type Description <code>_rewardOwner</code> <code>address</code> Address of the reward owner. <code>_recipient</code> <code>address payable</code> Address to transfer claimed rewards to. <code>_rewardEpoch</code> <code>uint256</code> Last reward epoch to claim for. All previous epochs with pending rewards will be claimed too. <code>_wrap</code> <code>bool</code> Whether claimed rewards should be wrapped through the <code>WNat</code> contract before transferring them to the <code>_recipient</code>. This parameter is offered as a convenience. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Total amount of claimed rewards (wei)."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_claimfromdataproviders_21bb25af","title":"<code>claimFromDataProviders</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function claimFromDataProviders(\n    address _rewardOwner,\n    address payable _recipient,\n    uint256[] _rewardEpochs,\n    address[] _dataProviders,\n    bool _wrap\n) external returns (\n    uint256 _rewardAmount);\n</code></pre> <p>Allows the caller to <code>claim</code> rewards for a reward owner from specific data providers. The caller does not have to be the owner of the rewards, but must be approved by the owner to <code>claim</code> on his behalf by using <code>setClaimExecutors</code> on the <code>claimSetupManager</code>.</p> <p>This function is intended to be used to <code>claim</code> rewards in case of delegation by amount (explicit delegation). Reverts if <code>msg.sender</code> is delegating by percentage.</p> <p>Anybody can call this method, but rewards can only be sent to the reward owner, therefore no funds can be stolen. However, by limiting the authorized callers, the owner can control the timing of the calls.</p> <p>When the reward owner is the caller, rewards can be sent to any recipient set by <code>setAllowedClaimRecipients</code> on the <code>claimSetupManager</code>. The reward owner's Personal Delegation Account is always an authorized recipient.</p> Parameters Type Description <code>_rewardOwner</code> <code>address</code> Address of the reward owner. <code>_recipient</code> <code>address payable</code> Address to transfer claimed rewards to. <code>_rewardEpochs</code> <code>uint256[]</code> Array of reward epoch IDs to claim for. <code>_dataProviders</code> <code>address[]</code> Array of addresses of the data providers to claim the reward from. <code>_wrap</code> <code>bool</code> Whether claimed rewards should be wrapped through the <code>WNat</code> contract before transferring them to the <code>_recipient</code>. This parameter is offered as a convenience. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Total amount of claimed rewards (wei)."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_claimreward_b2af870a","title":"<code>claimReward</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function claimReward(\n    address payable _recipient,\n    uint256[] _rewardEpochs\n) external returns (\n    uint256 _rewardAmount);\n</code></pre> <p>Allows a percentage delegator to <code>claim</code> rewards. This function is intended to be used to <code>claim</code> rewards in case of delegation by percentage.</p> <p>This function is deprecated: use <code>claim</code> instead.</p> <p>Reverts if <code>msg.sender</code> is delegating by amount. Claims for all unclaimed reward epochs to the 'max(_rewardEpochs)'. Retained for backward compatibility.</p> Parameters Type Description <code>_recipient</code> <code>address payable</code> Address to transfer funds to. <code>_rewardEpochs</code> <code>uint256[]</code> Array of reward epoch numbers to claim for. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Amount of total claimed rewards (wei)."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_claimrewardfromdataproviders_d20bb542","title":"<code>claimRewardFromDataProviders</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function claimRewardFromDataProviders(\n    address payable _recipient,\n    uint256[] _rewardEpochs,\n    address[] _dataProviders\n) external returns (\n    uint256 _rewardAmount);\n</code></pre> <p>Allows the caller to <code>claim</code> rewards from specific data providers. This function is intended to be used to <code>claim</code> rewards in case of delegation by amount.</p> <p>This function is deprecated: use <code>claimFromDataProviders</code> instead.</p> Parameters Type Description <code>_recipient</code> <code>address payable</code> Address to transfer funds to. <code>_rewardEpochs</code> <code>uint256[]</code> Array of reward epoch numbers to claim for. <code>_dataProviders</code> <code>address[]</code> Array of addresses of the data providers to claim the reward from. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Total amount of claimed rewards (wei)."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_closeexpiredrewardepoch_d6c1dbee","title":"<code>closeExpiredRewardEpoch</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function closeExpiredRewardEpoch(\n    uint256 _rewardEpoch\n) external;\n</code></pre> <p>Collects funds from expired reward epoch and calculates totals.</p> <p>Triggered by <code>ftsoManager</code> on finalization of a reward epoch. Operation is irreversible: when some reward epoch is closed according to current settings, it cannot be reopened even if new parameters would allow it, because <code>nextRewardEpochToExpire</code> in <code>ftsoManager</code> never decreases.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance,\n    address _addressUpdater,\n    address _oldFtsoRewardManager,\n    uint256 _feePercentageUpdateOffset,\n    uint256 _defaultFeePercentage\n) public;\n</code></pre>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>Governed</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance\n) public;\n</code></pre> Parameters Type Description <code>_governance</code> <code>address</code> Governance contract. Must not be zero."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_deactivate_51b42b00","title":"<code>deactivate</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function deactivate(\n) external;\n</code></pre> <p>Deactivates reward manager (prevents claiming rewards).</p> <p>Only <code>governance</code> can call this method.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_defaultfeepercentage_b4824034","title":"<code>defaultFeePercentage</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function defaultFeePercentage(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the configured default fee percentage.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_distributerewards_a9b79e17","title":"<code>distributeRewards</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function distributeRewards(\n    address[] _addresses,\n    uint256[] _weights,\n    uint256 _totalWeight,\n    uint256 _epochId,\n    address _ftso,\n    uint256 _priceEpochDurationSeconds,\n    uint256 _currentRewardEpoch,\n    uint256 _priceEpochEndTime,\n    uint256 _votePowerBlock\n) external;\n</code></pre> <p>Distributes price epoch rewards to data provider accounts, according to input parameters. Must be called with <code>totalWeight</code> &gt; 0 and <code>addresses.length</code> &gt; 0.</p> <p>The amount of rewards for a given price epoch ID are calculated in <code>FtsoRewardManager</code> from <code>priceEpochDurationSeconds</code>, <code>priceEpochEndTime</code> and inflation authorization data (see <code>_getTotalPriceEpochRewardWei</code> in <code>FtsoRewardManager</code>. Then each data provider address is given a portion of this amount according to corresponding weight and total sum of weights.</p> <p>Parameters <code>epochId</code> and <code>ftso</code> are only needed so they can be passed onto the emitted event.</p> <p>Only the <code>ftsoManager</code> can call this method.</p> Parameters Type Description <code>_addresses</code> <code>address[]</code> <code>_weights</code> <code>uint256[]</code> <code>_totalWeight</code> <code>uint256</code> <code>_epochId</code> <code>uint256</code> <code>_ftso</code> <code>address</code> <code>_priceEpochDurationSeconds</code> <code>uint256</code> <code>_currentRewardEpoch</code> <code>uint256</code> <code>_priceEpochEndTime</code> <code>uint256</code> <code>_votePowerBlock</code> <code>uint256</code>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_enableclaims_ea28edad","title":"<code>enableClaims</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function enableClaims(\n) external;\n</code></pre> <p>Enable claiming for current and all future reward epochs.</p> <p>Only <code>governance</code> can call this method.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_feepercentageupdateoffset_16fe49c7","title":"<code>feePercentageUpdateOffset</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function feePercentageUpdateOffset(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the amount of reward epoch that need to ellapse before a fee change takes effect.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_firstclaimablerewardepoch_7b6b2c0a","title":"<code>firstClaimableRewardEpoch</code>","text":"<p>Defined in <code>IIFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function firstClaimableRewardEpoch(\n) external view returns (\n    uint256);\n</code></pre> <p>Epochs before the token distribution event at Flare launch were not be claimable. Use this method to know the first reward epoch that was claimable.</p> Returns Type Description [0] <code>uint256</code> uint256 The first reward epoch that can be claimed."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getaddressupdater_5267a15d","title":"<code>getAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function getAddressUpdater(\n) public view returns (\n    address _addressUpdater);\n</code></pre> <p>Returns the configured address updater.</p> Returns Type Description <code>_addressUpdater</code> <code>address</code> The <code>AddresUpdater</code> contract that can update our contract address list, as a response to a governance call."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getclaimedreward_85b4c538","title":"<code>getClaimedReward</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getClaimedReward(\n    uint256 _rewardEpoch,\n    address _dataProvider,\n    address _claimer\n) external view returns (\n    bool _claimed,\n    uint256 _amount);\n</code></pre> <p>Returns information on the rewards accrued by a reward owner from a specific data provider at a specific reward epoch.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID to query. <code>_dataProvider</code> <code>address</code> Address of the data provider to query. <code>_claimer</code> <code>address</code> Address of the reward owner to query. Returns Type Description <code>_claimed</code> <code>bool</code> Whether the reward has been claimed or not. <code>_amount</code> <code>uint256</code> Accrued amount in wei."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getcontractname_f5f5ba72","title":"<code>getContractName</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getContractName(\n) external pure returns (\n    string);\n</code></pre> <p>Implement this function to allow updating inflation receiver contracts through <code>AddressUpdater</code>.</p> Returns Type Description [0] <code>string</code> Contract name."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getcurrentrewardepoch_e7c830d4","title":"<code>getCurrentRewardEpoch</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getCurrentRewardEpoch(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the current reward epoch ID.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getdataprovidercurrentfeepercentage_cfbcd25f","title":"<code>getDataProviderCurrentFeePercentage</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getDataProviderCurrentFeePercentage(\n    address _dataProvider\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the current fee percentage of a data provider.</p> Parameters Type Description <code>_dataProvider</code> <code>address</code> Address of the queried data provider. Returns Type Description [0] <code>uint256</code>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getdataproviderfeepercentage_961c00ed","title":"<code>getDataProviderFeePercentage</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getDataProviderFeePercentage(\n    address _dataProvider,\n    uint256 _rewardEpoch\n) external view returns (\n    uint256 _feePercentageBIPS);\n</code></pre> <p>Returns the fee percentage of a data provider at a given reward epoch.</p> Parameters Type Description <code>_dataProvider</code> <code>address</code> Address of the queried data provider. <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID. Returns Type Description <code>_feePercentageBIPS</code> <code>uint256</code> Fee percentage in BIPS."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getdataproviderperformanceinfo_eb82dd7f","title":"<code>getDataProviderPerformanceInfo</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getDataProviderPerformanceInfo(\n    uint256 _rewardEpoch,\n    address _dataProvider\n) external view returns (\n    uint256 _rewardAmount,\n    uint256 _votePowerIgnoringRevocation);\n</code></pre> <p>Returns information on rewards and vote power of a data provider at a given reward epoch.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID. <code>_dataProvider</code> <code>address</code> Address of the data provider to query. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Amount of rewards (wei). <code>_votePowerIgnoringRevocation</code> <code>uint256</code> Vote power, not including revocations."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getdataproviderscheduledfeepercentagechanges_33b7971e","title":"<code>getDataProviderScheduledFeePercentageChanges</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getDataProviderScheduledFeePercentageChanges(\n    address _dataProvider\n) external view returns (\n    uint256[] _feePercentageBIPS,\n    uint256[] _validFromEpoch,\n    bool[] _fixed);\n</code></pre> <p>Returns the scheduled fee percentage changes for a data provider.</p> Parameters Type Description <code>_dataProvider</code> <code>address</code> Address of the queried data provider. Returns Type Description <code>_feePercentageBIPS</code> <code>uint256[]</code> Array of fee percentages in BIPS. <code>_validFromEpoch</code> <code>uint256[]</code> Array of block numbers from which the fee settings are effective. <code>_fixed</code> <code>bool[]</code> Array of boolean values indicating whether settings are subject to change or not."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getepochreward_d418634a","title":"<code>getEpochReward</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getEpochReward(\n    uint256 _rewardEpoch\n) external view returns (\n    uint256 _totalReward,\n    uint256 _claimedReward);\n</code></pre> <p>Returns information on an epoch's rewards.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID. Returns Type Description <code>_totalReward</code> <code>uint256</code> Total amount of rewards accrued on that epoch, in wei. <code>_claimedReward</code> <code>uint256</code> Total amount of rewards that have already been claimed, in wei."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getepochswithclaimablerewards_0441218e","title":"<code>getEpochsWithClaimableRewards</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getEpochsWithClaimableRewards(\n) external view returns (\n    uint256 _startEpochId,\n    uint256 _endEpochId);\n</code></pre> <p>Returns the reward epoch range for which rewards can be claimed. Rewards outside this range are unclaimable, either because they have expired or because the reward epoch is still ongoing.</p> Returns Type Description <code>_startEpochId</code> <code>uint256</code> The oldest epoch ID that allows reward claiming. <code>_endEpochId</code> <code>uint256</code> The newest epoch ID that allows reward claiming."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getepochswithunclaimedrewards_b4a2043d","title":"<code>getEpochsWithUnclaimedRewards</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getEpochsWithUnclaimedRewards(\n    address _beneficiary\n) external view returns (\n    uint256[] _epochIds);\n</code></pre> <p>Returns the array of claimable epoch IDs for which the rewards of a reward owner have not yet been claimed.</p> Parameters Type Description <code>_beneficiary</code> <code>address</code> Address of the reward owner to query. Reverts if it uses delegation by amount. Returns Type Description <code>_epochIds</code> <code>uint256[]</code> Array of epoch IDs."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getexpectedbalance_af04cd3b","title":"<code>getExpectedBalance</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getExpectedBalance(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the contract's expected balance (actual balance may be higher due to self-destruct funds).</p> Returns Type Description [0] <code>uint256</code> Expected native token balance."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getinflationaddress_ed39d3f8","title":"<code>getInflationAddress</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getInflationAddress(\n) external view returns (\n    address);\n</code></pre> <p>Returns the address of the <code>Inflation</code> contract.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getinitialrewardepoch_3123b7d8","title":"<code>getInitialRewardEpoch</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getInitialRewardEpoch(\n) external view returns (\n    uint256 _initialRewardEpoch);\n</code></pre> <p>Returns the initial reward epoch ID for this reward manager contract. This corresponds to the oldest reward epoch with claimable rewards in the previous reward manager when this one took over. Set by <code>governance</code> through <code>setInitialRewardData</code>.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getrewardepochtoexpirenext_3e7ff857","title":"<code>getRewardEpochToExpireNext</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochToExpireNext(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the reward epoch that will expire next once a new reward epoch starts.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getrewardepochvotepowerblock_f2edab5a","title":"<code>getRewardEpochVotePowerBlock</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochVotePowerBlock(\n    uint256 _rewardEpoch\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the vote power block of a given reward epoch.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getstateofrewards_a4472c10","title":"<code>getStateOfRewards</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getStateOfRewards(\n    address _beneficiary,\n    uint256 _rewardEpoch\n) external view returns (\n    address[] _dataProviders,\n    uint256[] _rewardAmounts,\n    bool[] _claimed,\n    bool _claimable);\n</code></pre> <p>Returns the state of rewards for a given address at a specific reward epoch.</p> Parameters Type Description <code>_beneficiary</code> <code>address</code> Address of the beneficiary to query. It can be a data provider or a delegator, for example.Reverts if the queried address is delegating by amount. <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID to query. Returns Type Description <code>_dataProviders</code> <code>address[]</code> Array of addresses of data providers. <code>_rewardAmounts</code> <code>uint256[]</code> Array of reward amounts received from each provider, in wei. <code>_claimed</code> <code>bool[]</code> Array of boolean values indicating whether each reward has been claimed or not. <code>_claimable</code> <code>bool</code> Boolean value indicating whether rewards are claimable or not."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getstateofrewardsfromdataproviders_e416b7e1","title":"<code>getStateOfRewardsFromDataProviders</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getStateOfRewardsFromDataProviders(\n    address _beneficiary,\n    uint256 _rewardEpoch,\n    address[] _dataProviders\n) external view returns (\n    uint256[] _rewardAmounts,\n    bool[] _claimed,\n    bool _claimable);\n</code></pre> <p>Returns the state of rewards for a given address coming from a specific set of data providers, at a specific reward epoch.</p> Parameters Type Description <code>_beneficiary</code> <code>address</code> Address of beneficiary to query. <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID to query. <code>_dataProviders</code> <code>address[]</code> Array of addresses of the data providers to query. Returns Type Description <code>_rewardAmounts</code> <code>uint256[]</code> Array of reward amounts received from each provider, in wei. <code>_claimed</code> <code>bool[]</code> Array of boolean values indicating whether each reward has been claimed or not. <code>_claimable</code> <code>bool</code> Boolean value indicating whether rewards are claimable or not."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_gettokenpoolsupplydata_2dafdbbf","title":"<code>getTokenPoolSupplyData</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getTokenPoolSupplyData(\n) external view returns (\n    uint256 _lockedFundsWei,\n    uint256 _totalInflationAuthorizedWei,\n    uint256 _totalClaimedWei);\n</code></pre> <p>Returns token pool supply data.</p> Returns Type Description <code>_lockedFundsWei</code> <code>uint256</code> Total amount of funds ever locked in the token pool (wei). <code>_lockedFundsWei</code> - <code>_totalClaimedWei</code> is the amount currently locked and outside the circulating supply. <code>_totalInflationAuthorizedWei</code> <code>uint256</code> Total inflation authorized amount (wei). <code>_totalClaimedWei</code> <code>uint256</code> Total claimed amount (wei)."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_gettotals_84e10a90","title":"<code>getTotals</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getTotals(\n) external view returns (\n    uint256 _totalAwardedWei,\n    uint256 _totalClaimedWei,\n    uint256 _totalExpiredWei,\n    uint256 _totalUnearnedWei,\n    uint256 _totalBurnedWei,\n    uint256 _totalInflationAuthorizedWei,\n    uint256 _totalInflationReceivedWei,\n    uint256 _lastInflationAuthorizationReceivedTs,\n    uint256 _dailyAuthorizedInflation);\n</code></pre> <p>Returns statistics regarding rewards, accumulated over the whole lifespan of the reward manager contract.</p> Returns Type Description <code>_totalAwardedWei</code> <code>uint256</code> Rewards that were distributed (wei). <code>_totalClaimedWei</code> <code>uint256</code> Distributed rewards that were claimed in time (wei). <code>_totalExpiredWei</code> <code>uint256</code> Distributed rewards that were not claimed in time and expired (wei). <code>_totalUnearnedWei</code> <code>uint256</code> Rewards that were unearned (due to FTSO being in fallback mode) and thus were not distributed (wei). <code>_totalBurnedWei</code> <code>uint256</code> Rewards that were unearned or expired and thus burned (wei). <code>_totalInflationAuthorizedWei</code> <code>uint256</code> Total inflation authorized amount (wei). <code>_totalInflationReceivedWei</code> <code>uint256</code> Total inflation received amount (wei). <code>_lastInflationAuthorizationReceivedTs</code> <code>uint256</code> UNIX timestamp of the last inflation authorization. <code>_dailyAuthorizedInflation</code> <code>uint256</code> <code>Inflation</code> authorized amount (wei) at the time of last authorization."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_getunclaimedreward_657d9695","title":"<code>getUnclaimedReward</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getUnclaimedReward(\n    uint256 _rewardEpoch,\n    address _dataProvider\n) external view returns (\n    uint256 _amount,\n    uint256 _weight);\n</code></pre> <p>Returns information on unclaimed rewards for a given data provider and epoch.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> Queried reward epoch ID. <code>_dataProvider</code> <code>address</code> Address of the queried data provider. Returns Type Description <code>_amount</code> <code>uint256</code> Amount available to be claimed, in wei. <code>_weight</code> <code>uint256</code> Portion of total vote power used in this reward epoch that has not yet claimed its reward, in BIPS. It decreases to 0 when all data providers have claimed their rewards."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_nextclaimablerewardepoch_69b91b59","title":"<code>nextClaimableRewardEpoch</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function nextClaimableRewardEpoch(\n    address _rewardOwner\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the next claimable reward epoch for a reward owner.</p> Parameters Type Description <code>_rewardOwner</code> <code>address</code> Address of the reward owner to query."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_receiveinflation_06201f1d","title":"<code>receiveInflation</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function receiveInflation(\n) external payable;\n</code></pre> <p>Receive native tokens from inflation.</p> <p>Only the <code>inflation</code> contract can call this method.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_setdailyauthorizedinflation_e2739563","title":"<code>setDailyAuthorizedInflation</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function setDailyAuthorizedInflation(\n    uint256 _toAuthorizeWei\n) external;\n</code></pre> <p>Notify the receiver that it is entitled to receive a new inflation amount.</p> <p>Only the <code>inflation</code> contract can call this method.</p> Parameters Type Description <code>_toAuthorizeWei</code> <code>uint256</code> The amount of inflation that can be awarded in the coming day, in wei."},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_setdataproviderfeepercentage_16e69328","title":"<code>setDataProviderFeePercentage</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function setDataProviderFeePercentage(\n    uint256 _feePercentageBIPS\n) external returns (\n    uint256);\n</code></pre> <p>Sets the fee a data provider keeps from all delegations.</p> <p>Takes effect after <code>feeValueUpdateOffset</code> reward epochs have elapsed.</p> <p>When called multiple times inside the same reward epoch, only the last value remains.</p> Parameters Type Description <code>_feePercentageBIPS</code> <code>uint256</code> Fee percentage in BIPS. Returns Type Description [0] <code>uint256</code>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_setinitialrewarddata_1de56098","title":"<code>setInitialRewardData</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function setInitialRewardData(\n) external;\n</code></pre> <p>Copy initial reward data from <code>oldFtsoRewardManager</code> before starting up this new reward manager. Should be called at the time of switching to the new reward manager, can be called only once, and only by <code>governance</code>.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_setnewftsorewardmanager_82a2b905","title":"<code>setNewFtsoRewardManager</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>function setNewFtsoRewardManager(\n    address _newFtsoRewardManager\n) external;\n</code></pre> <p>Sets new ftso reward manager which will take over closing expired reward epochs Should be called at the time of switching to the new reward manager, can be called only once, and only by <code>governance</code>.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#fn_updatecontractaddresses_b00c0b76","title":"<code>updateContractAddresses</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function updateContractAddresses(\n    bytes32[] _contractNameHashes,\n    address[] _contractAddresses\n) external;\n</code></pre> <p>External method called from <code>AddressUpdater</code> only.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/FtsoRewardManager/#md_mustbalance","title":"<code>mustBalance</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>modifier mustBalance()\n</code></pre>"},{"location":"apis/smart-contracts/FtsoRewardManager/#md_nonreentrant","title":"<code>nonReentrant</code>","text":"<p>Defined in <code>ReentrancyGuard</code> (Source).</p> <pre><code>modifier nonReentrant()\n</code></pre> <p>Prevents a contract from calling itself, directly or indirectly. Calling a <code>nonReentrant</code> function from another <code>nonReentrant</code> function is not supported. It is possible to prevent this from happening by making the <code>nonReentrant</code> function external, and make it call a <code>private</code> function that does the actual work.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#md_onlyaddressupdater","title":"<code>onlyAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>modifier onlyAddressUpdater()\n</code></pre> <p>Only the <code>AdressUpdater</code> contract can call this method. Its address is set at construction time but it can also update itself.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#md_onlyexecutorandallowedrecipient","title":"<code>onlyExecutorAndAllowedRecipient</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>modifier onlyExecutorAndAllowedRecipient(    address _rewardOwner,\n    address _recipient)\n</code></pre> <p>Only the reward owner and its authorized executors can call this method. Executors can only send rewards to authorized recipients. See <code>ClaimSetupManager</code>.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#md_onlyftsomanager","title":"<code>onlyFtsoManager</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>modifier onlyFtsoManager()\n</code></pre> <p>Only the <code>ftsoManager</code> contract can call this method.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#md_onlygovernance","title":"<code>onlyGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/FtsoRewardManager/#md_onlyifactive","title":"<code>onlyIfActive</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>modifier onlyIfActive()\n</code></pre> <p>This method can only be called if the contract is <code>active</code>.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#md_onlyimmediategovernance","title":"<code>onlyImmediateGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyImmediateGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/FtsoRewardManager/#md_onlyinflation","title":"<code>onlyInflation</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>modifier onlyInflation()\n</code></pre> <p>Only the <code>Inflation</code> contract can call this method.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#structures","title":"Structures","text":""},{"location":"apis/smart-contracts/FtsoRewardManager/#st_rewardclaim","title":"<code>RewardClaim</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>struct RewardClaim {\n  bool claimed;\n  uint128 amount;\n}\n</code></pre>"},{"location":"apis/smart-contracts/FtsoRewardManager/#st_rewardstate","title":"<code>RewardState</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>struct RewardState {\n  address[] dataProviders;\n  uint256[] weights;\n  uint256[] amounts;\n  bool[] claimed;\n}\n</code></pre>"},{"location":"apis/smart-contracts/FtsoRewardManager/#st_timelockedcall","title":"<code>TimelockedCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>struct TimelockedCall {\n  uint256 allowedAfterTimestamp;\n  bytes encodedCall;\n}\n</code></pre>"},{"location":"apis/smart-contracts/FtsoRewardManager/#st_unclaimedrewardstate","title":"<code>UnclaimedRewardState</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>struct UnclaimedRewardState {\n  uint128 amount;\n  uint128 weight;\n}\n</code></pre>"},{"location":"apis/smart-contracts/FtsoRewardManager/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/FtsoRewardManager/#va_active","title":"<code>active</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>    bool active\n</code></pre> <p>Whether rewards can be claimed from this reward manager.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#va_claimsetupmanager","title":"<code>claimSetupManager</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>    contract IIClaimSetupManager claimSetupManager\n</code></pre> <p>The <code>ClaimSetupManager</code> contract that helps automate reward claiming.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#va_firstclaimablerewardepoch","title":"<code>firstClaimableRewardEpoch</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>    uint256 firstClaimableRewardEpoch\n</code></pre> <p>Epochs before the token distribution event at Flare launch were not be claimable. This variable holds the first reward epoch that was claimable.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#va_ftsomanager","title":"<code>ftsoManager</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>    contract IIFtsoManager ftsoManager\n</code></pre> <p>The <code>FtsoManager</code> contract that controls reward distribution.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#va_governancesettings","title":"<code>governanceSettings</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    contract IGovernanceSettings governanceSettings\n</code></pre> <p>Governance Settings.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#va_newftsorewardmanager","title":"<code>newFtsoRewardManager</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>    address newFtsoRewardManager\n</code></pre> <p>Address of the new <code>FtsoRewardManager</code> that replaced this one.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#va_oldftsorewardmanager","title":"<code>oldFtsoRewardManager</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>    address oldFtsoRewardManager\n</code></pre> <p>Address of the old <code>FtsoRewardManager</code>, replaced by this one.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#va_productionmode","title":"<code>productionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    bool productionMode\n</code></pre> <p>When true, <code>governance</code> is enabled and cannot be disabled. See <code>switchToProductionMode</code>.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#va_timelockedcalls","title":"<code>timelockedCalls</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    mapping(bytes4 =&gt; struct GovernedBase.TimelockedCall) timelockedCalls\n</code></pre> <p>List of pending timelocked <code>governance</code> calls.</p>"},{"location":"apis/smart-contracts/FtsoRewardManager/#va_wnat","title":"<code>wNat</code>","text":"<p>Defined in <code>FtsoRewardManager</code> (Docs, Source).</p> <pre><code>    contract WNat wNat\n</code></pre> <p>Address of the wrapped native token (<code>WNat</code>) contract.</p>"},{"location":"apis/smart-contracts/GovernanceSettings/","title":"GovernanceSettings","text":""},{"location":"apis/smart-contracts/GovernanceSettings/#ct_governancesettings","title":"<code>GovernanceSettings</code>","text":"<p>Source | Inherits from IGovernanceSettings</p> <p>A special contract that holds the Flare governance address and its timelock.</p> <p>All governance calls are delayed by the timelock specified in this contract.</p> <p>This contract enables updating governance address and timelock only by hard-forking the network, this is, only by updating validator code.</p>"},{"location":"apis/smart-contracts/GovernanceSettings/#events","title":"Events","text":""},{"location":"apis/smart-contracts/GovernanceSettings/#ev_governanceaddressupdated","title":"<code>GovernanceAddressUpdated</code>","text":"<p>Defined in <code>GovernanceSettings</code> (Docs, Source).</p> <pre><code>event GovernanceAddressUpdated(\n    uint256 timestamp,\n    address oldGovernanceAddress,\n    address newGovernanceAddress\n)\n</code></pre> <p>Emitted when the governance address has been changed.</p> Parameters Type Description <code>timestamp</code> <code>uint256</code> Timestamp of the block where the change happened, in seconds from UNIX epoch. <code>oldGovernanceAddress</code> <code>address</code> Governance address before the change. <code>newGovernanceAddress</code> <code>address</code> Governance address after the change."},{"location":"apis/smart-contracts/GovernanceSettings/#ev_governanceexecutorsupdated","title":"<code>GovernanceExecutorsUpdated</code>","text":"<p>Defined in <code>GovernanceSettings</code> (Docs, Source).</p> <pre><code>event GovernanceExecutorsUpdated(\n    uint256 timestamp,\n    address[] oldExecutors,\n    address[] newExecutors\n)\n</code></pre> <p>The list of addresses that are allowed to perform governance calls has been changed.</p> Parameters Type Description <code>timestamp</code> <code>uint256</code> Timestamp of the block where the change happened, in seconds from UNIX epoch. <code>oldExecutors</code> <code>address[]</code> Array of executor addresses before the change. <code>newExecutors</code> <code>address[]</code> Array of executor addresses after the change."},{"location":"apis/smart-contracts/GovernanceSettings/#ev_governancetimelockupdated","title":"<code>GovernanceTimelockUpdated</code>","text":"<p>Defined in <code>GovernanceSettings</code> (Docs, Source).</p> <pre><code>event GovernanceTimelockUpdated(\n    uint256 timestamp,\n    uint256 oldTimelock,\n    uint256 newTimelock\n)\n</code></pre> <p>Emitted when the timelock has been changed.</p> Parameters Type Description <code>timestamp</code> <code>uint256</code> Timestamp of the block where the change happened, in seconds from UNIX epoch. <code>oldTimelock</code> <code>uint256</code> Timelock before the change (in seconds). <code>newTimelock</code> <code>uint256</code> Timelock after the change (in seconds)."},{"location":"apis/smart-contracts/GovernanceSettings/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/GovernanceSettings/#fn_getexecutors_ef09e78f","title":"<code>getExecutors</code>","text":"<p>Defined in <code>GovernanceSettings</code> (Docs, Source).</p> <pre><code>function getExecutors(\n) external view returns (\n    address[]);\n</code></pre> <p>Gets the addresses of the accounts that are allowed to execute the timelocked governance calls, once the timelock period expires. Executors can be changed without a hard fork, via a normal governance call.</p> Returns Type Description [0] <code>address[]</code>"},{"location":"apis/smart-contracts/GovernanceSettings/#fn_getgovernanceaddress_73252494","title":"<code>getGovernanceAddress</code>","text":"<p>Defined in <code>GovernanceSettings</code> (Docs, Source).</p> <pre><code>function getGovernanceAddress(\n) external view returns (\n    address);\n</code></pre> <p>Gets the governance account address. The governance address can only be changed by a hard fork.</p> Returns Type Description [0] <code>address</code>"},{"location":"apis/smart-contracts/GovernanceSettings/#fn_gettimelock_6221a54b","title":"<code>getTimelock</code>","text":"<p>Defined in <code>GovernanceSettings</code> (Docs, Source).</p> <pre><code>function getTimelock(\n) external view returns (\n    uint256);\n</code></pre> <p>Gets the time in seconds that must pass between a governance call and its execution. The timelock value can only be changed by a hard fork.</p> Returns Type Description [0] <code>uint256</code>"},{"location":"apis/smart-contracts/GovernanceSettings/#fn_initialise_cf0ea268","title":"<code>initialise</code>","text":"<p>Defined in <code>GovernanceSettings</code> (Docs, Source).</p> <pre><code>function initialise(\n    address _governanceAddress,\n    uint256 _timelock,\n    address[] _executors\n) external;\n</code></pre> <p>Perform initialization, which cannot be done in constructor, since this is a genesis contract. Can only be called once.</p> Parameters Type Description <code>_governanceAddress</code> <code>address</code> Initial governance address. <code>_timelock</code> <code>uint256</code> Initial timelock value, in seconds. <code>_executors</code> <code>address[]</code> Initial list of addresses allowed to perform governance calls."},{"location":"apis/smart-contracts/GovernanceSettings/#fn_isexecutor_debfda30","title":"<code>isExecutor</code>","text":"<p>Defined in <code>GovernanceSettings</code> (Docs, Source).</p> <pre><code>function isExecutor(\n    address _address\n) external view returns (\n    bool);\n</code></pre> <p>Checks whether an address is one of the allowed executors. See <code>getExecutors</code>.</p> Parameters Type Description <code>_address</code> <code>address</code> The address to check. Returns Type Description [0] <code>bool</code> True if <code>_address</code> is in the executors list."},{"location":"apis/smart-contracts/GovernanceSettings/#fn_setexecutors_1d452e46","title":"<code>setExecutors</code>","text":"<p>Defined in <code>GovernanceSettings</code> (Docs, Source).</p> <pre><code>function setExecutors(\n    address[] _newExecutors\n) external;\n</code></pre> <p>Set the addresses of the accounts that are allowed to execute the timelocked governance calls once the timelock period expires. It isn't very dangerous to allow for anyone to execute timelocked calls, but we reserve the right to make sure the timing of the execution is under control. Can only be called by the governance.</p> Parameters Type Description <code>_newExecutors</code> <code>address[]</code> New list of allowed executors. The previous list is replaced."},{"location":"apis/smart-contracts/GovernanceSettings/#fn_setgovernanceaddress_cfc16254","title":"<code>setGovernanceAddress</code>","text":"<p>Defined in <code>GovernanceSettings</code> (Docs, Source).</p> <pre><code>function setGovernanceAddress(\n    address _newGovernance\n) external;\n</code></pre> <p>Change the governance address. Can only be called by validators via fork.</p> Parameters Type Description <code>_newGovernance</code> <code>address</code> New governance address."},{"location":"apis/smart-contracts/GovernanceSettings/#fn_settimelock_1e891c0a","title":"<code>setTimelock</code>","text":"<p>Defined in <code>GovernanceSettings</code> (Docs, Source).</p> <pre><code>function setTimelock(\n    uint256 _newTimelock\n) external;\n</code></pre> <p>Change the timelock, this is, the amount of time between a governance call and its execution. Can only be called by validators via fork.</p> Parameters Type Description <code>_newTimelock</code> <code>uint256</code> New timelock value, in seconds."},{"location":"apis/smart-contracts/GovernanceSettings/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/GovernanceSettings/#va_signal_coinbase","title":"<code>SIGNAL_COINBASE</code>","text":"<p>Defined in <code>GovernanceSettings</code> (Docs, Source).</p> <pre><code>    address SIGNAL_COINBASE\n</code></pre>"},{"location":"apis/smart-contracts/GovernanceVotePower/","title":"GovernanceVotePower","text":""},{"location":"apis/smart-contracts/GovernanceVotePower/#ct_governancevotepower","title":"<code>GovernanceVotePower</code>","text":"<p>Source | Inherits from IIGovernanceVotePower</p> <p>Contract managing governance vote power and its delegation.</p>"},{"location":"apis/smart-contracts/GovernanceVotePower/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/GovernanceVotePower/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>constructor(\n    contract IVPToken _ownerToken\n) public;\n</code></pre> <p>Construct <code>GovernanceVotePower</code> for given <code>VPToken</code>.</p>"},{"location":"apis/smart-contracts/GovernanceVotePower/#fn_delegate_5c19a95c","title":"<code>delegate</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>function delegate(\n    address _to\n) public;\n</code></pre> <p>Delegates all governance vote power of <code>msg.sender</code> to address <code>_to</code>.</p> Parameters Type Description <code>_to</code> <code>address</code> The address of the recipient."},{"location":"apis/smart-contracts/GovernanceVotePower/#fn_delegatedgovernancevotepowerhistorycleanup_29a59ff2","title":"<code>delegatedGovernanceVotePowerHistoryCleanup</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>function delegatedGovernanceVotePowerHistoryCleanup(\n    address _owner,\n    uint256 _count\n) external returns (\n    uint256);\n</code></pre> <p>Delete governance vote power checkpoints that expired (i.e. are before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_owner</code> <code>address</code> Vote power owner account address. <code>_count</code> <code>uint256</code> Maximum number of checkpoints to delete. Returns Type Description [0] <code>uint256</code> The number of deleted checkpoints."},{"location":"apis/smart-contracts/GovernanceVotePower/#fn_delegateshistorycleanup_f7ce0ddf","title":"<code>delegatesHistoryCleanup</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>function delegatesHistoryCleanup(\n    address _owner,\n    uint256 _count\n) external returns (\n    uint256);\n</code></pre> <p>Delete delegates checkpoints that expired (i.e. are before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_owner</code> <code>address</code> Vote power owner account address. <code>_count</code> <code>uint256</code> Maximum number of checkpoints to delete. Returns Type Description [0] <code>uint256</code> The number of deleted checkpoints."},{"location":"apis/smart-contracts/GovernanceVotePower/#fn_getcleanupblocknumber_a72ec4b6","title":"<code>getCleanupBlockNumber</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>function getCleanupBlockNumber(\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current cleanup block number set with <code>setCleanupBlockNumber</code>.</p> Returns Type Description [0] <code>uint256</code> The currently set cleanup block number."},{"location":"apis/smart-contracts/GovernanceVotePower/#fn_getdelegateofat_3c028e9d","title":"<code>getDelegateOfAt</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>function getDelegateOfAt(\n    address _who,\n    uint256 _blockNumber\n) public view returns (\n    address);\n</code></pre> <p>Gets the address an account is delegating its governance vote power to, at a given block number.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. <code>_blockNumber</code> <code>uint256</code> The block number at which to fetch the address. Returns Type Description [0] <code>address</code> Address where <code>_who</code> was delegating its governance vote power at block <code>_blockNumber</code>."},{"location":"apis/smart-contracts/GovernanceVotePower/#fn_getdelegateofatnow_b3e871ee","title":"<code>getDelegateOfAtNow</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>function getDelegateOfAtNow(\n    address _who\n) public view returns (\n    address);\n</code></pre> <p>Gets the address an account is delegating its governance vote power to, at the latest block number.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. Returns Type Description [0] <code>address</code> Address where <code>_who</code> is currently delegating its governance vote power."},{"location":"apis/smart-contracts/GovernanceVotePower/#fn_getvotes_9ab24eb0","title":"<code>getVotes</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>function getVotes(\n    address _who\n) public view returns (\n    uint256);\n</code></pre> <p>Gets the governance vote power of an address at the latest block, including all delegations made to it.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. Returns Type Description [0] <code>uint256</code> Governance vote power of <code>account</code> at the lastest block."},{"location":"apis/smart-contracts/GovernanceVotePower/#fn_ownertoken_65371883","title":"<code>ownerToken</code>","text":"<p>Defined in <code>IIGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function ownerToken(\n) external view returns (\n    contract IVPToken);\n</code></pre> <p>Get the token that this governance vote power contract belongs to.</p> Returns Type Description [0] <code>contract IVPToken</code> The <code>IVPToken</code> interface owning this contract."},{"location":"apis/smart-contracts/GovernanceVotePower/#fn_setcleanercontract_f6a494af","title":"<code>setCleanerContract</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>function setCleanerContract(\n    address _cleanerContract\n) external;\n</code></pre> <p>Set the contract that is allowed to call history cleaning methods.</p> <p>This method can be called by the <code>ownerToken</code> only.</p> Parameters Type Description <code>_cleanerContract</code> <code>address</code> Address of the cleanup contract. Usually this will be an instance of <code>CleanupBlockNumberManager</code>."},{"location":"apis/smart-contracts/GovernanceVotePower/#fn_setcleanupblocknumber_13de97f5","title":"<code>setCleanupBlockNumber</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>function setCleanupBlockNumber(\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Set the cleanup block number. Historic data for the blocks before <code>cleanupBlockNumber</code> can be erased. History before that block should never be used since it can be inconsistent. In particular, cleanup block number must be lower than the current vote power block.</p> <p>This method can be called by the <code>ownerToken</code> only.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The new cleanup block number."},{"location":"apis/smart-contracts/GovernanceVotePower/#fn_undelegate_92ab89bb","title":"<code>undelegate</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>function undelegate(\n) public;\n</code></pre> <p>Undelegates all governance vote power of <code>msg.sender</code>.</p>"},{"location":"apis/smart-contracts/GovernanceVotePower/#fn_updateattokentransfer_eadb4362","title":"<code>updateAtTokenTransfer</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>function updateAtTokenTransfer(\n    address _from,\n    address _to,\n    uint256,\n    uint256,\n    uint256 _amount\n) external;\n</code></pre> <p>Update governance vote power of all involved delegates after tokens are transferred.</p> <p>This function MUST be called after each governance token transfer for the delegates to reflect the correct balance.</p> Parameters Type Description <code>_from</code> <code>address</code> Source address of the transfer. <code>_to</code> <code>address</code> Destination address of the transfer. `` <code>uint256</code> `` <code>uint256</code> <code>_amount</code> <code>uint256</code> Amount being transferred."},{"location":"apis/smart-contracts/GovernanceVotePower/#fn_votepowerofat_92bfe6d8","title":"<code>votePowerOfAt</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>function votePowerOfAt(\n    address _who,\n    uint256 _blockNumber\n) public view returns (\n    uint256);\n</code></pre> <p>Gets the governance vote power of an address at a given block number, including all delegations made to it.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. <code>_blockNumber</code> <code>uint256</code> The block number at which to fetch the vote power. Returns Type Description [0] <code>uint256</code> Governance vote power of <code>_who</code> at <code>_blockNumber</code>."},{"location":"apis/smart-contracts/GovernanceVotePower/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/GovernanceVotePower/#md_onlycleaner","title":"<code>onlyCleaner</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>modifier onlyCleaner()\n</code></pre> <p>History cleaning methods can be called only from the cleaner address.</p>"},{"location":"apis/smart-contracts/GovernanceVotePower/#md_onlyownertoken","title":"<code>onlyOwnerToken</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>modifier onlyOwnerToken()\n</code></pre> <p>All external methods in <code>GovernanceVotePower</code> can only be executed by the owner token.</p>"},{"location":"apis/smart-contracts/GovernanceVotePower/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/GovernanceVotePower/#va_cleanercontract","title":"<code>cleanerContract</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>    address cleanerContract\n</code></pre> <p>Address of the contract that is allowed to call methods for history cleaning. Set with <code>setCleanerContract</code>.</p>"},{"location":"apis/smart-contracts/GovernanceVotePower/#va_ownertoken","title":"<code>ownerToken</code>","text":"<p>Defined in <code>GovernanceVotePower</code> (Docs, Source).</p> <pre><code>    contract IVPToken ownerToken\n</code></pre> <p>The <code>VPToken</code> (or some other contract) that owns this <code>GovernanceVotePower</code>. All state changing methods may be called only from this address. This is because original <code>msg.sender</code> is typically sent in a parameter and we must make sure that it cannot be faked by directly calling <code>GovernanceVotePower</code> methods.</p>"},{"location":"apis/smart-contracts/Governed/","title":"Governed","text":""},{"location":"apis/smart-contracts/Governed/#ct_governed","title":"<code>Governed</code>","text":"<p>Source | Inherits from GovernedBase</p> <p>Defines behaviors for governed contracts that must have a governor set at construction-time.</p>"},{"location":"apis/smart-contracts/Governed/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/Governed/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/Governed/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>Governed</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance\n) public;\n</code></pre> Parameters Type Description <code>_governance</code> <code>address</code> Governance contract. Must not be zero."},{"location":"apis/smart-contracts/Governed/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/Governed/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/Governed/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/","title":"GovernedAndFlareDaemonized","text":""},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#ct_governedandflaredaemonized","title":"<code>GovernedAndFlareDaemonized</code>","text":"<p>Source | Inherits from Governed</p> <p>Base class for contracts that are governed and triggered from the <code>FlareDaemon</code>.</p> <p>See <code>Governed</code> and <code>IFlareDaemonize</code>.</p>"},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>GovernedAndFlareDaemonized</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance,\n    contract FlareDaemon _flareDaemon\n) public;\n</code></pre>"},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>Governed</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance\n) public;\n</code></pre> Parameters Type Description <code>_governance</code> <code>address</code> Governance contract. Must not be zero."},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#md_onlyflaredaemon","title":"<code>onlyFlareDaemon</code>","text":"<p>Defined in <code>GovernedAndFlareDaemonized</code> (Docs, Source).</p> <pre><code>modifier onlyFlareDaemon()\n</code></pre> <p>Only the <code>flareDaemon</code> can call this method.</p>"},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#md_onlygovernance","title":"<code>onlyGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#md_onlyimmediategovernance","title":"<code>onlyImmediateGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyImmediateGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#va_flaredaemon","title":"<code>flareDaemon</code>","text":"<p>Defined in <code>GovernedAndFlareDaemonized</code> (Docs, Source).</p> <pre><code>    contract FlareDaemon flareDaemon\n</code></pre> <p>The <code>FlareDaemon</code> contract, set at construction time.</p>"},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#va_governancesettings","title":"<code>governanceSettings</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    contract IGovernanceSettings governanceSettings\n</code></pre> <p>Governance Settings.</p>"},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#va_productionmode","title":"<code>productionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    bool productionMode\n</code></pre> <p>When true, <code>governance</code> is enabled and cannot be disabled. See <code>switchToProductionMode</code>.</p>"},{"location":"apis/smart-contracts/GovernedAndFlareDaemonized/#va_timelockedcalls","title":"<code>timelockedCalls</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    mapping(bytes4 =&gt; struct GovernedBase.TimelockedCall) timelockedCalls\n</code></pre> <p>List of pending timelocked <code>governance</code> calls.</p>"},{"location":"apis/smart-contracts/GovernedAtGenesis/","title":"GovernedAtGenesis","text":""},{"location":"apis/smart-contracts/GovernedAtGenesis/#ct_governedatgenesis","title":"<code>GovernedAtGenesis</code>","text":"<p>Source | Inherits from GovernedBase</p> <p>Defines behaviors for governed contracts that have their governor set at genesis.</p> <p>This contract enforces a fixed <code>governance</code> address when the <code>constructor</code> is not executed on a contract (for instance when directly loaded to the genesis block). This is required to fix <code>governance</code> on a contract when the network starts, at such point where theoretically no accounts yet exist, and leaving it ungoverned could result in a race to claim <code>governance</code> by an unauthorized address.</p>"},{"location":"apis/smart-contracts/GovernedAtGenesis/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/GovernedAtGenesis/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/GovernedAtGenesis/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>GovernedAtGenesis</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance\n) public;\n</code></pre>"},{"location":"apis/smart-contracts/GovernedAtGenesis/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/GovernedAtGenesis/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/GovernedAtGenesis/#fn_initialise_9d6a890f","title":"<code>initialise</code>","text":"<p>Defined in <code>GovernedAtGenesis</code> (Docs, Source).</p> <pre><code>function initialise(\n    address _governance\n) public pure;\n</code></pre> <p>Disallow <code>initialise</code> to be called.</p> Parameters Type Description <code>_governance</code> <code>address</code> The governance address for initial claiming."},{"location":"apis/smart-contracts/GovernedAtGenesis/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/GovernedBase/","title":"GovernedBase","text":""},{"location":"apis/smart-contracts/GovernedBase/#ct_governedbase","title":"<code>GovernedBase</code>","text":"<p>Source</p> <p>Abstract base class that defines behaviors for governed contracts.</p> <p>This class is abstract so that specific behaviors can be defined for the constructor. Contracts should not be left ungoverned, but not all contract will have a constructor (for example those pre-defined in genesis).</p>"},{"location":"apis/smart-contracts/GovernedBase/#events","title":"Events","text":""},{"location":"apis/smart-contracts/GovernedBase/#ev_governancecalltimelocked","title":"<code>GovernanceCallTimelocked</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernanceCallTimelocked(\n    bytes4 selector,\n    uint256 allowedAfterTimestamp,\n    bytes encodedCall\n)\n</code></pre> <p>Emitted when a new <code>governance</code> call has been recorded and is now waiting for the time lock to expire.</p>"},{"location":"apis/smart-contracts/GovernedBase/#ev_governanceinitialised","title":"<code>GovernanceInitialised</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernanceInitialised(\n    address initialGovernance\n)\n</code></pre> <p>Emitted when the <code>governance</code> address is initialized. This address will be used until production mode is entered (see <code>GovernedProductionModeEntered</code>). At that point the <code>governance</code> address is taken from <code>GovernanceSettings</code>.</p>"},{"location":"apis/smart-contracts/GovernedBase/#ev_governedproductionmodeentered","title":"<code>GovernedProductionModeEntered</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernedProductionModeEntered(\n    address governanceSettings\n)\n</code></pre> <p>Emitted when <code>governance</code> is enabled and the <code>governance</code> address cannot be changed anymore (only through a network fork).</p>"},{"location":"apis/smart-contracts/GovernedBase/#ev_timelockedgovernancecallcanceled","title":"<code>TimelockedGovernanceCallCanceled</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event TimelockedGovernanceCallCanceled(\n    bytes4 selector,\n    uint256 timestamp\n)\n</code></pre> <p>Emitted when a timelocked <code>governance</code> call is canceled before execution.</p>"},{"location":"apis/smart-contracts/GovernedBase/#ev_timelockedgovernancecallexecuted","title":"<code>TimelockedGovernanceCallExecuted</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event TimelockedGovernanceCallExecuted(\n    bytes4 selector,\n    uint256 timestamp\n)\n</code></pre> <p>Emitted when a timelocked <code>governance</code> call is executed.</p>"},{"location":"apis/smart-contracts/GovernedBase/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/GovernedBase/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/GovernedBase/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/GovernedBase/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/GovernedBase/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/GovernedBase/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/GovernedBase/#md_onlygovernance","title":"<code>onlyGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/GovernedBase/#md_onlyimmediategovernance","title":"<code>onlyImmediateGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyImmediateGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/GovernedBase/#structures","title":"Structures","text":""},{"location":"apis/smart-contracts/GovernedBase/#st_timelockedcall","title":"<code>TimelockedCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>struct TimelockedCall {\n  uint256 allowedAfterTimestamp;\n  bytes encodedCall;\n}\n</code></pre>"},{"location":"apis/smart-contracts/GovernedBase/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/GovernedBase/#va_governancesettings","title":"<code>governanceSettings</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    contract IGovernanceSettings governanceSettings\n</code></pre> <p>Governance Settings.</p>"},{"location":"apis/smart-contracts/GovernedBase/#va_productionmode","title":"<code>productionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    bool productionMode\n</code></pre> <p>When true, <code>governance</code> is enabled and cannot be disabled. See <code>switchToProductionMode</code>.</p>"},{"location":"apis/smart-contracts/GovernedBase/#va_timelockedcalls","title":"<code>timelockedCalls</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    mapping(bytes4 =&gt; struct GovernedBase.TimelockedCall) timelockedCalls\n</code></pre> <p>List of pending timelocked <code>governance</code> calls.</p>"},{"location":"apis/smart-contracts/IClaimSetupManager/","title":"IClaimSetupManager","text":""},{"location":"apis/smart-contracts/IClaimSetupManager/#ct_iclaimsetupmanager","title":"<code>IClaimSetupManager</code>","text":"<p>Source</p> <p>Public interface for the <code>ClaimSetupManager</code> contract.</p>"},{"location":"apis/smart-contracts/IClaimSetupManager/#events","title":"Events","text":""},{"location":"apis/smart-contracts/IClaimSetupManager/#ev_allowedclaimrecipientschanged","title":"<code>AllowedClaimRecipientsChanged</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event AllowedClaimRecipientsChanged(\n    address owner,\n    address[] recipients\n)\n</code></pre>"},{"location":"apis/smart-contracts/IClaimSetupManager/#ev_claimexecutorfeevaluechanged","title":"<code>ClaimExecutorFeeValueChanged</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event ClaimExecutorFeeValueChanged(\n    address executor,\n    uint256 validFromRewardEpoch,\n    uint256 feeValueWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/IClaimSetupManager/#ev_claimexecutorschanged","title":"<code>ClaimExecutorsChanged</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event ClaimExecutorsChanged(\n    address owner,\n    address[] executors\n)\n</code></pre>"},{"location":"apis/smart-contracts/IClaimSetupManager/#ev_delegationaccountcreated","title":"<code>DelegationAccountCreated</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event DelegationAccountCreated(\n    address owner,\n    contract IDelegationAccount delegationAccount\n)\n</code></pre>"},{"location":"apis/smart-contracts/IClaimSetupManager/#ev_delegationaccountupdated","title":"<code>DelegationAccountUpdated</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event DelegationAccountUpdated(\n    address owner,\n    contract IDelegationAccount delegationAccount,\n    bool enabled\n)\n</code></pre>"},{"location":"apis/smart-contracts/IClaimSetupManager/#ev_executorregistered","title":"<code>ExecutorRegistered</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event ExecutorRegistered(\n    address executor\n)\n</code></pre>"},{"location":"apis/smart-contracts/IClaimSetupManager/#ev_executorunregistered","title":"<code>ExecutorUnregistered</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event ExecutorUnregistered(\n    address executor,\n    uint256 validFromRewardEpoch\n)\n</code></pre>"},{"location":"apis/smart-contracts/IClaimSetupManager/#ev_maxfeeset","title":"<code>MaxFeeSet</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event MaxFeeSet(\n    uint256 maxFeeValueWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/IClaimSetupManager/#ev_minfeeset","title":"<code>MinFeeSet</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event MinFeeSet(\n    uint256 minFeeValueWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/IClaimSetupManager/#ev_registerexecutorfeeset","title":"<code>RegisterExecutorFeeSet</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event RegisterExecutorFeeSet(\n    uint256 registerExecutorFeeValueWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/IClaimSetupManager/#ev_setexecutorsexcessamountrefunded","title":"<code>SetExecutorsExcessAmountRefunded</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event SetExecutorsExcessAmountRefunded(\n    address owner,\n    uint256 excessAmount\n)\n</code></pre>"},{"location":"apis/smart-contracts/IClaimSetupManager/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_accounttodelegationaccount_69ea2387","title":"<code>accountToDelegationAccount</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function accountToDelegationAccount(\n    address _owner\n) external view returns (\n    address);\n</code></pre> <p>Gets the PDA of an account.</p> Parameters Type Description <code>_owner</code> <code>address</code> Account to query. Returns Type Description [0] <code>address</code> Address of its PDA or <code>address(0)</code> if it has not been created yet."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_allowedclaimrecipients_dfd14c34","title":"<code>allowedClaimRecipients</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function allowedClaimRecipients(\n    address _rewardOwner\n) external view returns (\n    address[]);\n</code></pre> <p>Gets the addresses of recipients allowed to receive rewards on behalf of an account. Beside these, the owner of the rewards is always authorized. See <code>setAllowedClaimRecipients</code>.</p> Parameters Type Description <code>_rewardOwner</code> <code>address</code> The account to query. Returns Type Description [0] <code>address[]</code> Addresses of all set authorized recipients."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_batchdelegate_dc4fcda7","title":"<code>batchDelegate</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function batchDelegate(\n    address[] _delegatees,\n    uint256[] _bips\n) external;\n</code></pre> <p>Undelegates all percentage delegations from the caller's PDA and then <code>delegate</code> to a list of accounts.</p> <p>See <code>delegate</code>.</p> Parameters Type Description <code>_delegatees</code> <code>address[]</code> The addresses of the new recipients. <code>_bips</code> <code>uint256[]</code> The percentage of voting power to be delegated to each delegatee, expressed in basis points (1/100 of one percent). Total of all <code>_bips</code> values must be lower than 10000."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_claimexecutors_3f317fe1","title":"<code>claimExecutors</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function claimExecutors(\n    address _owner\n) external view returns (\n    address[]);\n</code></pre> <p>Gets the addresses of executors authorized to claim for an account. See <code>setClaimExecutors</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> The account to query. Returns Type Description [0] <code>address[]</code> Addresses of all set executors."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_delegate_026e402b","title":"<code>delegate</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function delegate(\n    address _to,\n    uint256 _bips\n) external;\n</code></pre> <p>Delegates a percentage of the caller's PDA's voting power to another address.</p> Parameters Type Description <code>_to</code> <code>address</code> The address of the recipient. <code>_bips</code> <code>uint256</code> The percentage of voting power to be delegated expressed in basis points (1/100 of one percent). Not cumulative: Every call resets the delegation value. A value of 0 revokes delegation."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_delegategovernance_7a68a508","title":"<code>delegateGovernance</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function delegateGovernance(\n    address _to\n) external;\n</code></pre> <p>Delegates all the governance vote power of the caller's PDA to another account.</p> Parameters Type Description <code>_to</code> <code>address</code> Address of the recipient of the delegation."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_disabledelegationaccount_2394deb1","title":"<code>disableDelegationAccount</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function disableDelegationAccount(\n) external;\n</code></pre> <p>Disables the Personal Delegation Account (PDA).</p> <p>When using automatic claiming, all airdrops and FTSO rewards will be sent to the owner's account. Rewards accrued by the PDA will no longer be automatically claimed.</p> <p>Reverts if there is no PDA.</p>"},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_enabledelegationaccount_f0977215","title":"<code>enableDelegationAccount</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function enableDelegationAccount(\n) external returns (\n    contract IDelegationAccount);\n</code></pre> <p>Enables (or creates) a Personal Delegation Account (PDA).</p> <p>When using automatic claiming, all airdrops and FTSO rewards will be sent to the PDA, and any rewards accrued by the PDA will be claimed too.</p> Returns Type Description [0] <code>contract IDelegationAccount</code> Address of the delegation account contract."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_getdelegationaccountdata_17a1e3fc","title":"<code>getDelegationAccountData</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getDelegationAccountData(\n    address _owner\n) external view returns (\n    contract IDelegationAccount _delegationAccount,\n    bool _enabled);\n</code></pre> <p>Gets PDA data for an account.</p> Parameters Type Description <code>_owner</code> <code>address</code> Account to query. Returns Type Description <code>_delegationAccount</code> <code>contract IDelegationAccount</code> Account's PDA address or <code>address(0)</code> if it has not been created yet. <code>_enabled</code> <code>bool</code> Whether the PDA is enabled."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_getexecutorcurrentfeevalue_e25547f8","title":"<code>getExecutorCurrentFeeValue</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getExecutorCurrentFeeValue(\n    address _executor\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the current fee of a registered executor. Reverts if the executor is not registered.</p> Parameters Type Description <code>_executor</code> <code>address</code> The executor to query. Returns Type Description [0] <code>uint256</code> Fee in wei."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_getexecutorfeevalue_3f8f784c","title":"<code>getExecutorFeeValue</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getExecutorFeeValue(\n    address _executor,\n    uint256 _rewardEpoch\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the fee of an executor at a given reward epoch.</p> Parameters Type Description <code>_executor</code> <code>address</code> The executor to query. <code>_rewardEpoch</code> <code>uint256</code> Reward Epoch ID to query. Returns Type Description [0] <code>uint256</code> Fee in wei at that reward epoch."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_getexecutorinfo_8e28b923","title":"<code>getExecutorInfo</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getExecutorInfo(\n    address _executor\n) external view returns (\n    bool _registered,\n    uint256 _currentFeeValue);\n</code></pre> <p>Returns information about an executor.</p> Parameters Type Description <code>_executor</code> <code>address</code> The executor to query. Returns Type Description <code>_registered</code> <code>bool</code> Whether the executor is registered. <code>_currentFeeValue</code> <code>uint256</code> Executor's current fee value, if registered."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_getexecutorscheduledfeevaluechanges_950b028c","title":"<code>getExecutorScheduledFeeValueChanges</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getExecutorScheduledFeeValueChanges(\n    address _executor\n) external view returns (\n    uint256[] _feeValue,\n    uint256[] _validFromEpoch,\n    bool[] _fixed);\n</code></pre> <p>Returns the currently scheduled fee changes of an executor.</p> Parameters Type Description <code>_executor</code> <code>address</code> Executor to query. Returns Type Description <code>_feeValue</code> <code>uint256[]</code> Array of scheduled fees. <code>_validFromEpoch</code> <code>uint256[]</code> Array of reward epochs ID where the scheduled fees will become effective. <code>_fixed</code> <code>bool[]</code> Array of booleans indicating if an scheduled fee change is fixed or it might still be changed."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_getregisteredexecutors_6e927e61","title":"<code>getRegisteredExecutors</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getRegisteredExecutors(\n    uint256 _start,\n    uint256 _end\n) external view returns (\n    address[] _registeredExecutors,\n    uint256 _totalLength);\n</code></pre> <p>Returns the list of executors registered through <code>registerExecutor</code>. Supports paging.</p> Parameters Type Description <code>_start</code> <code>uint256</code> First executor to return. <code>_end</code> <code>uint256</code> Last executor to return. Returns Type Description <code>_registeredExecutors</code> <code>address[]</code> Addresses of the registered executors. <code>_totalLength</code> <code>uint256</code> Total amount of executors."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_isclaimexecutor_87962abe","title":"<code>isClaimExecutor</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function isClaimExecutor(\n    address _owner,\n    address _executor\n) external view returns (\n    bool);\n</code></pre> <p>Returns whether an executor is authorized to claim on behalf of a reward owner. See <code>setClaimExecutors</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> The reward owner to query. <code>_executor</code> <code>address</code> The executor to query."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_registerexecutor_ccce7e86","title":"<code>registerExecutor</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function registerExecutor(\n    uint256 _feeValue\n) external payable returns (\n    uint256);\n</code></pre> <p>Registers the caller as an executor and sets its initial fee value.</p> <p>If the executor was already registered, this method only updates the fee, which will take effect after <code>feeValueUpdateOffset</code> reward epochs have elapsed.</p> <p>Executor must pay a fee in order to register. See <code>registerExecutorFeeValueWei</code>.</p> Parameters Type Description <code>_feeValue</code> <code>uint256</code> Desired fee, in wei. Must be between <code>minFeeValueWei</code> and <code>maxFeeValueWei</code>. 0 means no fee. Returns Type Description [0] <code>uint256</code> Reward epoch ID when the changes become effective."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_revokedelegationat_bbd6fbf8","title":"<code>revokeDelegationAt</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function revokeDelegationAt(\n    address _who,\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Revokes all delegation from the caller's PDA to a given account at a given block.</p> <p>Only affects the reads via <code>votePowerOfAtCached()</code> in the specified block.</p> <p>This method should be used only to prevent rogue <code>delegate</code> voting in the current voting block. To stop delegating use <code>delegate</code> with percentage of 0 or <code>undelegateAll</code>.</p> Parameters Type Description <code>_who</code> <code>address</code> The account to revoke. <code>_blockNumber</code> <code>uint256</code> Block number where the revoking will take place. Must be in the past."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_setallowedclaimrecipients_d2a4ac61","title":"<code>setAllowedClaimRecipients</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setAllowedClaimRecipients(\n    address[] _recipients\n) external;\n</code></pre> <p>Set the addresses of allowed recipients. The reward owner is always an allowed recipient.</p> Parameters Type Description <code>_recipients</code> <code>address[]</code> The new allowed recipients. All old recipients will be deleted and replaced by these."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_setautoclaiming_e72dcdbb","title":"<code>setAutoClaiming</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setAutoClaiming(\n    address[] _executors,\n    bool _enableDelegationAccount\n) external payable;\n</code></pre> <p>Sets the addresses of executors and optionally enables (creates) a Personal Delegation Account (PDA).</p> <p>If any of the executors is a registered executor, some fee needs to be paid.</p> Parameters Type Description <code>_executors</code> <code>address[]</code> The new executors. All old executors will be deleted and replaced by these. <code>_enableDelegationAccount</code> <code>bool</code> Whether the PDA should be enabled."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_setclaimexecutors_9119c494","title":"<code>setClaimExecutors</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setClaimExecutors(\n    address[] _executors\n) external payable;\n</code></pre> <p>Sets the addresses of executors.</p> <p>If any of the executors is a registered executor, some fee needs to be paid.</p> Parameters Type Description <code>_executors</code> <code>address[]</code> The new executors. All old executors will be deleted and replaced by these."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_transferexternaltoken_489a8a47","title":"<code>transferExternalToken</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function transferExternalToken(\n    contract IERC20 _token,\n    uint256 _amount\n) external;\n</code></pre> <p>Allows the caller to transfer ERC-20 tokens from their PDA to the owner account.</p> <p>The main use case is to move ERC-20 tokes received by mistake (by an airdrop, for example) out of the PDA and into the main account, where they can be more easily managed.</p> <p>Reverts if the target token is the <code>WNat</code> contract: use method <code>withdraw</code> for that.</p> Parameters Type Description <code>_token</code> <code>contract IERC20</code> Target token contract address. <code>_amount</code> <code>uint256</code> Amount of tokens to transfer."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_undelegateall_b302f393","title":"<code>undelegateAll</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function undelegateAll(\n) external;\n</code></pre> <p>Removes all delegations from the caller's PDA.</p>"},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_undelegategovernance_87a2a0dc","title":"<code>undelegateGovernance</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function undelegateGovernance(\n) external;\n</code></pre> <p>Undelegates all governance vote power currently delegated by the caller's PDA.</p>"},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_unregisterexecutor_868a660f","title":"<code>unregisterExecutor</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function unregisterExecutor(\n) external returns (\n    uint256);\n</code></pre> <p>Unregisters the caller as an executor.</p> Returns Type Description [0] <code>uint256</code> Reward epoch ID when the change becomes effective."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_updateexecutorfeevalue_831f16af","title":"<code>updateExecutorFeeValue</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function updateExecutorFeeValue(\n    uint256 _feeValue\n) external returns (\n    uint256);\n</code></pre> <p>Sets the caller's executor fee. The caller must be an executor registered through <code>registerExecutor</code>.</p> <p>When called multiple times inside the same reward epoch, only the last value remains.</p> Parameters Type Description <code>_feeValue</code> <code>uint256</code> Desired fee, in wei. Must be between <code>minFeeValueWei</code> and <code>maxFeeValueWei</code>. 0 means no fee. Returns Type Description [0] <code>uint256</code> Reward epoch ID when the changes become effective."},{"location":"apis/smart-contracts/IClaimSetupManager/#fn_withdraw_2e1a7d4d","title":"<code>withdraw</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function withdraw(\n    uint256 _amount\n) external;\n</code></pre> <p>Allows the caller to transfer <code>WNat</code> wrapped tokens from their PDA to the owner account.</p> Parameters Type Description <code>_amount</code> <code>uint256</code> Amount of tokens to transfer, in wei."},{"location":"apis/smart-contracts/IFlareContractRegistry/","title":"IFlareContractRegistry","text":""},{"location":"apis/smart-contracts/IFlareContractRegistry/#ct_iflarecontractregistry","title":"<code>IFlareContractRegistry</code>","text":"<p>Source</p> <p>Interface for the <code>FlareContractRegistry</code>.</p> <p>Entry point for all external dapps that need the latest contract addresses deployed by Flare.</p>"},{"location":"apis/smart-contracts/IFlareContractRegistry/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IFlareContractRegistry/#fn_getallcontracts_18d3ce96","title":"<code>getAllContracts</code>","text":"<p>Defined in <code>IFlareContractRegistry</code> (Docs, Source).</p> <pre><code>function getAllContracts(\n) external view returns (\n    string[] _names,\n    address[] _addresses);\n</code></pre> <p>Returns all contract names and their corresponding addresses.</p> Returns Type Description <code>_names</code> <code>string[]</code> Array of contract names. <code>_addresses</code> <code>address[]</code> Array of corresponding contract addresses."},{"location":"apis/smart-contracts/IFlareContractRegistry/#fn_getcontractaddressbyhash_159354a2","title":"<code>getContractAddressByHash</code>","text":"<p>Defined in <code>IFlareContractRegistry</code> (Docs, Source).</p> <pre><code>function getContractAddressByHash(\n    bytes32 _nameHash\n) external view returns (\n    address);\n</code></pre> <p>Returns the address of a given contract hash.</p> Parameters Type Description <code>_nameHash</code> <code>bytes32</code> Hash of the contract name as: <code>keccak256(abi.encode(name))</code>. Returns Type Description [0] <code>address</code> Address of the contract, or <code>address(0)</code> if not found."},{"location":"apis/smart-contracts/IFlareContractRegistry/#fn_getcontractaddressbyname_82760fca","title":"<code>getContractAddressByName</code>","text":"<p>Defined in <code>IFlareContractRegistry</code> (Docs, Source).</p> <pre><code>function getContractAddressByName(\n    string _name\n) external view returns (\n    address);\n</code></pre> <p>Returns the address of a given contract name.</p> Parameters Type Description <code>_name</code> <code>string</code> Name of the contract. Returns Type Description [0] <code>address</code> Address of the contract, or <code>address(0)</code> if not found."},{"location":"apis/smart-contracts/IFlareContractRegistry/#fn_getcontractaddressesbyhash_5e11e2d1","title":"<code>getContractAddressesByHash</code>","text":"<p>Defined in <code>IFlareContractRegistry</code> (Docs, Source).</p> <pre><code>function getContractAddressesByHash(\n    bytes32[] _nameHashes\n) external view returns (\n    address[]);\n</code></pre> <p>Returns the addresses of a list of contract hashes.</p> Parameters Type Description <code>_nameHashes</code> <code>bytes32[]</code> Array of contract name hashes as: <code>keccak256(abi.encode(name))</code>. Returns Type Description [0] <code>address[]</code> Array of addresses of the contracts. Any of them might be <code>address(0)</code> if not found."},{"location":"apis/smart-contracts/IFlareContractRegistry/#fn_getcontractaddressesbyname_76d2b1af","title":"<code>getContractAddressesByName</code>","text":"<p>Defined in <code>IFlareContractRegistry</code> (Docs, Source).</p> <pre><code>function getContractAddressesByName(\n    string[] _names\n) external view returns (\n    address[]);\n</code></pre> <p>Returns the addresses of a list of contract names.</p> Parameters Type Description <code>_names</code> <code>string[]</code> Array of contract names. Returns Type Description [0] <code>address[]</code> Array of addresses of the contracts. Any of them might be <code>address(0)</code> if not found."},{"location":"apis/smart-contracts/IFlareDaemonize/","title":"IFlareDaemonize","text":""},{"location":"apis/smart-contracts/IFlareDaemonize/#ct_iflaredaemonize","title":"<code>IFlareDaemonize</code>","text":"<p>Source</p> <p>Interface for contracts that receive triggers from the <code>FlareDaemon</code> contract.</p>"},{"location":"apis/smart-contracts/IFlareDaemonize/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IFlareDaemonize/#fn_daemonize_6d0e8c34","title":"<code>daemonize</code>","text":"<p>Defined in <code>IFlareDaemonize</code> (Docs, Source).</p> <pre><code>function daemonize(\n) external returns (\n    bool);\n</code></pre> <p>Implement this function to receive a trigger from the <code>FlareDaemon</code>. The trigger method is called by the validator right at the end of block state transition.</p> Returns Type Description [0] <code>bool</code> bool Whether the contract is still active after the call. Currently unused."},{"location":"apis/smart-contracts/IFlareDaemonize/#fn_getcontractname_f5f5ba72","title":"<code>getContractName</code>","text":"<p>Defined in <code>IFlareDaemonize</code> (Docs, Source).</p> <pre><code>function getContractName(\n) external view returns (\n    string);\n</code></pre> <p>Implement this function to allow updating daemonized contracts through the <code>AddressUpdater</code>.</p> Returns Type Description [0] <code>string</code> string Contract name."},{"location":"apis/smart-contracts/IFlareDaemonize/#fn_switchtofallbackmode_e22fdece","title":"<code>switchToFallbackMode</code>","text":"<p>Defined in <code>IFlareDaemonize</code> (Docs, Source).</p> <pre><code>function switchToFallbackMode(\n) external returns (\n    bool);\n</code></pre> <p>This function will be called after an error is caught in <code>daemonize</code>. It will switch the contract to a simpler fallback mode, which hopefully works when full mode doesn't. Not every contract needs to support fallback mode (<code>FtsoManager</code> does), so this method may be empty. Switching back to normal mode is left to the contract (typically a governed method call). This function may be called due to low-gas error, so it shouldn't use more than ~30.000 gas.</p> Returns Type Description [0] <code>bool</code> True if switched to fallback mode, false if already in fallback mode or if fallback mode is not supported."},{"location":"apis/smart-contracts/IFtso/","title":"IFtso","text":""},{"location":"apis/smart-contracts/IFtso/#ct_iftso","title":"<code>IFtso</code>","text":"<p>Source</p> <p>Interface for each of the FTSO contracts that handles an asset. Read the FTSO documentation page for general information about the FTSO system.</p>"},{"location":"apis/smart-contracts/IFtso/#enums","title":"Enums","text":""},{"location":"apis/smart-contracts/IFtso/#en_pricefinalizationtype","title":"<code>PriceFinalizationType</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>enum PriceFinalizationType {\n  NOT_FINALIZED,\n  WEIGHTED_MEDIAN,\n  TRUSTED_ADDRESSES,\n  PREVIOUS_PRICE_COPIED,\n  TRUSTED_ADDRESSES_EXCEPTION,\n  PREVIOUS_PRICE_COPIED_EXCEPTION\n}\n</code></pre> <p>How did a price epoch finalize.</p> <ul> <li><code>NOT_FINALIZED</code>: The epoch has not been finalized yet. This is the initial state.</li> <li><code>WEIGHTED_MEDIAN</code>: The median was used to calculate the final price.     This is the most common state in normal operation.</li> <li><code>TRUSTED_ADDRESSES</code>: Due to low turnout, the final price was calculated using only     the median of trusted addresses.</li> <li><code>PREVIOUS_PRICE_COPIED</code>: Due to low turnout and absence of votes from trusted addresses,     the final price was copied from the previous epoch.</li> <li><code>TRUSTED_ADDRESSES_EXCEPTION</code>: Due to an exception, the final price was calculated     using only the median of trusted addresses.</li> <li><code>PREVIOUS_PRICE_COPIED_EXCEPTION</code>: Due to an exception, the final price was copied     from the previous epoch.</li> </ul>"},{"location":"apis/smart-contracts/IFtso/#events","title":"Events","text":""},{"location":"apis/smart-contracts/IFtso/#ev_lowturnout","title":"<code>LowTurnout</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>event LowTurnout(\n    uint256 epochId,\n    uint256 natTurnout,\n    uint256 lowNatTurnoutThresholdBIPS,\n    uint256 timestamp\n)\n</code></pre> <p>Not enough votes were received for this asset during a price epoch that has just ended.</p> Parameters Type Description <code>epochId</code> <code>uint256</code> The ID of the epoch. <code>natTurnout</code> <code>uint256</code> Total received vote power, as a percentage of the circulating supply in BIPS. <code>lowNatTurnoutThresholdBIPS</code> <code>uint256</code> Minimum required vote power, as a percentage of the circulating supply in BIPS. The fact that this number is higher than <code>natTurnout</code> is what triggered this event. <code>timestamp</code> <code>uint256</code> Timestamp of the block where the price epoch ended."},{"location":"apis/smart-contracts/IFtso/#ev_priceepochinitializedonftso","title":"<code>PriceEpochInitializedOnFtso</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>event PriceEpochInitializedOnFtso(\n    uint256 epochId,\n    uint256 endTime,\n    uint256 timestamp\n)\n</code></pre> <p>All necessary parameters have been set for an epoch and prices can start being revealed. Note that prices can already be submitted immediately after the previous price epoch submit end time is over.</p> <p>This event is not emitted in fallback mode (see <code>getPriceEpochData</code>).</p> Parameters Type Description <code>epochId</code> <code>uint256</code> The ID of the epoch that has just started. <code>endTime</code> <code>uint256</code> Deadline to submit prices, in seconds since UNIX epoch. <code>timestamp</code> <code>uint256</code> Current on-chain timestamp."},{"location":"apis/smart-contracts/IFtso/#ev_pricefinalized","title":"<code>PriceFinalized</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>event PriceFinalized(\n    uint256 epochId,\n    uint256 price,\n    bool rewardedFtso,\n    uint256 lowIQRRewardPrice,\n    uint256 highIQRRewardPrice,\n    uint256 lowElasticBandRewardPrice,\n    uint256 highElasticBandRewardPrice,\n    enum IFtso.PriceFinalizationType finalizationType,\n    uint256 timestamp\n)\n</code></pre> <p>An epoch has ended and the asset price is available.</p> Parameters Type Description <code>epochId</code> <code>uint256</code> The ID of the epoch that has just ended. <code>price</code> <code>uint256</code> The asset's price for that epoch. <code>rewardedFtso</code> <code>bool</code> Whether the next 4 parameters contain data. <code>lowIQRRewardPrice</code> <code>uint256</code> Lowest price in the primary (inter-quartile) reward band. <code>highIQRRewardPrice</code> <code>uint256</code> Highest price in the primary (inter-quartile) reward band. <code>lowElasticBandRewardPrice</code> <code>uint256</code> Lowest price in the secondary (elastic) reward band. <code>highElasticBandRewardPrice</code> <code>uint256</code> Highest price in the secondary (elastic) reward band. <code>finalizationType</code> <code>enum IFtso.PriceFinalizationType</code> Reason for the finalization of the epoch. <code>timestamp</code> <code>uint256</code> Timestamp of the block where the price has been finalized."},{"location":"apis/smart-contracts/IFtso/#ev_pricerevealed","title":"<code>PriceRevealed</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>event PriceRevealed(\n    address voter,\n    uint256 epochId,\n    uint256 price,\n    uint256 timestamp,\n    uint256 votePowerNat,\n    uint256 votePowerAsset\n)\n</code></pre> <p>A voter has revealed its price.</p> Parameters Type Description <code>voter</code> <code>address</code> The voter. <code>epochId</code> <code>uint256</code> The ID of the epoch for which the price has been revealed. <code>price</code> <code>uint256</code> The revealed price. <code>timestamp</code> <code>uint256</code> Timestamp of the block where the reveal happened. <code>votePowerNat</code> <code>uint256</code> Vote power of the voter in this epoch. This includes the vote power derived from its <code>WNat</code> holdings and the delegations. <code>votePowerAsset</code> <code>uint256</code> Unused."},{"location":"apis/smart-contracts/IFtso/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IFtso/#fn_active_02fb0c5e","title":"<code>active</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function active(\n) external view returns (\n    bool);\n</code></pre> <p>Returns whether FTSO is <code>active</code> or not.</p>"},{"location":"apis/smart-contracts/IFtso/#fn_getcurrentepochid_a29a839f","title":"<code>getCurrentEpochId</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getCurrentEpochId(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the current epoch ID.</p> Returns Type Description [0] <code>uint256</code> Currently running epoch ID. IDs are consecutive numbers starting from zero."},{"location":"apis/smart-contracts/IFtso/#fn_getcurrentprice_eb91d37e","title":"<code>getCurrentPrice</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getCurrentPrice(\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp);\n</code></pre> <p>Returns the current asset price.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Time when price was updated for the last time, in seconds from UNIX epoch."},{"location":"apis/smart-contracts/IFtso/#fn_getcurrentpricedetails_040d73b8","title":"<code>getCurrentPriceDetails</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getCurrentPriceDetails(\n) external view returns (\n    uint256 _price,\n    uint256 _priceTimestamp,\n    enum IFtso.PriceFinalizationType _priceFinalizationType,\n    uint256 _lastPriceEpochFinalizationTimestamp,\n    enum IFtso.PriceFinalizationType _lastPriceEpochFinalizationType);\n</code></pre> <p>Returns asset's current price details. All timestamps are in seconds from UNIX epoch.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_priceTimestamp</code> <code>uint256</code> Time when price was updated for the last time. <code>_priceFinalizationType</code> <code>enum IFtso.PriceFinalizationType</code> Finalization type when price was updated for the last time. <code>_lastPriceEpochFinalizationTimestamp</code> <code>uint256</code> Time when last price epoch was finalized. <code>_lastPriceEpochFinalizationType</code> <code>enum IFtso.PriceFinalizationType</code> Finalization type of last finalized price epoch."},{"location":"apis/smart-contracts/IFtso/#fn_getcurrentpricefromtrustedproviders_af52df08","title":"<code>getCurrentPriceFromTrustedProviders</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getCurrentPriceFromTrustedProviders(\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp);\n</code></pre> <p>Returns current asset price calculated only using input from trusted providers.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Time when price was updated for the last time, in seconds from UNIX epoch."},{"location":"apis/smart-contracts/IFtso/#fn_getcurrentpricewithdecimals_65f5cd86","title":"<code>getCurrentPriceWithDecimals</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getCurrentPriceWithDecimals(\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals);\n</code></pre> <p>Returns current asset price and number of decimals.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>_assetPriceUsdDecimals</code>. <code>_timestamp</code> <code>uint256</code> Time when price was updated for the last time, in seconds from UNIX epoch. <code>_assetPriceUsdDecimals</code> <code>uint256</code> Number of decimals used to return the USD price."},{"location":"apis/smart-contracts/IFtso/#fn_getcurrentpricewithdecimalsfromtrustedproviders_3cacb3ae","title":"<code>getCurrentPriceWithDecimalsFromTrustedProviders</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getCurrentPriceWithDecimalsFromTrustedProviders(\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals);\n</code></pre> <p>Returns current asset price calculated only using input from trusted providers and number of decimals.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Time when price was updated for the last time, in seconds from UNIX epoch. <code>_assetPriceUsdDecimals</code> <code>uint256</code> Number of decimals used to return the USD price."},{"location":"apis/smart-contracts/IFtso/#fn_getcurrentrandom_d89601fd","title":"<code>getCurrentRandom</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getCurrentRandom(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the random number for the previous price epoch, obtained from the random numbers provided by all data providers along with their data submissions.</p>"},{"location":"apis/smart-contracts/IFtso/#fn_getepochid_5303548b","title":"<code>getEpochId</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getEpochId(\n    uint256 _timestamp\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the ID of the epoch that was opened for price submission at the specified timestamp.</p> Parameters Type Description <code>_timestamp</code> <code>uint256</code> Queried timestamp in seconds from UNIX epoch. Returns Type Description [0] <code>uint256</code> Epoch ID corresponding to that timestamp. IDs are consecutive numbers starting from zero."},{"location":"apis/smart-contracts/IFtso/#fn_getepochprice_7d1d6f12","title":"<code>getEpochPrice</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getEpochPrice(\n    uint256 _epochId\n) external view returns (\n    uint256);\n</code></pre> <p>Returns agreed asset price in the specified epoch.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch. Only the last 200 epochs can be queried. Out-of-bounds queries revert. Returns Type Description [0] <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>."},{"location":"apis/smart-contracts/IFtso/#fn_getepochpriceforvoter_c5d8b9e7","title":"<code>getEpochPriceForVoter</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getEpochPriceForVoter(\n    uint256 _epochId,\n    address _voter\n) external view returns (\n    uint256);\n</code></pre> <p>Returns asset price submitted by a voter in the specified epoch.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch being queried. Only the last 200 epochs can be queried. Out-of-bounds queries revert. <code>_voter</code> <code>address</code> Address of the voter being queried. Returns Type Description [0] <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>."},{"location":"apis/smart-contracts/IFtso/#fn_getpriceepochconfiguration_144e1591","title":"<code>getPriceEpochConfiguration</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getPriceEpochConfiguration(\n) external view returns (\n    uint256 _firstEpochStartTs,\n    uint256 _submitPeriodSeconds,\n    uint256 _revealPeriodSeconds);\n</code></pre> <p>Returns current epoch's configuration.</p> Returns Type Description <code>_firstEpochStartTs</code> <code>uint256</code> First epoch start timestamp in seconds from UNIX epoch. <code>_submitPeriodSeconds</code> <code>uint256</code> Submit period in seconds. <code>_revealPeriodSeconds</code> <code>uint256</code> Reveal period in seconds."},{"location":"apis/smart-contracts/IFtso/#fn_getpriceepochdata_e3b3a3b3","title":"<code>getPriceEpochData</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getPriceEpochData(\n) external view returns (\n    uint256 _epochId,\n    uint256 _epochSubmitEndTime,\n    uint256 _epochRevealEndTime,\n    uint256 _votePowerBlock,\n    bool _fallbackMode);\n</code></pre> <p>Returns current epoch data. Intervals are open on the right: End times are not included.</p> Returns Type Description <code>_epochId</code> <code>uint256</code> Current epoch ID. <code>_epochSubmitEndTime</code> <code>uint256</code> End time of the price submission window in seconds from UNIX epoch. <code>_epochRevealEndTime</code> <code>uint256</code> End time of the price reveal window in seconds from UNIX epoch. <code>_votePowerBlock</code> <code>uint256</code> Vote power block for the current epoch. <code>_fallbackMode</code> <code>bool</code> Whether the current epoch is in fallback mode. Only votes from trusted addresses are used in this mode."},{"location":"apis/smart-contracts/IFtso/#fn_getrandom_cd4b6914","title":"<code>getRandom</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getRandom(\n    uint256 _epochId\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the random number used in a specific past epoch, obtained from the random numbers provided by all data providers along with their data submissions.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the queried epoch. Current epoch cannot be queried, and the previous epoch is constantly updated as data providers reveal their prices and random numbers. Only the last 50 epochs can be queried and there is no bounds checking for this parameter. Out-of-bounds queries return undefined values. Returns Type Description [0] <code>uint256</code> The random number used in that epoch."},{"location":"apis/smart-contracts/IFtso/#fn_symbol_95d89b41","title":"<code>symbol</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function symbol(\n) external view returns (\n    string);\n</code></pre> <p>Returns the FTSO <code>symbol</code>.</p>"},{"location":"apis/smart-contracts/IFtsoGenesis/","title":"IFtsoGenesis","text":""},{"location":"apis/smart-contracts/IFtsoGenesis/#ct_iftsogenesis","title":"<code>IFtsoGenesis</code>","text":"<p>Source</p> <p>Portion of the <code>IFtso</code> interface that is available to contracts deployed at genesis.</p>"},{"location":"apis/smart-contracts/IFtsoGenesis/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IFtsoGenesis/#fn_revealpricesubmitter_c1f6c36e","title":"<code>revealPriceSubmitter</code>","text":"<p>Defined in <code>IFtsoGenesis</code> (Docs, Source).</p> <pre><code>function revealPriceSubmitter(\n    address _voter,\n    uint256 _epochId,\n    uint256 _price,\n    uint256 _voterWNatVP\n) external;\n</code></pre> <p>Reveals the price submitted by a voter on a specific epoch. The hash of _price and _random must be equal to the submitted hash</p> Parameters Type Description <code>_voter</code> <code>address</code> Voter address. <code>_epochId</code> <code>uint256</code> ID of the epoch in which the price hash was submitted. <code>_price</code> <code>uint256</code> Submitted price. <code>_voterWNatVP</code> <code>uint256</code> Voter's vote power in <code>WNat</code> units."},{"location":"apis/smart-contracts/IFtsoGenesis/#fn_wnatvotepowercached_f72cab28","title":"<code>wNatVotePowerCached</code>","text":"<p>Defined in <code>IFtsoGenesis</code> (Docs, Source).</p> <pre><code>function wNatVotePowerCached(\n    address _voter,\n    uint256 _epochId\n) external returns (\n    uint256);\n</code></pre> <p>Get and cache the vote power of a voter on a specific epoch, in <code>WNat</code> units.</p> Parameters Type Description <code>_voter</code> <code>address</code> Voter address. <code>_epochId</code> <code>uint256</code> ID of the epoch in which the price hash was submitted. Returns Type Description [0] <code>uint256</code> Voter's vote power in <code>WNat</code> units."},{"location":"apis/smart-contracts/IFtsoManager/","title":"IFtsoManager","text":""},{"location":"apis/smart-contracts/IFtsoManager/#ct_iftsomanager","title":"<code>IFtsoManager</code>","text":"<p>Source | Inherits from IFtsoManagerGenesis</p> <p>Interface for the <code>FtsoManager</code> contract.</p>"},{"location":"apis/smart-contracts/IFtsoManager/#events","title":"Events","text":""},{"location":"apis/smart-contracts/IFtsoManager/#ev_accruingunearnedrewardsfailed","title":"<code>AccruingUnearnedRewardsFailed</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event AccruingUnearnedRewardsFailed(\n    uint256 epochId\n)\n</code></pre> <p>Unexpected failure while accruing unearned rewards. This should be a rare occurrence.</p> Parameters Type Description <code>epochId</code> <code>uint256</code> Epoch ID of the failure."},{"location":"apis/smart-contracts/IFtsoManager/#ev_distributingrewardsfailed","title":"<code>DistributingRewardsFailed</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event DistributingRewardsFailed(\n    address ftso,\n    uint256 epochId\n)\n</code></pre> <p>Unexpected failure while distributing rewards. This should be a rare occurrence.</p> Parameters Type Description <code>ftso</code> <code>address</code> Contract address of the FTSO where the failure happened. <code>epochId</code> <code>uint256</code> Epoch ID of the failure."},{"location":"apis/smart-contracts/IFtsoManager/#ev_fallbackmode","title":"<code>FallbackMode</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event FallbackMode(\n    bool fallbackMode\n)\n</code></pre> <p>Emitted when the fallback mode of the FTSO manager changes its state. Fallback mode is a recovery mode, where only data from a trusted subset of FTSO data providers is used to calculate the final price.</p> <p>The FTSO Manager enters the fallback mode when ALL FTSOs are in fallback mode.</p> Parameters Type Description <code>fallbackMode</code> <code>bool</code> New state of the FTSO Manager fallback mode."},{"location":"apis/smart-contracts/IFtsoManager/#ev_finalizingpriceepochfailed","title":"<code>FinalizingPriceEpochFailed</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event FinalizingPriceEpochFailed(\n    contract IIFtso ftso,\n    uint256 epochId,\n    enum IFtso.PriceFinalizationType failingType\n)\n</code></pre> <p>Unexpected failure while finalizing a price epoch. This should be a rare occurrence.</p> Parameters Type Description <code>ftso</code> <code>contract IIFtso</code> Contract address of the FTSO where the failure happened. <code>epochId</code> <code>uint256</code> Epoch ID of the failure. <code>failingType</code> <code>enum IFtso.PriceFinalizationType</code> How was the epoch finalized."},{"location":"apis/smart-contracts/IFtsoManager/#ev_ftsoadded","title":"<code>FtsoAdded</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event FtsoAdded(\n    contract IIFtso ftso,\n    bool add\n)\n</code></pre> <p>Emitted when a new FTSO has been added or an existing one has been removed.</p> Parameters Type Description <code>ftso</code> <code>contract IIFtso</code> Contract address of the FTSO. <code>add</code> <code>bool</code> True if added, removed otherwise."},{"location":"apis/smart-contracts/IFtsoManager/#ev_ftsofallbackmode","title":"<code>FtsoFallbackMode</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event FtsoFallbackMode(\n    contract IIFtso ftso,\n    bool fallbackMode\n)\n</code></pre> <p>Emitted when the fallback mode of an FTSO changes its state.</p> Parameters Type Description <code>ftso</code> <code>contract IIFtso</code> Contract address of the FTSO. <code>fallbackMode</code> <code>bool</code> New state of its fallback mode."},{"location":"apis/smart-contracts/IFtsoManager/#ev_initializingcurrentepochstateforrevealfailed","title":"<code>InitializingCurrentEpochStateForRevealFailed</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event InitializingCurrentEpochStateForRevealFailed(\n    contract IIFtso ftso,\n    uint256 epochId\n)\n</code></pre> <p>Unexpected failure while initializing a price epoch. This should be a rare occurrence.</p> Parameters Type Description <code>ftso</code> <code>contract IIFtso</code> Contract address of the FTSO where the failure happened. <code>epochId</code> <code>uint256</code> Epoch ID that failed initialization."},{"location":"apis/smart-contracts/IFtsoManager/#ev_priceepochfinalized","title":"<code>PriceEpochFinalized</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event PriceEpochFinalized(\n    address chosenFtso,\n    uint256 rewardEpochId\n)\n</code></pre> <p>Emitted when a price epoch ends, this is, after the reveal phase, when final prices are calculated.</p> Parameters Type Description <code>chosenFtso</code> <code>address</code> Contract address of the FTSO asset that was randomly chosen to be the basis for reward calculation. On this price epoch, rewards will be calculated based on how close each data provider was to the median of all submitted prices FOR THIS FTSO. <code>rewardEpochId</code> <code>uint256</code> Reward epoch ID this price epoch belongs to."},{"location":"apis/smart-contracts/IFtsoManager/#ev_rewardepochfinalized","title":"<code>RewardEpochFinalized</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event RewardEpochFinalized(\n    uint256 votepowerBlock,\n    uint256 startBlock\n)\n</code></pre> <p>Emitted when a reward epoch ends and rewards are available.</p> Parameters Type Description <code>votepowerBlock</code> <code>uint256</code> The vote power block of the epoch. <code>startBlock</code> <code>uint256</code> The first block of the epoch."},{"location":"apis/smart-contracts/IFtsoManager/#ev_usegoodrandomset","title":"<code>UseGoodRandomSet</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event UseGoodRandomSet(\n    bool useGoodRandom,\n    uint256 maxWaitForGoodRandomSeconds\n)\n</code></pre> <p>Emitted when the requirement to provide good random numbers has changed.</p> <p>As part of the FTSO protocol, data providers must submit a random number along with their price reveals. When good random numbers are enforced, all providers that submit a hash must then submit a reveal with a random number or they will be punished. This is a measure against random number manipulation.</p> Parameters Type Description <code>useGoodRandom</code> <code>bool</code> Whether good random numbers are now enforced or not. <code>maxWaitForGoodRandomSeconds</code> <code>uint256</code> Max number of seconds to wait for a good random number to be submitted."},{"location":"apis/smart-contracts/IFtsoManager/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IFtsoManager/#fn_active_02fb0c5e","title":"<code>active</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function active(\n) external view returns (\n    bool);\n</code></pre> <p>Returns whether the FTSO Manager is <code>active</code> or not.</p> Returns Type Description [0] <code>bool</code> bool Active status."},{"location":"apis/smart-contracts/IFtsoManager/#fn_getcurrentpriceepochdata_93a79025","title":"<code>getCurrentPriceEpochData</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getCurrentPriceEpochData(\n) external view returns (\n    uint256 _priceEpochId,\n    uint256 _priceEpochStartTimestamp,\n    uint256 _priceEpochEndTimestamp,\n    uint256 _priceEpochRevealEndTimestamp,\n    uint256 _currentTimestamp);\n</code></pre> <p>Returns timing information for the current price epoch. All intervals are half-closed: end time is not included. All timestamps are in seconds since UNIX epoch.</p> <p>See the FTSO page for information about the different submission phases.</p> Returns Type Description <code>_priceEpochId</code> <code>uint256</code> Price epoch ID. <code>_priceEpochStartTimestamp</code> <code>uint256</code> Beginning of the commit phase. <code>_priceEpochEndTimestamp</code> <code>uint256</code> End of the commit phase. <code>_priceEpochRevealEndTimestamp</code> <code>uint256</code> End of the reveal phase. <code>_currentTimestamp</code> <code>uint256</code> Current time."},{"location":"apis/smart-contracts/IFtsoManager/#fn_getcurrentpriceepochid_08a7f402","title":"<code>getCurrentPriceEpochId</code>","text":"<p>Defined in <code>IFtsoManagerGenesis</code> (Docs, Source).</p> <pre><code>function getCurrentPriceEpochId(\n) external view returns (\n    uint256 _priceEpochId);\n</code></pre> <p>Returns current price epoch ID.</p> Returns Type Description <code>_priceEpochId</code> <code>uint256</code> Currently running epoch ID. IDs are consecutive numbers starting from zero."},{"location":"apis/smart-contracts/IFtsoManager/#fn_getcurrentrewardepoch_e7c830d4","title":"<code>getCurrentRewardEpoch</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getCurrentRewardEpoch(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns current reward epoch ID (the one currently running).</p> Returns Type Description [0] <code>uint256</code> Reward epoch ID. A monotonically increasing integer."},{"location":"apis/smart-contracts/IFtsoManager/#fn_getfallbackmode_4b48dd5e","title":"<code>getFallbackMode</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getFallbackMode(\n) external view returns (\n    bool _fallbackMode,\n    contract IIFtso[] _ftsos,\n    bool[] _ftsoInFallbackMode);\n</code></pre> <p>Returns whether the FTSO Manager is currently in fallback mode.</p> <p>In this mode only submissions from trusted providers are used.</p> Returns Type Description <code>_fallbackMode</code> <code>bool</code> True if fallback mode is enabled for the manager. <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all currently active FTSO assets. <code>_ftsoInFallbackMode</code> <code>bool[]</code> Boolean array indicating which FTSO assets are in fallback mode. If the FTSO Manager is in fallback mode then ALL FTSOs are in fallback mode."},{"location":"apis/smart-contracts/IFtsoManager/#fn_getftsos_ce69f833","title":"<code>getFtsos</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getFtsos(\n) external view returns (\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Returns the list of currently <code>active</code> FTSOs.</p> Returns Type Description <code>_ftsos</code> <code>contract IIFtso[]</code> Array of contract addresses for the FTSOs."},{"location":"apis/smart-contracts/IFtsoManager/#fn_getpriceepochconfiguration_144e1591","title":"<code>getPriceEpochConfiguration</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getPriceEpochConfiguration(\n) external view returns (\n    uint256 _firstPriceEpochStartTs,\n    uint256 _priceEpochDurationSeconds,\n    uint256 _revealEpochDurationSeconds);\n</code></pre> <p>Returns the current values for price epoch timing configuration.</p> <p>See the FTSO page for information about the different submission phases.</p> Returns Type Description <code>_firstPriceEpochStartTs</code> <code>uint256</code> Timestamp, in seconds since UNIX epoch, of the first price epoch. <code>_priceEpochDurationSeconds</code> <code>uint256</code> Duration in seconds of the commit phase. <code>_revealEpochDurationSeconds</code> <code>uint256</code> Duration in seconds of the reveal phase."},{"location":"apis/smart-contracts/IFtsoManager/#fn_getrewardepochconfiguration_1cb513f7","title":"<code>getRewardEpochConfiguration</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochConfiguration(\n) external view returns (\n    uint256 _firstRewardEpochStartTs,\n    uint256 _rewardEpochDurationSeconds);\n</code></pre> <p>Returns the current values for reward epoch timing configuration.</p> <p>See the Reward epochs box.</p> Returns Type Description <code>_firstRewardEpochStartTs</code> <code>uint256</code> Timestamp, in seconds since UNIX epoch, of the first reward epoch. <code>_rewardEpochDurationSeconds</code> <code>uint256</code> Duration in seconds of the reward epochs."},{"location":"apis/smart-contracts/IFtsoManager/#fn_getrewardepochtoexpirenext_3e7ff857","title":"<code>getRewardEpochToExpireNext</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochToExpireNext(\n) external view returns (\n    uint256);\n</code></pre> <p>Return reward epoch that will expire next, when a new reward epoch is initialized.</p> <p>Reward epochs older than 90 days expire, and any unclaimed rewards in them become inaccessible.</p> Returns Type Description [0] <code>uint256</code> uint256 Reward epoch ID."},{"location":"apis/smart-contracts/IFtsoManager/#fn_getrewardepochvotepowerblock_f2edab5a","title":"<code>getRewardEpochVotePowerBlock</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochVotePowerBlock(\n    uint256 _rewardEpoch\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the vote power block that was used for a past reward epoch.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> The queried reward epoch ID. Returns Type Description [0] <code>uint256</code> uint256 The block number of that reward epoch's vote power block."},{"location":"apis/smart-contracts/IFtsoManagerGenesis/","title":"IFtsoManagerGenesis","text":""},{"location":"apis/smart-contracts/IFtsoManagerGenesis/#ct_iftsomanagergenesis","title":"<code>IFtsoManagerGenesis</code>","text":"<p>Source</p> <p>Portion of the <code>IFtsoManager</code> interface that is available to contracts deployed at genesis.</p>"},{"location":"apis/smart-contracts/IFtsoManagerGenesis/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IFtsoManagerGenesis/#fn_getcurrentpriceepochid_08a7f402","title":"<code>getCurrentPriceEpochId</code>","text":"<p>Defined in <code>IFtsoManagerGenesis</code> (Docs, Source).</p> <pre><code>function getCurrentPriceEpochId(\n) external view returns (\n    uint256 _priceEpochId);\n</code></pre> <p>Returns current price epoch ID.</p> Returns Type Description <code>_priceEpochId</code> <code>uint256</code> Currently running epoch ID. IDs are consecutive numbers starting from zero."},{"location":"apis/smart-contracts/IFtsoRegistry/","title":"IFtsoRegistry","text":""},{"location":"apis/smart-contracts/IFtsoRegistry/#ct_iftsoregistry","title":"<code>IFtsoRegistry</code>","text":"<p>Source | Inherits from IFtsoRegistryGenesis</p> <p>Interface for the <code>FtsoRegistry</code> contract.</p>"},{"location":"apis/smart-contracts/IFtsoRegistry/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getallcurrentprices_58f9296f","title":"<code>getAllCurrentPrices</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getAllCurrentPrices(\n) external view returns (\n    struct IFtsoRegistry.PriceInfo[]);\n</code></pre> <p>Returns the current price of all supported assets.</p> Returns Type Description [0] <code>struct IFtsoRegistry.PriceInfo[]</code> Array of <code>PriceInfo</code> structures."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getcurrentprice_c55d0f56","title":"<code>getCurrentPrice</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPrice(\n    uint256 _ftsoIndex\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp);\n</code></pre> <p>Public view function to get the current price of a given active FTSO index. Reverts if the index is not supported.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Index to query. Returns Type Description <code>_price</code> <code>uint256</code> Current price of the asset in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Timestamp for when this price was updated, in seconds since UNIX epoch."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getcurrentprice_42a0f243","title":"<code>getCurrentPrice</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPrice(\n    string _symbol\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp);\n</code></pre> <p>Public view function to get the current price of a given active asset symbol. Reverts if the symbol is not supported.</p> Parameters Type Description <code>_symbol</code> <code>string</code> Symbol to query. Returns Type Description <code>_price</code> <code>uint256</code> Current price of the asset in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Timestamp for when this price was updated, in seconds since UNIX epoch."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getcurrentpricewithdecimals_257cbd3a","title":"<code>getCurrentPriceWithDecimals</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPriceWithDecimals(\n    uint256 _assetIndex\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals);\n</code></pre> <p>Public view function to get the current price and decimals of a given active FTSO index. Reverts if the index is not supported.</p> Parameters Type Description <code>_assetIndex</code> <code>uint256</code> Index to query. Returns Type Description <code>_price</code> <code>uint256</code> Current price of the asset in USD multiplied by 10^<code>_assetPriceUsdDecimals</code>. <code>_timestamp</code> <code>uint256</code> Timestamp for when this price was updated, in seconds since UNIX epoch. <code>_assetPriceUsdDecimals</code> <code>uint256</code> Number of decimals used to return the <code>_price</code>."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getcurrentpricewithdecimals_a69afdc6","title":"<code>getCurrentPriceWithDecimals</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPriceWithDecimals(\n    string _symbol\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals);\n</code></pre> <p>Public view function to get the current price and decimals of a given active asset symbol. Reverts if the symbol is not supported.</p> Parameters Type Description <code>_symbol</code> <code>string</code> Symbol to query. Returns Type Description <code>_price</code> <code>uint256</code> Current price of the asset in USD multiplied by 10^<code>_assetPriceUsdDecimals</code>. <code>_timestamp</code> <code>uint256</code> Timestamp for when this price was updated, in seconds since UNIX epoch. <code>_assetPriceUsdDecimals</code> <code>uint256</code> Number of decimals used to return the <code>_price</code>."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getcurrentpricesbyindices_6ba31fa1","title":"<code>getCurrentPricesByIndices</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPricesByIndices(\n    uint256[] _indices\n) external view returns (\n    struct IFtsoRegistry.PriceInfo[]);\n</code></pre> <p>Returns the current price of a list of indices. Reverts if any of the indices is not supported.</p> Parameters Type Description <code>_indices</code> <code>uint256[]</code> Array of indices to query. Returns Type Description [0] <code>struct IFtsoRegistry.PriceInfo[]</code> Array of <code>PriceInfo</code> structures."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getcurrentpricesbysymbols_79d5ea4b","title":"<code>getCurrentPricesBySymbols</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPricesBySymbols(\n    string[] _symbols\n) external view returns (\n    struct IFtsoRegistry.PriceInfo[]);\n</code></pre> <p>Returns the current price of a list of asset symbols. Reverts if any of the symbols is not supported.</p> Parameters Type Description <code>_symbols</code> <code>string[]</code> Array of symbols to query. Returns Type Description [0] <code>struct IFtsoRegistry.PriceInfo[]</code> Array of <code>PriceInfo</code> structures."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getftso_d75f6d81","title":"<code>getFtso</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getFtso(\n    uint256 _activeFtso\n) external view returns (\n    contract IIFtso _activeFtsoAddress);\n</code></pre> <p>Returns the address of the FTSO contract for a given index. Reverts if unsupported index is passed.</p> Parameters Type Description <code>_activeFtso</code> <code>uint256</code> The queried index. Returns Type Description <code>_activeFtsoAddress</code> <code>contract IIFtso</code> FTSO contract address for the queried index."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getftsobysymbol_97da6af4","title":"<code>getFtsoBySymbol</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getFtsoBySymbol(\n    string _symbol\n) external view returns (\n    contract IIFtso _activeFtsoAddress);\n</code></pre> <p>Returns the address of the FTSO contract for a given symbol. Reverts if unsupported symbol is passed.</p> Parameters Type Description <code>_symbol</code> <code>string</code> The queried symbol. Returns Type Description <code>_activeFtsoAddress</code> <code>contract IIFtso</code> FTSO contract address for the queried symbol."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getftsoindex_e848da30","title":"<code>getFtsoIndex</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getFtsoIndex(\n    string _symbol\n) external view returns (\n    uint256 _assetIndex);\n</code></pre> <p>Returns the FTSO index corresponding to a given asset symbol. Reverts if the symbol is not supported.</p> Parameters Type Description <code>_symbol</code> <code>string</code> Symbol to query. Returns Type Description <code>_assetIndex</code> <code>uint256</code> The corresponding asset index."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getftsosymbol_136d3f64","title":"<code>getFtsoSymbol</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getFtsoSymbol(\n    uint256 _ftsoIndex\n) external view returns (\n    string _symbol);\n</code></pre> <p>Returns the asset symbol corresponding to a given FTSO index. Reverts if the index is not supported.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Index to query. Returns Type Description <code>_symbol</code> <code>string</code> The corresponding asset symbol."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getftsos_9cb47538","title":"<code>getFtsos</code>","text":"<p>Defined in <code>IFtsoRegistryGenesis</code> (Docs, Source).</p> <pre><code>function getFtsos(\n    uint256[] _indices\n) external view returns (\n    contract IFtsoGenesis[] _ftsos);\n</code></pre> <p>Get the addresses of the active FTSOs at the given indices. Reverts if any of the provided indices is non-existing or inactive.</p> Parameters Type Description <code>_indices</code> <code>uint256[]</code> Array of FTSO indices to query. Returns Type Description <code>_ftsos</code> <code>contract IFtsoGenesis[]</code> The array of FTSO addresses."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getsupportedftsos_a40060ba","title":"<code>getSupportedFtsos</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedFtsos(\n) external view returns (\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Get array of all FTSO contracts for all supported asset indices. The index of FTSO in returned array does not necessarily correspond to the asset's index. Due to deletion, some indices might be unsupported.</p> <p>Use <code>getSupportedIndicesAndFtsos</code> to retrieve pairs of correct indices and FTSOs, where possible \"null\" holes are readily apparent.</p> Returns Type Description <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all supported FTSOs."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getsupportedindices_798aac5b","title":"<code>getSupportedIndices</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedIndices(\n) external view returns (\n    uint256[] _supportedIndices);\n</code></pre> <p>Returns the indices of the currently supported FTSOs. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of all active FTSO indices in increasing order."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getsupportedindicesandftsos_06a2ba29","title":"<code>getSupportedIndicesAndFtsos</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedIndicesAndFtsos(\n) external view returns (\n    uint256[] _supportedIndices,\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Get all supported indices and corresponding FTSO addresses. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of all supported indices. <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all supported FTSO addresses."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getsupportedindicesandsymbols_e68f283b","title":"<code>getSupportedIndicesAndSymbols</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedIndicesAndSymbols(\n) external view returns (\n    uint256[] _supportedIndices,\n    string[] _supportedSymbols);\n</code></pre> <p>Get all supported indices and corresponding symbols. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of all supported indices. <code>_supportedSymbols</code> <code>string[]</code> Array of all supported symbols."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getsupportedindicessymbolsandftsos_7687542c","title":"<code>getSupportedIndicesSymbolsAndFtsos</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedIndicesSymbolsAndFtsos(\n) external view returns (\n    uint256[] _supportedIndices,\n    string[] _supportedSymbols,\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Get all supported indices, symbols, and corresponding FTSO addresses. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of all supported indices. <code>_supportedSymbols</code> <code>string[]</code> Array of all supported symbols. <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all supported FTSO addresses."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getsupportedsymbols_ce1c0e4d","title":"<code>getSupportedSymbols</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedSymbols(\n) external view returns (\n    string[] _supportedSymbols);\n</code></pre> <p>Returns the symbols of the currently supported FTSOs. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedSymbols</code> <code>string[]</code> Array of all active FTSO symbols in increasing order."},{"location":"apis/smart-contracts/IFtsoRegistry/#fn_getsupportedsymbolsandftsos_0cf48497","title":"<code>getSupportedSymbolsAndFtsos</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedSymbolsAndFtsos(\n) external view returns (\n    string[] _supportedSymbols,\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Get all supported symbols and corresponding FTSO addresses. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedSymbols</code> <code>string[]</code> Array of all supported symbols. <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all supported FTSO addresses."},{"location":"apis/smart-contracts/IFtsoRegistry/#structures","title":"Structures","text":""},{"location":"apis/smart-contracts/IFtsoRegistry/#st_priceinfo","title":"<code>PriceInfo</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>struct PriceInfo {\n  uint256 ftsoIndex;\n  uint256 price;\n  uint256 decimals;\n  uint256 timestamp;\n}\n</code></pre>"},{"location":"apis/smart-contracts/IFtsoRegistryGenesis/","title":"IFtsoRegistryGenesis","text":""},{"location":"apis/smart-contracts/IFtsoRegistryGenesis/#ct_iftsoregistrygenesis","title":"<code>IFtsoRegistryGenesis</code>","text":"<p>Source</p> <p>Portion of the <code>IFtsoRegistry</code> interface that is available to contracts deployed at genesis.</p>"},{"location":"apis/smart-contracts/IFtsoRegistryGenesis/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IFtsoRegistryGenesis/#fn_getftsos_9cb47538","title":"<code>getFtsos</code>","text":"<p>Defined in <code>IFtsoRegistryGenesis</code> (Docs, Source).</p> <pre><code>function getFtsos(\n    uint256[] _indices\n) external view returns (\n    contract IFtsoGenesis[] _ftsos);\n</code></pre> <p>Get the addresses of the active FTSOs at the given indices. Reverts if any of the provided indices is non-existing or inactive.</p> Parameters Type Description <code>_indices</code> <code>uint256[]</code> Array of FTSO indices to query. Returns Type Description <code>_ftsos</code> <code>contract IFtsoGenesis[]</code> The array of FTSO addresses."},{"location":"apis/smart-contracts/IFtsoRewardManager/","title":"IFtsoRewardManager","text":""},{"location":"apis/smart-contracts/IFtsoRewardManager/#ct_iftsorewardmanager","title":"<code>IFtsoRewardManager</code>","text":"<p>Source</p> <p>Interface for the <code>FtsoRewardManager</code> contract.</p>"},{"location":"apis/smart-contracts/IFtsoRewardManager/#events","title":"Events","text":""},{"location":"apis/smart-contracts/IFtsoRewardManager/#ev_feepercentagechanged","title":"<code>FeePercentageChanged</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event FeePercentageChanged(\n    address dataProvider,\n    uint256 value,\n    uint256 validFromEpoch\n)\n</code></pre> <p>Emitted when a data provider changes its fee.</p> Parameters Type Description <code>dataProvider</code> <code>address</code> Address of the data provider. <code>value</code> <code>uint256</code> New fee, in BIPS. <code>validFromEpoch</code> <code>uint256</code> Epoch ID where the new fee takes effect."},{"location":"apis/smart-contracts/IFtsoRewardManager/#ev_ftsorewardmanageractivated","title":"<code>FtsoRewardManagerActivated</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event FtsoRewardManagerActivated(\n    address ftsoRewardManager\n)\n</code></pre> <p>Emitted when the reward manager contract is activated.</p> Parameters Type Description <code>ftsoRewardManager</code> <code>address</code> The reward manager contract."},{"location":"apis/smart-contracts/IFtsoRewardManager/#ev_ftsorewardmanagerdeactivated","title":"<code>FtsoRewardManagerDeactivated</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event FtsoRewardManagerDeactivated(\n    address ftsoRewardManager\n)\n</code></pre> <p>Emitted when the reward manager contract is deactivated.</p> Parameters Type Description <code>ftsoRewardManager</code> <code>address</code> The reward manager contract."},{"location":"apis/smart-contracts/IFtsoRewardManager/#ev_rewardclaimed","title":"<code>RewardClaimed</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event RewardClaimed(\n    address dataProvider,\n    address whoClaimed,\n    address sentTo,\n    uint256 rewardEpoch,\n    uint256 amount\n)\n</code></pre> <p>Emitted when a data provider claims its FTSO rewards.</p> Parameters Type Description <code>dataProvider</code> <code>address</code> Address of the data provider that accrued the reward. <code>whoClaimed</code> <code>address</code> Address that actually performed the claim. <code>sentTo</code> <code>address</code> Address that received the reward. <code>rewardEpoch</code> <code>uint256</code> ID of the reward epoch where the reward was accrued. <code>amount</code> <code>uint256</code> Amount of rewarded native tokens (wei)."},{"location":"apis/smart-contracts/IFtsoRewardManager/#ev_rewardclaimsenabled","title":"<code>RewardClaimsEnabled</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event RewardClaimsEnabled(\n    uint256 rewardEpochId\n)\n</code></pre> <p>Emitted when reward claims have been enabled.</p> Parameters Type Description <code>rewardEpochId</code> <code>uint256</code> First claimable reward epoch."},{"location":"apis/smart-contracts/IFtsoRewardManager/#ev_rewardclaimsexpired","title":"<code>RewardClaimsExpired</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event RewardClaimsExpired(\n    uint256 rewardEpochId\n)\n</code></pre> <p>Unclaimed rewards have expired and are now inaccessible.</p> <p><code>getUnclaimedReward()</code> can be used to retrieve more information.</p> Parameters Type Description <code>rewardEpochId</code> <code>uint256</code> ID of the reward epoch that has just expired."},{"location":"apis/smart-contracts/IFtsoRewardManager/#ev_rewardsdistributed","title":"<code>RewardsDistributed</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event RewardsDistributed(\n    address ftso,\n    uint256 epochId,\n    address[] addresses,\n    uint256[] rewards\n)\n</code></pre> <p>Emitted every price epoch, when rewards have been distributed to each contributing data provider. Note that rewards are not claimable until the reward epoch finishes.</p> Parameters Type Description <code>ftso</code> <code>address</code> Address of the FTSO that generated the rewards. <code>epochId</code> <code>uint256</code> ID of the reward epoch where the rewards were accrued. <code>addresses</code> <code>address[]</code> Data provider addresses that have rewards to claim. <code>rewards</code> <code>uint256[]</code> Amounts available for claiming (wei)."},{"location":"apis/smart-contracts/IFtsoRewardManager/#ev_unearnedrewardsaccrued","title":"<code>UnearnedRewardsAccrued</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event UnearnedRewardsAccrued(\n    uint256 epochId,\n    uint256 reward\n)\n</code></pre> <p>Emitted when rewards cannot be distributed during a reward epoch (for example, because the FTSO went into fallback mode) and they are accrued for later burning.</p> Parameters Type Description <code>epochId</code> <code>uint256</code> ID of the reward epoch where the reward was accrued. <code>reward</code> <code>uint256</code> Total amount of accrued rewards (wei)."},{"location":"apis/smart-contracts/IFtsoRewardManager/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_active_02fb0c5e","title":"<code>active</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function active(\n) external view returns (\n    bool);\n</code></pre> <p>Whether rewards can be claimed from this reward manager.</p>"},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_autoclaim_8dc305fa","title":"<code>autoClaim</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function autoClaim(\n    address[] _rewardOwners,\n    uint256 _rewardEpoch\n) external;\n</code></pre> <p>Allows claiming rewards simultaneously for a list of reward owners and all unclaimed epochs before the specified one.</p> <p>This is meant as a convenience all-in-one reward claiming method to be used both by reward owners and registered executors. It performs a series of operations, besides claiming rewards:</p> <ul> <li> <p>If a reward owner has enabled its Personal Delegation Account, rewards are also claimed for the PDA and the total claimed amount is sent to that PDA. Otherwise, the claimed amount is sent to the reward owner's account.</p> </li> <li> <p>Claimed amount is automatically wrapped through the <code>WNat</code> contract.</p> </li> <li> <p>If the caller is a registered executor with a non-zero fee, the fee is paid to the executor for each claimed address.</p> </li> </ul> Parameters Type Description <code>_rewardOwners</code> <code>address[]</code> List of reward owners to claim for. <code>_rewardEpoch</code> <code>uint256</code> Last reward epoch ID to claim for. All previous epochs with pending rewards will be claimed too."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_claim_b2c12192","title":"<code>claim</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function claim(\n    address _rewardOwner,\n    address payable _recipient,\n    uint256 _rewardEpoch,\n    bool _wrap\n) external returns (\n    uint256 _rewardAmount);\n</code></pre> <p>Allows the caller to <code>claim</code> rewards for a reward owner. The caller does not have to be the owner of the rewards, but must be approved by the owner to <code>claim</code> on his behalf by using <code>setClaimExecutors</code> on the <code>claimSetupManager</code>.</p> <p>This function is intended to be used to <code>claim</code> rewards in case of delegation by percentage. Reverts if <code>msg.sender</code> is delegating by amount.</p> <p>Anybody can call this method, but rewards can only be sent to the reward owner, therefore no funds can be stolen. However, by limiting the authorized callers, the owner can control the timing of the calls.</p> <p>When the reward owner is the caller, rewards can be sent to any recipient set by <code>setAllowedClaimRecipients</code> on the <code>claimSetupManager</code>. The reward owner's Personal Delegation Account is always an authorized recipient.</p> Parameters Type Description <code>_rewardOwner</code> <code>address</code> Address of the reward owner. <code>_recipient</code> <code>address payable</code> Address to transfer claimed rewards to. <code>_rewardEpoch</code> <code>uint256</code> Last reward epoch to claim for. All previous epochs with pending rewards will be claimed too. <code>_wrap</code> <code>bool</code> Whether claimed rewards should be wrapped through the <code>WNat</code> contract before transferring them to the <code>_recipient</code>. This parameter is offered as a convenience. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Total amount of claimed rewards (wei)."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_claimfromdataproviders_21bb25af","title":"<code>claimFromDataProviders</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function claimFromDataProviders(\n    address _rewardOwner,\n    address payable _recipient,\n    uint256[] _rewardEpochs,\n    address[] _dataProviders,\n    bool _wrap\n) external returns (\n    uint256 _rewardAmount);\n</code></pre> <p>Allows the caller to <code>claim</code> rewards for a reward owner from specific data providers. The caller does not have to be the owner of the rewards, but must be approved by the owner to <code>claim</code> on his behalf by using <code>setClaimExecutors</code> on the <code>claimSetupManager</code>.</p> <p>This function is intended to be used to <code>claim</code> rewards in case of delegation by amount (explicit delegation). Reverts if <code>msg.sender</code> is delegating by percentage.</p> <p>Anybody can call this method, but rewards can only be sent to the reward owner, therefore no funds can be stolen. However, by limiting the authorized callers, the owner can control the timing of the calls.</p> <p>When the reward owner is the caller, rewards can be sent to any recipient set by <code>setAllowedClaimRecipients</code> on the <code>claimSetupManager</code>. The reward owner's Personal Delegation Account is always an authorized recipient.</p> Parameters Type Description <code>_rewardOwner</code> <code>address</code> Address of the reward owner. <code>_recipient</code> <code>address payable</code> Address to transfer claimed rewards to. <code>_rewardEpochs</code> <code>uint256[]</code> Array of reward epoch IDs to claim for. <code>_dataProviders</code> <code>address[]</code> Array of addresses of the data providers to claim the reward from. <code>_wrap</code> <code>bool</code> Whether claimed rewards should be wrapped through the <code>WNat</code> contract before transferring them to the <code>_recipient</code>. This parameter is offered as a convenience. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Total amount of claimed rewards (wei)."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_claimreward_b2af870a","title":"<code>claimReward</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function claimReward(\n    address payable _recipient,\n    uint256[] _rewardEpochs\n) external returns (\n    uint256 _rewardAmount);\n</code></pre> <p>Allows a percentage delegator to <code>claim</code> rewards. This function is intended to be used to <code>claim</code> rewards in case of delegation by percentage.</p> <p>This function is deprecated: use <code>claim</code> instead.</p> <p>Reverts if <code>msg.sender</code> is delegating by amount. Claims for all unclaimed reward epochs to the 'max(_rewardEpochs)'. Retained for backward compatibility.</p> Parameters Type Description <code>_recipient</code> <code>address payable</code> Address to transfer funds to. <code>_rewardEpochs</code> <code>uint256[]</code> Array of reward epoch numbers to claim for. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Amount of total claimed rewards (wei)."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_claimrewardfromdataproviders_d20bb542","title":"<code>claimRewardFromDataProviders</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function claimRewardFromDataProviders(\n    address payable _recipient,\n    uint256[] _rewardEpochs,\n    address[] _dataProviders\n) external returns (\n    uint256 _rewardAmount);\n</code></pre> <p>Allows the caller to <code>claim</code> rewards from specific data providers. This function is intended to be used to <code>claim</code> rewards in case of delegation by amount.</p> <p>This function is deprecated: use <code>claimFromDataProviders</code> instead.</p> Parameters Type Description <code>_recipient</code> <code>address payable</code> Address to transfer funds to. <code>_rewardEpochs</code> <code>uint256[]</code> Array of reward epoch numbers to claim for. <code>_dataProviders</code> <code>address[]</code> Array of addresses of the data providers to claim the reward from. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Total amount of claimed rewards (wei)."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_getclaimedreward_85b4c538","title":"<code>getClaimedReward</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getClaimedReward(\n    uint256 _rewardEpoch,\n    address _dataProvider,\n    address _claimer\n) external view returns (\n    bool _claimed,\n    uint256 _amount);\n</code></pre> <p>Returns information on the rewards accrued by a reward owner from a specific data provider at a specific reward epoch.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID to query. <code>_dataProvider</code> <code>address</code> Address of the data provider to query. <code>_claimer</code> <code>address</code> Address of the reward owner to query. Returns Type Description <code>_claimed</code> <code>bool</code> Whether the reward has been claimed or not. <code>_amount</code> <code>uint256</code> Accrued amount in wei."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_getcurrentrewardepoch_e7c830d4","title":"<code>getCurrentRewardEpoch</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getCurrentRewardEpoch(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the current reward epoch ID.</p>"},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_getdataprovidercurrentfeepercentage_cfbcd25f","title":"<code>getDataProviderCurrentFeePercentage</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getDataProviderCurrentFeePercentage(\n    address _dataProvider\n) external view returns (\n    uint256 _feePercentageBIPS);\n</code></pre> <p>Returns the current fee percentage of a data provider.</p> Parameters Type Description <code>_dataProvider</code> <code>address</code> Address of the queried data provider. Returns Type Description <code>_feePercentageBIPS</code> <code>uint256</code> Fee percentage in BIPS."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_getdataproviderfeepercentage_961c00ed","title":"<code>getDataProviderFeePercentage</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getDataProviderFeePercentage(\n    address _dataProvider,\n    uint256 _rewardEpoch\n) external view returns (\n    uint256 _feePercentageBIPS);\n</code></pre> <p>Returns the fee percentage of a data provider at a given reward epoch.</p> Parameters Type Description <code>_dataProvider</code> <code>address</code> Address of the queried data provider. <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID. Returns Type Description <code>_feePercentageBIPS</code> <code>uint256</code> Fee percentage in BIPS."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_getdataproviderperformanceinfo_eb82dd7f","title":"<code>getDataProviderPerformanceInfo</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getDataProviderPerformanceInfo(\n    uint256 _rewardEpoch,\n    address _dataProvider\n) external view returns (\n    uint256 _rewardAmount,\n    uint256 _votePowerIgnoringRevocation);\n</code></pre> <p>Returns information on rewards and vote power of a data provider at a given reward epoch.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID. <code>_dataProvider</code> <code>address</code> Address of the data provider to query. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Amount of rewards (wei). <code>_votePowerIgnoringRevocation</code> <code>uint256</code> Vote power, not including revocations."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_getdataproviderscheduledfeepercentagechanges_33b7971e","title":"<code>getDataProviderScheduledFeePercentageChanges</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getDataProviderScheduledFeePercentageChanges(\n    address _dataProvider\n) external view returns (\n    uint256[] _feePercentageBIPS,\n    uint256[] _validFromEpoch,\n    bool[] _fixed);\n</code></pre> <p>Returns the scheduled fee percentage changes for a data provider.</p> Parameters Type Description <code>_dataProvider</code> <code>address</code> Address of the queried data provider. Returns Type Description <code>_feePercentageBIPS</code> <code>uint256[]</code> Array of fee percentages in BIPS. <code>_validFromEpoch</code> <code>uint256[]</code> Array of block numbers from which the fee settings are effective. <code>_fixed</code> <code>bool[]</code> Array of boolean values indicating whether settings are subject to change or not."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_getepochreward_d418634a","title":"<code>getEpochReward</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getEpochReward(\n    uint256 _rewardEpoch\n) external view returns (\n    uint256 _totalReward,\n    uint256 _claimedReward);\n</code></pre> <p>Returns information on an epoch's rewards.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID. Returns Type Description <code>_totalReward</code> <code>uint256</code> Total amount of rewards accrued on that epoch, in wei. <code>_claimedReward</code> <code>uint256</code> Total amount of rewards that have already been claimed, in wei."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_getepochswithclaimablerewards_0441218e","title":"<code>getEpochsWithClaimableRewards</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getEpochsWithClaimableRewards(\n) external view returns (\n    uint256 _startEpochId,\n    uint256 _endEpochId);\n</code></pre> <p>Returns the reward epoch range for which rewards can be claimed. Rewards outside this range are unclaimable, either because they have expired or because the reward epoch is still ongoing.</p> Returns Type Description <code>_startEpochId</code> <code>uint256</code> The oldest epoch ID that allows reward claiming. <code>_endEpochId</code> <code>uint256</code> The newest epoch ID that allows reward claiming."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_getepochswithunclaimedrewards_b4a2043d","title":"<code>getEpochsWithUnclaimedRewards</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getEpochsWithUnclaimedRewards(\n    address _beneficiary\n) external view returns (\n    uint256[] _epochIds);\n</code></pre> <p>Returns the array of claimable epoch IDs for which the rewards of a reward owner have not yet been claimed.</p> Parameters Type Description <code>_beneficiary</code> <code>address</code> Address of the reward owner to query. Reverts if it uses delegation by amount. Returns Type Description <code>_epochIds</code> <code>uint256[]</code> Array of epoch IDs."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_getinitialrewardepoch_3123b7d8","title":"<code>getInitialRewardEpoch</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getInitialRewardEpoch(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the initial reward epoch ID for this reward manager contract. This corresponds to the oldest reward epoch with claimable rewards in the previous reward manager when this one took over. Set by governance through <code>setInitialRewardData</code>.</p>"},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_getrewardepochtoexpirenext_3e7ff857","title":"<code>getRewardEpochToExpireNext</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochToExpireNext(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the reward epoch that will expire next once a new reward epoch starts.</p>"},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_getrewardepochvotepowerblock_f2edab5a","title":"<code>getRewardEpochVotePowerBlock</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochVotePowerBlock(\n    uint256 _rewardEpoch\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the vote power block of a given reward epoch.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_getstateofrewards_a4472c10","title":"<code>getStateOfRewards</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getStateOfRewards(\n    address _beneficiary,\n    uint256 _rewardEpoch\n) external view returns (\n    address[] _dataProviders,\n    uint256[] _rewardAmounts,\n    bool[] _claimed,\n    bool _claimable);\n</code></pre> <p>Returns the state of rewards for a given address at a specific reward epoch.</p> Parameters Type Description <code>_beneficiary</code> <code>address</code> Address of the beneficiary to query. It can be a data provider or a delegator, for example.Reverts if the queried address is delegating by amount. <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID to query. Returns Type Description <code>_dataProviders</code> <code>address[]</code> Array of addresses of data providers. <code>_rewardAmounts</code> <code>uint256[]</code> Array of reward amounts received from each provider, in wei. <code>_claimed</code> <code>bool[]</code> Array of boolean values indicating whether each reward has been claimed or not. <code>_claimable</code> <code>bool</code> Boolean value indicating whether rewards are claimable or not."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_getstateofrewardsfromdataproviders_e416b7e1","title":"<code>getStateOfRewardsFromDataProviders</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getStateOfRewardsFromDataProviders(\n    address _beneficiary,\n    uint256 _rewardEpoch,\n    address[] _dataProviders\n) external view returns (\n    uint256[] _rewardAmounts,\n    bool[] _claimed,\n    bool _claimable);\n</code></pre> <p>Returns the state of rewards for a given address coming from a specific set of data providers, at a specific reward epoch.</p> Parameters Type Description <code>_beneficiary</code> <code>address</code> Address of beneficiary to query. <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID to query. <code>_dataProviders</code> <code>address[]</code> Array of addresses of the data providers to query. Returns Type Description <code>_rewardAmounts</code> <code>uint256[]</code> Array of reward amounts received from each provider, in wei. <code>_claimed</code> <code>bool[]</code> Array of boolean values indicating whether each reward has been claimed or not. <code>_claimable</code> <code>bool</code> Boolean value indicating whether rewards are claimable or not."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_nextclaimablerewardepoch_69b91b59","title":"<code>nextClaimableRewardEpoch</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function nextClaimableRewardEpoch(\n    address _rewardOwner\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the next claimable reward epoch for a reward owner.</p> Parameters Type Description <code>_rewardOwner</code> <code>address</code> Address of the reward owner to query."},{"location":"apis/smart-contracts/IFtsoRewardManager/#fn_setdataproviderfeepercentage_16e69328","title":"<code>setDataProviderFeePercentage</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function setDataProviderFeePercentage(\n    uint256 _feePercentageBIPS\n) external returns (\n    uint256 _validFromEpoch);\n</code></pre> <p>Sets the fee a data provider keeps from all delegations.</p> <p>Takes effect after <code>feeValueUpdateOffset</code> reward epochs have elapsed.</p> <p>When called multiple times inside the same reward epoch, only the last value remains.</p> Parameters Type Description <code>_feePercentageBIPS</code> <code>uint256</code> Fee percentage in BIPS. Returns Type Description <code>_validFromEpoch</code> <code>uint256</code> Reward epoch number when the new fee percentage will become effective."},{"location":"apis/smart-contracts/IGovernanceSettings/","title":"IGovernanceSettings","text":""},{"location":"apis/smart-contracts/IGovernanceSettings/#ct_igovernancesettings","title":"<code>IGovernanceSettings</code>","text":"<p>Source</p> <p>Interface for the <code>GovernanceSettings</code> that hold the Flare governance address and its timelock.</p> <p>All governance calls are delayed by the timelock specified in this contract.</p> <p>NOTE: This contract enables updating the governance address and timelock only by hard-forking the network, meaning only by updating validator code.</p>"},{"location":"apis/smart-contracts/IGovernanceSettings/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IGovernanceSettings/#fn_getexecutors_ef09e78f","title":"<code>getExecutors</code>","text":"<p>Defined in <code>IGovernanceSettings</code> (Docs, Source).</p> <pre><code>function getExecutors(\n) external view returns (\n    address[] _addresses);\n</code></pre> <p>Gets the addresses of the accounts that are allowed to execute the timelocked governance calls, once the timelock period expires. Executors can be changed without a hard fork, via a normal governance call.</p> Returns Type Description <code>_addresses</code> <code>address[]</code> Array of executor addresses."},{"location":"apis/smart-contracts/IGovernanceSettings/#fn_getgovernanceaddress_73252494","title":"<code>getGovernanceAddress</code>","text":"<p>Defined in <code>IGovernanceSettings</code> (Docs, Source).</p> <pre><code>function getGovernanceAddress(\n) external view returns (\n    address _address);\n</code></pre> <p>Gets the governance account address. The governance address can only be changed by a hard fork.</p> Returns Type Description <code>_address</code> <code>address</code> The governance account address."},{"location":"apis/smart-contracts/IGovernanceSettings/#fn_gettimelock_6221a54b","title":"<code>getTimelock</code>","text":"<p>Defined in <code>IGovernanceSettings</code> (Docs, Source).</p> <pre><code>function getTimelock(\n) external view returns (\n    uint256 _timelock);\n</code></pre> <p>Gets the time in seconds that must pass between a governance call and its execution. The timelock value can only be changed by a hard fork.</p> Returns Type Description <code>_timelock</code> <code>uint256</code> Time in seconds that passes between the governance call and execution."},{"location":"apis/smart-contracts/IGovernanceSettings/#fn_isexecutor_debfda30","title":"<code>isExecutor</code>","text":"<p>Defined in <code>IGovernanceSettings</code> (Docs, Source).</p> <pre><code>function isExecutor(\n    address _address\n) external view returns (\n    bool);\n</code></pre> <p>Checks whether an address is one of the allowed executors. See <code>getExecutors</code>.</p> Parameters Type Description <code>_address</code> <code>address</code> The address to check. Returns Type Description [0] <code>bool</code> True if <code>_address</code> is in the executors list."},{"location":"apis/smart-contracts/IGovernanceVotePower/","title":"IGovernanceVotePower","text":""},{"location":"apis/smart-contracts/IGovernanceVotePower/#ct_igovernancevotepower","title":"<code>IGovernanceVotePower</code>","text":"<p>Source</p> <p>Interface for contracts delegating their governance vote power.</p>"},{"location":"apis/smart-contracts/IGovernanceVotePower/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IGovernanceVotePower/#fn_delegate_5c19a95c","title":"<code>delegate</code>","text":"<p>Defined in <code>IGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function delegate(\n    address _to\n) external;\n</code></pre> <p>Delegates all governance vote power of <code>msg.sender</code> to address <code>_to</code>.</p> Parameters Type Description <code>_to</code> <code>address</code> The address of the recipient."},{"location":"apis/smart-contracts/IGovernanceVotePower/#fn_getdelegateofat_3c028e9d","title":"<code>getDelegateOfAt</code>","text":"<p>Defined in <code>IGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function getDelegateOfAt(\n    address _who,\n    uint256 _blockNumber\n) external view returns (\n    address);\n</code></pre> <p>Gets the address an account is delegating its governance vote power to, at a given block number.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. <code>_blockNumber</code> <code>uint256</code> The block number at which to fetch the address. Returns Type Description [0] <code>address</code> Address where <code>_who</code> was delegating its governance vote power at block <code>_blockNumber</code>."},{"location":"apis/smart-contracts/IGovernanceVotePower/#fn_getdelegateofatnow_b3e871ee","title":"<code>getDelegateOfAtNow</code>","text":"<p>Defined in <code>IGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function getDelegateOfAtNow(\n    address _who\n) external view returns (\n    address);\n</code></pre> <p>Gets the address an account is delegating its governance vote power to, at the latest block number.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. Returns Type Description [0] <code>address</code> Address where <code>_who</code> is currently delegating its governance vote power."},{"location":"apis/smart-contracts/IGovernanceVotePower/#fn_getvotes_9ab24eb0","title":"<code>getVotes</code>","text":"<p>Defined in <code>IGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function getVotes(\n    address _who\n) external view returns (\n    uint256);\n</code></pre> <p>Gets the governance vote power of an address at the latest block, including all delegations made to it.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. Returns Type Description [0] <code>uint256</code> Governance vote power of <code>account</code> at the lastest block."},{"location":"apis/smart-contracts/IGovernanceVotePower/#fn_undelegate_92ab89bb","title":"<code>undelegate</code>","text":"<p>Defined in <code>IGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function undelegate(\n) external;\n</code></pre> <p>Undelegates all governance vote power of <code>msg.sender</code>.</p>"},{"location":"apis/smart-contracts/IGovernanceVotePower/#fn_votepowerofat_92bfe6d8","title":"<code>votePowerOfAt</code>","text":"<p>Defined in <code>IGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function votePowerOfAt(\n    address _who,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Gets the governance vote power of an address at a given block number, including all delegations made to it.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. <code>_blockNumber</code> <code>uint256</code> The block number at which to fetch the vote power. Returns Type Description [0] <code>uint256</code> Governance vote power of <code>_who</code> at <code>_blockNumber</code>."},{"location":"apis/smart-contracts/IIAddressUpdatable/","title":"IIAddressUpdatable","text":""},{"location":"apis/smart-contracts/IIAddressUpdatable/#ct_iiaddressupdatable","title":"<code>IIAddressUpdatable</code>","text":"<p>Source</p> <p>Internal interface for contracts that depend on other contracts whose addresses can change.</p> <p>See <code>AddressUpdatable</code>.</p>"},{"location":"apis/smart-contracts/IIAddressUpdatable/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IIAddressUpdatable/#fn_updatecontractaddresses_b00c0b76","title":"<code>updateContractAddresses</code>","text":"<p>Defined in <code>IIAddressUpdatable</code> (Docs, Source).</p> <pre><code>function updateContractAddresses(\n    bytes32[] _contractNameHashes,\n    address[] _contractAddresses\n) external;\n</code></pre> <p>Updates contract addresses. Can only be called from the <code>AddressUpdater</code> contract typically set at construction time.</p> Parameters Type Description <code>_contractNameHashes</code> <code>bytes32[]</code> List of keccak256(abi.encode(...)) contract names. <code>_contractAddresses</code> <code>address[]</code> List of contract addresses corresponding to the contract names."},{"location":"apis/smart-contracts/IIAddressUpdater/","title":"IIAddressUpdater","text":""},{"location":"apis/smart-contracts/IIAddressUpdater/#ct_iiaddressupdater","title":"<code>IIAddressUpdater</code>","text":"<p>Source</p> <p>Internal interface for <code>AddressUpdater</code>.</p>"},{"location":"apis/smart-contracts/IIAddressUpdater/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IIAddressUpdater/#fn_getcontractaddress_04433bbc","title":"<code>getContractAddress</code>","text":"<p>Defined in <code>IIAddressUpdater</code> (Docs, Source).</p> <pre><code>function getContractAddress(\n    string _name\n) external view returns (\n    address);\n</code></pre> <p>Returns contract address for the given name, which might be address(0).</p> Parameters Type Description <code>_name</code> <code>string</code> Name of the contract to query. Returns Type Description [0] <code>address</code> Current address for the queried contract."},{"location":"apis/smart-contracts/IIAddressUpdater/#fn_getcontractaddressbyhash_159354a2","title":"<code>getContractAddressByHash</code>","text":"<p>Defined in <code>IIAddressUpdater</code> (Docs, Source).</p> <pre><code>function getContractAddressByHash(\n    bytes32 _nameHash\n) external view returns (\n    address);\n</code></pre> <p>Returns contract address for the given name hash, which might be address(0).</p> Parameters Type Description <code>_nameHash</code> <code>bytes32</code> Hash of the contract name: <code>keccak256(abi.encode(name))</code> Returns Type Description [0] <code>address</code> Current address for the queried contract."},{"location":"apis/smart-contracts/IIAddressUpdater/#fn_getcontractaddresses_ee6f63c3","title":"<code>getContractAddresses</code>","text":"<p>Defined in <code>IIAddressUpdater</code> (Docs, Source).</p> <pre><code>function getContractAddresses(\n    string[] _names\n) external view returns (\n    address[]);\n</code></pre> <p>Returns contract addresses for the given names, which might be address(0).</p> Parameters Type Description <code>_names</code> <code>string[]</code> Names of the contracts to query. Returns Type Description [0] <code>address[]</code> Current addresses for the queried contracts."},{"location":"apis/smart-contracts/IIAddressUpdater/#fn_getcontractaddressesbyhash_5e11e2d1","title":"<code>getContractAddressesByHash</code>","text":"<p>Defined in <code>IIAddressUpdater</code> (Docs, Source).</p> <pre><code>function getContractAddressesByHash(\n    bytes32[] _nameHashes\n) external view returns (\n    address[]);\n</code></pre> <p>Returns contract addresses for the given name hashes, which might be address(0).</p> Parameters Type Description <code>_nameHashes</code> <code>bytes32[]</code> Hashes of the contract names: <code>keccak256(abi.encode(name))</code> Returns Type Description [0] <code>address[]</code> Current addresses for the queried contracts."},{"location":"apis/smart-contracts/IIAddressUpdater/#fn_getcontractnamesandaddresses_2f26c5c3","title":"<code>getContractNamesAndAddresses</code>","text":"<p>Defined in <code>IIAddressUpdater</code> (Docs, Source).</p> <pre><code>function getContractNamesAndAddresses(\n) external view returns (\n    string[] _contractNames,\n    address[] _contractAddresses);\n</code></pre> <p>Returns all contract names and corresponding addresses currently being tracked.</p> Returns Type Description <code>_contractNames</code> <code>string[]</code> Array of contract names. <code>_contractAddresses</code> <code>address[]</code> Array of contract addresses."},{"location":"apis/smart-contracts/IIClaimSetupManager/","title":"IIClaimSetupManager","text":""},{"location":"apis/smart-contracts/IIClaimSetupManager/#ct_iiclaimsetupmanager","title":"<code>IIClaimSetupManager</code>","text":"<p>Source | Inherits from IClaimSetupManager</p> <p>Internal interface for the <code>ClaimSetupManager</code> contract.</p>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#events","title":"Events","text":""},{"location":"apis/smart-contracts/IIClaimSetupManager/#ev_allowedclaimrecipientschanged","title":"<code>AllowedClaimRecipientsChanged</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event AllowedClaimRecipientsChanged(\n    address owner,\n    address[] recipients\n)\n</code></pre>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#ev_claimexecutorfeevaluechanged","title":"<code>ClaimExecutorFeeValueChanged</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event ClaimExecutorFeeValueChanged(\n    address executor,\n    uint256 validFromRewardEpoch,\n    uint256 feeValueWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#ev_claimexecutorschanged","title":"<code>ClaimExecutorsChanged</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event ClaimExecutorsChanged(\n    address owner,\n    address[] executors\n)\n</code></pre>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#ev_delegationaccountcreated","title":"<code>DelegationAccountCreated</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event DelegationAccountCreated(\n    address owner,\n    contract IDelegationAccount delegationAccount\n)\n</code></pre>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#ev_delegationaccountupdated","title":"<code>DelegationAccountUpdated</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event DelegationAccountUpdated(\n    address owner,\n    contract IDelegationAccount delegationAccount,\n    bool enabled\n)\n</code></pre>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#ev_executorregistered","title":"<code>ExecutorRegistered</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event ExecutorRegistered(\n    address executor\n)\n</code></pre>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#ev_executorunregistered","title":"<code>ExecutorUnregistered</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event ExecutorUnregistered(\n    address executor,\n    uint256 validFromRewardEpoch\n)\n</code></pre>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#ev_maxfeeset","title":"<code>MaxFeeSet</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event MaxFeeSet(\n    uint256 maxFeeValueWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#ev_minfeeset","title":"<code>MinFeeSet</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event MinFeeSet(\n    uint256 minFeeValueWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#ev_registerexecutorfeeset","title":"<code>RegisterExecutorFeeSet</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event RegisterExecutorFeeSet(\n    uint256 registerExecutorFeeValueWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#ev_setexecutorsexcessamountrefunded","title":"<code>SetExecutorsExcessAmountRefunded</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>event SetExecutorsExcessAmountRefunded(\n    address owner,\n    uint256 excessAmount\n)\n</code></pre>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#ev_setlibraryaddress","title":"<code>SetLibraryAddress</code>","text":"<p>Defined in <code>IIClaimSetupManager</code> (Docs, Source).</p> <pre><code>event SetLibraryAddress(\n    address libraryAddress\n)\n</code></pre> <p>Emitted when the <code>libraryAddress</code> has been set.</p>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_accounttodelegationaccount_69ea2387","title":"<code>accountToDelegationAccount</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function accountToDelegationAccount(\n    address _owner\n) external view returns (\n    address);\n</code></pre> <p>Gets the PDA of an account.</p> Parameters Type Description <code>_owner</code> <code>address</code> Account to query. Returns Type Description [0] <code>address</code> Address of its PDA or <code>address(0)</code> if it has not been created yet."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_allowedclaimrecipients_dfd14c34","title":"<code>allowedClaimRecipients</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function allowedClaimRecipients(\n    address _rewardOwner\n) external view returns (\n    address[]);\n</code></pre> <p>Gets the addresses of recipients allowed to receive rewards on behalf of an account. Beside these, the owner of the rewards is always authorized. See <code>setAllowedClaimRecipients</code>.</p> Parameters Type Description <code>_rewardOwner</code> <code>address</code> The account to query. Returns Type Description [0] <code>address[]</code> Addresses of all set authorized recipients."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_batchdelegate_dc4fcda7","title":"<code>batchDelegate</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function batchDelegate(\n    address[] _delegatees,\n    uint256[] _bips\n) external;\n</code></pre> <p>Undelegates all percentage delegations from the caller's PDA and then <code>delegate</code> to a list of accounts.</p> <p>See <code>delegate</code>.</p> Parameters Type Description <code>_delegatees</code> <code>address[]</code> The addresses of the new recipients. <code>_bips</code> <code>uint256[]</code> The percentage of voting power to be delegated to each delegatee, expressed in basis points (1/100 of one percent). Total of all <code>_bips</code> values must be lower than 10000."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_checkexecutorandallowedrecipient_ce2caa57","title":"<code>checkExecutorAndAllowedRecipient</code>","text":"<p>Defined in <code>IIClaimSetupManager</code> (Docs, Source).</p> <pre><code>function checkExecutorAndAllowedRecipient(\n    address _executor,\n    address _owner,\n    address _recipient\n) external view;\n</code></pre> <p>Checks if an executor can claim on behalf of a given account and send funds to a given recipient address.</p> <p>Reverts if claiming is not possible, does nothing otherwise.</p> Parameters Type Description <code>_executor</code> <code>address</code> The executor to query. <code>_owner</code> <code>address</code> The reward owner to query. <code>_recipient</code> <code>address</code> The address where the reward would be sent."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_claimexecutors_3f317fe1","title":"<code>claimExecutors</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function claimExecutors(\n    address _owner\n) external view returns (\n    address[]);\n</code></pre> <p>Gets the addresses of executors authorized to claim for an account. See <code>setClaimExecutors</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> The account to query. Returns Type Description [0] <code>address[]</code> Addresses of all set executors."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_delegate_026e402b","title":"<code>delegate</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function delegate(\n    address _to,\n    uint256 _bips\n) external;\n</code></pre> <p>Delegates a percentage of the caller's PDA's voting power to another address.</p> Parameters Type Description <code>_to</code> <code>address</code> The address of the recipient. <code>_bips</code> <code>uint256</code> The percentage of voting power to be delegated expressed in basis points (1/100 of one percent). Not cumulative: Every call resets the delegation value. A value of 0 revokes delegation."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_delegategovernance_7a68a508","title":"<code>delegateGovernance</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function delegateGovernance(\n    address _to\n) external;\n</code></pre> <p>Delegates all the governance vote power of the caller's PDA to another account.</p> Parameters Type Description <code>_to</code> <code>address</code> Address of the recipient of the delegation."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_disabledelegationaccount_2394deb1","title":"<code>disableDelegationAccount</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function disableDelegationAccount(\n) external;\n</code></pre> <p>Disables the Personal Delegation Account (PDA).</p> <p>When using automatic claiming, all airdrops and FTSO rewards will be sent to the owner's account. Rewards accrued by the PDA will no longer be automatically claimed.</p> <p>Reverts if there is no PDA.</p>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_enabledelegationaccount_f0977215","title":"<code>enableDelegationAccount</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function enableDelegationAccount(\n) external returns (\n    contract IDelegationAccount);\n</code></pre> <p>Enables (or creates) a Personal Delegation Account (PDA).</p> <p>When using automatic claiming, all airdrops and FTSO rewards will be sent to the PDA, and any rewards accrued by the PDA will be claimed too.</p> Returns Type Description [0] <code>contract IDelegationAccount</code> Address of the delegation account contract."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_getautoclaimaddressesandexecutorfee_e24883b2","title":"<code>getAutoClaimAddressesAndExecutorFee</code>","text":"<p>Defined in <code>IIClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getAutoClaimAddressesAndExecutorFee(\n    address _executor,\n    address[] _owners\n) external view returns (\n    address[] _recipients,\n    uint256 _executorFeeValue);\n</code></pre> <p>Gets the Personal Delegation Account (PDA) for a list of accounts for which an executor is claiming. Returns owner address instead if the PDA is not created yet or not enabled.</p> Parameters Type Description <code>_executor</code> <code>address</code> Executor to query. <code>_owners</code> <code>address[]</code> Array of reward owners which must have set <code>_executor</code> as their executor. Returns Type Description <code>_recipients</code> <code>address[]</code> Addresses which will receive the claimed rewards. Can be the reward owners or their PDAs. <code>_executorFeeValue</code> <code>uint256</code> Executor's fee value, in wei."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_getdelegationaccountdata_17a1e3fc","title":"<code>getDelegationAccountData</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getDelegationAccountData(\n    address _owner\n) external view returns (\n    contract IDelegationAccount _delegationAccount,\n    bool _enabled);\n</code></pre> <p>Gets PDA data for an account.</p> Parameters Type Description <code>_owner</code> <code>address</code> Account to query. Returns Type Description <code>_delegationAccount</code> <code>contract IDelegationAccount</code> Account's PDA address or <code>address(0)</code> if it has not been created yet. <code>_enabled</code> <code>bool</code> Whether the PDA is enabled."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_getexecutorcurrentfeevalue_e25547f8","title":"<code>getExecutorCurrentFeeValue</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getExecutorCurrentFeeValue(\n    address _executor\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the current fee of a registered executor. Reverts if the executor is not registered.</p> Parameters Type Description <code>_executor</code> <code>address</code> The executor to query. Returns Type Description [0] <code>uint256</code> Fee in wei."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_getexecutorfeevalue_3f8f784c","title":"<code>getExecutorFeeValue</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getExecutorFeeValue(\n    address _executor,\n    uint256 _rewardEpoch\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the fee of an executor at a given reward epoch.</p> Parameters Type Description <code>_executor</code> <code>address</code> The executor to query. <code>_rewardEpoch</code> <code>uint256</code> Reward Epoch ID to query. Returns Type Description [0] <code>uint256</code> Fee in wei at that reward epoch."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_getexecutorinfo_8e28b923","title":"<code>getExecutorInfo</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getExecutorInfo(\n    address _executor\n) external view returns (\n    bool _registered,\n    uint256 _currentFeeValue);\n</code></pre> <p>Returns information about an executor.</p> Parameters Type Description <code>_executor</code> <code>address</code> The executor to query. Returns Type Description <code>_registered</code> <code>bool</code> Whether the executor is registered. <code>_currentFeeValue</code> <code>uint256</code> Executor's current fee value, if registered."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_getexecutorscheduledfeevaluechanges_950b028c","title":"<code>getExecutorScheduledFeeValueChanges</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getExecutorScheduledFeeValueChanges(\n    address _executor\n) external view returns (\n    uint256[] _feeValue,\n    uint256[] _validFromEpoch,\n    bool[] _fixed);\n</code></pre> <p>Returns the currently scheduled fee changes of an executor.</p> Parameters Type Description <code>_executor</code> <code>address</code> Executor to query. Returns Type Description <code>_feeValue</code> <code>uint256[]</code> Array of scheduled fees. <code>_validFromEpoch</code> <code>uint256[]</code> Array of reward epochs ID where the scheduled fees will become effective. <code>_fixed</code> <code>bool[]</code> Array of booleans indicating if an scheduled fee change is fixed or it might still be changed."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_getregisteredexecutors_6e927e61","title":"<code>getRegisteredExecutors</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function getRegisteredExecutors(\n    uint256 _start,\n    uint256 _end\n) external view returns (\n    address[] _registeredExecutors,\n    uint256 _totalLength);\n</code></pre> <p>Returns the list of executors registered through <code>registerExecutor</code>. Supports paging.</p> Parameters Type Description <code>_start</code> <code>uint256</code> First executor to return. <code>_end</code> <code>uint256</code> Last executor to return. Returns Type Description <code>_registeredExecutors</code> <code>address[]</code> Addresses of the registered executors. <code>_totalLength</code> <code>uint256</code> Total amount of executors."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_isclaimexecutor_87962abe","title":"<code>isClaimExecutor</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function isClaimExecutor(\n    address _owner,\n    address _executor\n) external view returns (\n    bool);\n</code></pre> <p>Returns whether an executor is authorized to claim on behalf of a reward owner. See <code>setClaimExecutors</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> The reward owner to query. <code>_executor</code> <code>address</code> The executor to query."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_registerexecutor_ccce7e86","title":"<code>registerExecutor</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function registerExecutor(\n    uint256 _feeValue\n) external payable returns (\n    uint256);\n</code></pre> <p>Registers the caller as an executor and sets its initial fee value.</p> <p>If the executor was already registered, this method only updates the fee, which will take effect after <code>feeValueUpdateOffset</code> reward epochs have elapsed.</p> <p>Executor must pay a fee in order to register. See <code>registerExecutorFeeValueWei</code>.</p> Parameters Type Description <code>_feeValue</code> <code>uint256</code> Desired fee, in wei. Must be between <code>minFeeValueWei</code> and <code>maxFeeValueWei</code>. 0 means no fee. Returns Type Description [0] <code>uint256</code> Reward epoch ID when the changes become effective."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_revokedelegationat_bbd6fbf8","title":"<code>revokeDelegationAt</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function revokeDelegationAt(\n    address _who,\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Revokes all delegation from the caller's PDA to a given account at a given block.</p> <p>Only affects the reads via <code>votePowerOfAtCached()</code> in the specified block.</p> <p>This method should be used only to prevent rogue <code>delegate</code> voting in the current voting block. To stop delegating use <code>delegate</code> with percentage of 0 or <code>undelegateAll</code>.</p> Parameters Type Description <code>_who</code> <code>address</code> The account to revoke. <code>_blockNumber</code> <code>uint256</code> Block number where the revoking will take place. Must be in the past."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_setallowedclaimrecipients_d2a4ac61","title":"<code>setAllowedClaimRecipients</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setAllowedClaimRecipients(\n    address[] _recipients\n) external;\n</code></pre> <p>Set the addresses of allowed recipients. The reward owner is always an allowed recipient.</p> Parameters Type Description <code>_recipients</code> <code>address[]</code> The new allowed recipients. All old recipients will be deleted and replaced by these."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_setautoclaiming_e72dcdbb","title":"<code>setAutoClaiming</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setAutoClaiming(\n    address[] _executors,\n    bool _enableDelegationAccount\n) external payable;\n</code></pre> <p>Sets the addresses of executors and optionally enables (creates) a Personal Delegation Account (PDA).</p> <p>If any of the executors is a registered executor, some fee needs to be paid.</p> Parameters Type Description <code>_executors</code> <code>address[]</code> The new executors. All old executors will be deleted and replaced by these. <code>_enableDelegationAccount</code> <code>bool</code> Whether the PDA should be enabled."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_setclaimexecutors_9119c494","title":"<code>setClaimExecutors</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setClaimExecutors(\n    address[] _executors\n) external payable;\n</code></pre> <p>Sets the addresses of executors.</p> <p>If any of the executors is a registered executor, some fee needs to be paid.</p> Parameters Type Description <code>_executors</code> <code>address[]</code> The new executors. All old executors will be deleted and replaced by these."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_setlibraryaddress_4863ba17","title":"<code>setLibraryAddress</code>","text":"<p>Defined in <code>IIClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setLibraryAddress(\n    address _libraryAddress\n) external;\n</code></pre> <p>Sets new library address.</p>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_setmaxfeevaluewei_2e9b6afa","title":"<code>setMaxFeeValueWei</code>","text":"<p>Defined in <code>IIClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setMaxFeeValueWei(\n    uint256 _maxFeeValueWei\n) external;\n</code></pre> <p>Sets maximum fee allowed for executors, in wei.</p>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_setminfeevaluewei_d8343550","title":"<code>setMinFeeValueWei</code>","text":"<p>Defined in <code>IIClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setMinFeeValueWei(\n    uint256 _minFeeValueWei\n) external;\n</code></pre> <p>Sets minimum fee allowed for executors, in wei.</p>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_setregisterexecutorfeevaluewei_869d90a5","title":"<code>setRegisterExecutorFeeValueWei</code>","text":"<p>Defined in <code>IIClaimSetupManager</code> (Docs, Source).</p> <pre><code>function setRegisterExecutorFeeValueWei(\n    uint256 _registerExecutorFeeValueWei\n) external;\n</code></pre> <p>Sets the fee required to register an executor, which must be higher than 0.</p>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_transferexternaltoken_489a8a47","title":"<code>transferExternalToken</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function transferExternalToken(\n    contract IERC20 _token,\n    uint256 _amount\n) external;\n</code></pre> <p>Allows the caller to transfer ERC-20 tokens from their PDA to the owner account.</p> <p>The main use case is to move ERC-20 tokes received by mistake (by an airdrop, for example) out of the PDA and into the main account, where they can be more easily managed.</p> <p>Reverts if the target token is the <code>WNat</code> contract: use method <code>withdraw</code> for that.</p> Parameters Type Description <code>_token</code> <code>contract IERC20</code> Target token contract address. <code>_amount</code> <code>uint256</code> Amount of tokens to transfer."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_undelegateall_b302f393","title":"<code>undelegateAll</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function undelegateAll(\n) external;\n</code></pre> <p>Removes all delegations from the caller's PDA.</p>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_undelegategovernance_87a2a0dc","title":"<code>undelegateGovernance</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function undelegateGovernance(\n) external;\n</code></pre> <p>Undelegates all governance vote power currently delegated by the caller's PDA.</p>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_unregisterexecutor_868a660f","title":"<code>unregisterExecutor</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function unregisterExecutor(\n) external returns (\n    uint256);\n</code></pre> <p>Unregisters the caller as an executor.</p> Returns Type Description [0] <code>uint256</code> Reward epoch ID when the change becomes effective."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_updateexecutorfeevalue_831f16af","title":"<code>updateExecutorFeeValue</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function updateExecutorFeeValue(\n    uint256 _feeValue\n) external returns (\n    uint256);\n</code></pre> <p>Sets the caller's executor fee. The caller must be an executor registered through <code>registerExecutor</code>.</p> <p>When called multiple times inside the same reward epoch, only the last value remains.</p> Parameters Type Description <code>_feeValue</code> <code>uint256</code> Desired fee, in wei. Must be between <code>minFeeValueWei</code> and <code>maxFeeValueWei</code>. 0 means no fee. Returns Type Description [0] <code>uint256</code> Reward epoch ID when the changes become effective."},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_wnat_9edbf007","title":"<code>wNat</code>","text":"<p>Defined in <code>IIClaimSetupManager</code> (Docs, Source).</p> <pre><code>function wNat(\n) external view returns (\n    contract WNat);\n</code></pre> <p>Returns the <code>WNat</code> contract.</p>"},{"location":"apis/smart-contracts/IIClaimSetupManager/#fn_withdraw_2e1a7d4d","title":"<code>withdraw</code>","text":"<p>Defined in <code>IClaimSetupManager</code> (Docs, Source).</p> <pre><code>function withdraw(\n    uint256 _amount\n) external;\n</code></pre> <p>Allows the caller to transfer <code>WNat</code> wrapped tokens from their PDA to the owner account.</p> Parameters Type Description <code>_amount</code> <code>uint256</code> Amount of tokens to transfer, in wei."},{"location":"apis/smart-contracts/IICleanable/","title":"IICleanable","text":""},{"location":"apis/smart-contracts/IICleanable/#ct_iicleanable","title":"<code>IICleanable</code>","text":"<p>Source</p> <p>Internal interface for entities that can have their block history cleaned.</p>"},{"location":"apis/smart-contracts/IICleanable/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IICleanable/#fn_cleanupblocknumber_deea13e7","title":"<code>cleanupBlockNumber</code>","text":"<p>Defined in <code>IICleanable</code> (Docs, Source).</p> <pre><code>function cleanupBlockNumber(\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current cleanup block number set with <code>setCleanupBlockNumber</code>.</p> Returns Type Description [0] <code>uint256</code> The currently set cleanup block number."},{"location":"apis/smart-contracts/IICleanable/#fn_setcleanercontract_f6a494af","title":"<code>setCleanerContract</code>","text":"<p>Defined in <code>IICleanable</code> (Docs, Source).</p> <pre><code>function setCleanerContract(\n    address _cleanerContract\n) external;\n</code></pre> <p>Set the contract that is allowed to call history cleaning methods.</p> Parameters Type Description <code>_cleanerContract</code> <code>address</code> Address of the cleanup contract. Usually this will be an instance of <code>CleanupBlockNumberManager</code>."},{"location":"apis/smart-contracts/IICleanable/#fn_setcleanupblocknumber_13de97f5","title":"<code>setCleanupBlockNumber</code>","text":"<p>Defined in <code>IICleanable</code> (Docs, Source).</p> <pre><code>function setCleanupBlockNumber(\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Set the cleanup block number. Historic data for the blocks before <code>cleanupBlockNumber</code> can be erased. History before that block should never be used since it can be inconsistent. In particular, cleanup block number must be lower than the current vote power block.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The new cleanup block number."},{"location":"apis/smart-contracts/IIFtso/","title":"IIFtso","text":""},{"location":"apis/smart-contracts/IIFtso/#ct_iiftso","title":"<code>IIFtso</code>","text":"<p>Source | Inherits from IFtso, IFtsoGenesis</p> <p>Internal interface for each of the FTSO contracts that handles an asset. Read the FTSO documentation page for general information about the FTSO system.</p>"},{"location":"apis/smart-contracts/IIFtso/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IIFtso/#fn_activateftso_2f0a6f3c","title":"<code>activateFtso</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function activateFtso(\n    uint256 _firstEpochStartTs,\n    uint256 _submitPeriodSeconds,\n    uint256 _revealPeriodSeconds\n) external;\n</code></pre> <p>Initializes FTSO immutable settings and activates the contract.</p> Parameters Type Description <code>_firstEpochStartTs</code> <code>uint256</code> Timestamp of the first epoch in seconds from UNIX epoch. <code>_submitPeriodSeconds</code> <code>uint256</code> Duration of epoch submission window in seconds. <code>_revealPeriodSeconds</code> <code>uint256</code> Duration of epoch reveal window in seconds."},{"location":"apis/smart-contracts/IIFtso/#fn_active_02fb0c5e","title":"<code>active</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function active(\n) external view returns (\n    bool);\n</code></pre> <p>Returns whether FTSO is <code>active</code> or not.</p>"},{"location":"apis/smart-contracts/IIFtso/#fn_configureepochs_5a3c9d8e","title":"<code>configureEpochs</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function configureEpochs(\n    uint256 _maxVotePowerNatThresholdFraction,\n    uint256 _maxVotePowerAssetThresholdFraction,\n    uint256 _lowAssetUSDThreshold,\n    uint256 _highAssetUSDThreshold,\n    uint256 _highAssetTurnoutThresholdBIPS,\n    uint256 _lowNatTurnoutThresholdBIPS,\n    uint256 _elasticBandRewardBIPS,\n    uint256 _elasticBandWidthPPM,\n    address[] _trustedAddresses\n) external;\n</code></pre> <p>Sets configurable settings related to epochs.</p> Parameters Type Description <code>_maxVotePowerNatThresholdFraction</code> <code>uint256</code> High threshold for native token vote power per voter. <code>_maxVotePowerAssetThresholdFraction</code> <code>uint256</code> High threshold for asset vote power per voter. <code>_lowAssetUSDThreshold</code> <code>uint256</code> Threshold for low asset vote power (in scaled USD). <code>_highAssetUSDThreshold</code> <code>uint256</code> Threshold for high asset vote power (in scaled USD). <code>_highAssetTurnoutThresholdBIPS</code> <code>uint256</code> Threshold for high asset turnout (in BIPS). <code>_lowNatTurnoutThresholdBIPS</code> <code>uint256</code> Threshold for low nat turnout (in BIPS). <code>_elasticBandRewardBIPS</code> <code>uint256</code> Percentage of the rewards (in BIPS) that go to the secondary reward band. The rest go to the primary reward band. <code>_elasticBandWidthPPM</code> <code>uint256</code> Width of the secondary reward band, in parts-per-milion of the median. <code>_trustedAddresses</code> <code>address[]</code> Trusted voters that will be used if low voter turnout is detected."},{"location":"apis/smart-contracts/IIFtso/#fn_deactivateftso_555989da","title":"<code>deactivateFtso</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function deactivateFtso(\n) external;\n</code></pre> <p>Deactivates the contract.</p>"},{"location":"apis/smart-contracts/IIFtso/#fn_epochsconfiguration_e3749e0c","title":"<code>epochsConfiguration</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function epochsConfiguration(\n) external view returns (\n    uint256 _maxVotePowerNatThresholdFraction,\n    uint256 _maxVotePowerAssetThresholdFraction,\n    uint256 _lowAssetUSDThreshold,\n    uint256 _highAssetUSDThreshold,\n    uint256 _highAssetTurnoutThresholdBIPS,\n    uint256 _lowNatTurnoutThresholdBIPS,\n    uint256 _elasticBandRewardBIPS,\n    uint256 _elasticBandWidthPPM,\n    address[] _trustedAddresses);\n</code></pre> <p>Returns current configuration of epoch state.</p> Returns Type Description <code>_maxVotePowerNatThresholdFraction</code> <code>uint256</code> High threshold for native token vote power per voter. <code>_maxVotePowerAssetThresholdFraction</code> <code>uint256</code> High threshold for asset vote power per voter. <code>_lowAssetUSDThreshold</code> <code>uint256</code> Threshold for low asset vote power (in scaled USD). <code>_highAssetUSDThreshold</code> <code>uint256</code> Threshold for high asset vote power (in scaled USD). <code>_highAssetTurnoutThresholdBIPS</code> <code>uint256</code> Threshold for high asset turnout (in BIPS). <code>_lowNatTurnoutThresholdBIPS</code> <code>uint256</code> Threshold for low nat turnout (in BIPS). <code>_elasticBandRewardBIPS</code> <code>uint256</code> Percentage of the rewards (in BIPS) that go to the secondary reward band. The rest go to the primary reward band. <code>_elasticBandWidthPPM</code> <code>uint256</code> Width of the secondary reward band, in parts-per-milion of the median. <code>_trustedAddresses</code> <code>address[]</code> Trusted voters that will be used if low voter turnout is detected."},{"location":"apis/smart-contracts/IIFtso/#fn_fallbackfinalizepriceepoch_4afd5102","title":"<code>fallbackFinalizePriceEpoch</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function fallbackFinalizePriceEpoch(\n    uint256 _epochId\n) external;\n</code></pre> <p>Forces finalization of a price epoch, calculating the median price from trusted addresses only.</p> <p>Used as a fallback method, for example, due to an unexpected error during normal epoch finalization or because the <code>ftsoManager</code> enabled the fallback mode.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch to finalize."},{"location":"apis/smart-contracts/IIFtso/#fn_finalizepriceepoch_40462a2d","title":"<code>finalizePriceEpoch</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function finalizePriceEpoch(\n    uint256 _epochId,\n    bool _returnRewardData\n) external returns (\n    address[] _eligibleAddresses,\n    uint256[] _natWeights,\n    uint256 _totalNatWeight);\n</code></pre> <p>Computes epoch price based on gathered votes.</p> <ul> <li>If the price reveal window for the epoch has ended, finalize the epoch.</li> <li>Iterate list of price submissions.</li> <li>Find weighted median.</li> <li>Find adjacent 50% of price submissions.</li> <li>Allocate rewards for price submissions.</li> </ul> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch to finalize. <code>_returnRewardData</code> <code>bool</code> Parameter that determines if the reward data is returned. Returns Type Description <code>_eligibleAddresses</code> <code>address[]</code> List of addresses eligible for reward. <code>_natWeights</code> <code>uint256[]</code> List of native token weights corresponding to the eligible addresses. <code>_totalNatWeight</code> <code>uint256</code> Sum of weights in <code>_natWeights</code>."},{"location":"apis/smart-contracts/IIFtso/#fn_forcefinalizepriceepoch_974d7a6b","title":"<code>forceFinalizePriceEpoch</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function forceFinalizePriceEpoch(\n    uint256 _epochId\n) external;\n</code></pre> <p>Forces finalization of a price epoch by copying the price from the previous epoch.</p> <p>Used as a fallback method if <code>fallbackFinalizePriceEpoch</code> fails due to an exception.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch to finalize."},{"location":"apis/smart-contracts/IIFtso/#fn_ftsomanager_11a7aaaa","title":"<code>ftsoManager</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function ftsoManager(\n) external view returns (\n    address);\n</code></pre> <p>Returns the FTSO manager's address.</p> Returns Type Description [0] <code>address</code> Address of the FTSO manager contract."},{"location":"apis/smart-contracts/IIFtso/#fn_getasset_5c222bad","title":"<code>getAsset</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function getAsset(\n) external view returns (\n    contract IIVPToken);\n</code></pre> <p>Returns the FTSO asset.</p> Returns Type Description [0] <code>contract IIVPToken</code> Address of the <code>IIVPToken</code> tracked by this FTSO. <code>null</code> in case of multi-asset FTSO."},{"location":"apis/smart-contracts/IIFtso/#fn_getassetftsos_18931c35","title":"<code>getAssetFtsos</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function getAssetFtsos(\n) external view returns (\n    contract IIFtso[]);\n</code></pre> <p>Returns the asset FTSOs.</p> Returns Type Description [0] <code>contract IIFtso[]</code> Array of <code>IIFtso</code> contract addresses. <code>null</code> in case of single-asset FTSO."},{"location":"apis/smart-contracts/IIFtso/#fn_getcurrentepochid_a29a839f","title":"<code>getCurrentEpochId</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getCurrentEpochId(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the current epoch ID.</p> Returns Type Description [0] <code>uint256</code> Currently running epoch ID. IDs are consecutive numbers starting from zero."},{"location":"apis/smart-contracts/IIFtso/#fn_getcurrentprice_eb91d37e","title":"<code>getCurrentPrice</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getCurrentPrice(\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp);\n</code></pre> <p>Returns the current asset price.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Time when price was updated for the last time, in seconds from UNIX epoch."},{"location":"apis/smart-contracts/IIFtso/#fn_getcurrentpricedetails_040d73b8","title":"<code>getCurrentPriceDetails</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getCurrentPriceDetails(\n) external view returns (\n    uint256 _price,\n    uint256 _priceTimestamp,\n    enum IFtso.PriceFinalizationType _priceFinalizationType,\n    uint256 _lastPriceEpochFinalizationTimestamp,\n    enum IFtso.PriceFinalizationType _lastPriceEpochFinalizationType);\n</code></pre> <p>Returns asset's current price details. All timestamps are in seconds from UNIX epoch.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_priceTimestamp</code> <code>uint256</code> Time when price was updated for the last time. <code>_priceFinalizationType</code> <code>enum IFtso.PriceFinalizationType</code> Finalization type when price was updated for the last time. <code>_lastPriceEpochFinalizationTimestamp</code> <code>uint256</code> Time when last price epoch was finalized. <code>_lastPriceEpochFinalizationType</code> <code>enum IFtso.PriceFinalizationType</code> Finalization type of last finalized price epoch."},{"location":"apis/smart-contracts/IIFtso/#fn_getcurrentpricefromtrustedproviders_af52df08","title":"<code>getCurrentPriceFromTrustedProviders</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getCurrentPriceFromTrustedProviders(\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp);\n</code></pre> <p>Returns current asset price calculated only using input from trusted providers.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Time when price was updated for the last time, in seconds from UNIX epoch."},{"location":"apis/smart-contracts/IIFtso/#fn_getcurrentpricewithdecimals_65f5cd86","title":"<code>getCurrentPriceWithDecimals</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getCurrentPriceWithDecimals(\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals);\n</code></pre> <p>Returns current asset price and number of decimals.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>_assetPriceUsdDecimals</code>. <code>_timestamp</code> <code>uint256</code> Time when price was updated for the last time, in seconds from UNIX epoch. <code>_assetPriceUsdDecimals</code> <code>uint256</code> Number of decimals used to return the USD price."},{"location":"apis/smart-contracts/IIFtso/#fn_getcurrentpricewithdecimalsfromtrustedproviders_3cacb3ae","title":"<code>getCurrentPriceWithDecimalsFromTrustedProviders</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getCurrentPriceWithDecimalsFromTrustedProviders(\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals);\n</code></pre> <p>Returns current asset price calculated only using input from trusted providers and number of decimals.</p> Returns Type Description <code>_price</code> <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Time when price was updated for the last time, in seconds from UNIX epoch. <code>_assetPriceUsdDecimals</code> <code>uint256</code> Number of decimals used to return the USD price."},{"location":"apis/smart-contracts/IIFtso/#fn_getcurrentrandom_d89601fd","title":"<code>getCurrentRandom</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getCurrentRandom(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the random number for the previous price epoch, obtained from the random numbers provided by all data providers along with their data submissions.</p>"},{"location":"apis/smart-contracts/IIFtso/#fn_getepochid_5303548b","title":"<code>getEpochId</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getEpochId(\n    uint256 _timestamp\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the ID of the epoch that was opened for price submission at the specified timestamp.</p> Parameters Type Description <code>_timestamp</code> <code>uint256</code> Queried timestamp in seconds from UNIX epoch. Returns Type Description [0] <code>uint256</code> Epoch ID corresponding to that timestamp. IDs are consecutive numbers starting from zero."},{"location":"apis/smart-contracts/IIFtso/#fn_getepochprice_7d1d6f12","title":"<code>getEpochPrice</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getEpochPrice(\n    uint256 _epochId\n) external view returns (\n    uint256);\n</code></pre> <p>Returns agreed asset price in the specified epoch.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch. Only the last 200 epochs can be queried. Out-of-bounds queries revert. Returns Type Description [0] <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>."},{"location":"apis/smart-contracts/IIFtso/#fn_getepochpriceforvoter_c5d8b9e7","title":"<code>getEpochPriceForVoter</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getEpochPriceForVoter(\n    uint256 _epochId,\n    address _voter\n) external view returns (\n    uint256);\n</code></pre> <p>Returns asset price submitted by a voter in the specified epoch.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch being queried. Only the last 200 epochs can be queried. Out-of-bounds queries revert. <code>_voter</code> <code>address</code> Address of the voter being queried. Returns Type Description [0] <code>uint256</code> Price in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>."},{"location":"apis/smart-contracts/IIFtso/#fn_getpriceepochconfiguration_144e1591","title":"<code>getPriceEpochConfiguration</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getPriceEpochConfiguration(\n) external view returns (\n    uint256 _firstEpochStartTs,\n    uint256 _submitPeriodSeconds,\n    uint256 _revealPeriodSeconds);\n</code></pre> <p>Returns current epoch's configuration.</p> Returns Type Description <code>_firstEpochStartTs</code> <code>uint256</code> First epoch start timestamp in seconds from UNIX epoch. <code>_submitPeriodSeconds</code> <code>uint256</code> Submit period in seconds. <code>_revealPeriodSeconds</code> <code>uint256</code> Reveal period in seconds."},{"location":"apis/smart-contracts/IIFtso/#fn_getpriceepochdata_e3b3a3b3","title":"<code>getPriceEpochData</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getPriceEpochData(\n) external view returns (\n    uint256 _epochId,\n    uint256 _epochSubmitEndTime,\n    uint256 _epochRevealEndTime,\n    uint256 _votePowerBlock,\n    bool _fallbackMode);\n</code></pre> <p>Returns current epoch data. Intervals are open on the right: End times are not included.</p> Returns Type Description <code>_epochId</code> <code>uint256</code> Current epoch ID. <code>_epochSubmitEndTime</code> <code>uint256</code> End time of the price submission window in seconds from UNIX epoch. <code>_epochRevealEndTime</code> <code>uint256</code> End time of the price reveal window in seconds from UNIX epoch. <code>_votePowerBlock</code> <code>uint256</code> Vote power block for the current epoch. <code>_fallbackMode</code> <code>bool</code> Whether the current epoch is in fallback mode. Only votes from trusted addresses are used in this mode."},{"location":"apis/smart-contracts/IIFtso/#fn_getrandom_cd4b6914","title":"<code>getRandom</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function getRandom(\n    uint256 _epochId\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the random number used in a specific past epoch, obtained from the random numbers provided by all data providers along with their data submissions.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the queried epoch. Current epoch cannot be queried, and the previous epoch is constantly updated as data providers reveal their prices and random numbers. Only the last 50 epochs can be queried and there is no bounds checking for this parameter. Out-of-bounds queries return undefined values. Returns Type Description [0] <code>uint256</code> The random number used in that epoch."},{"location":"apis/smart-contracts/IIFtso/#fn_getvoteweightingparameters_8357d08c","title":"<code>getVoteWeightingParameters</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function getVoteWeightingParameters(\n) external view returns (\n    contract IIVPToken[] _assets,\n    uint256[] _assetMultipliers,\n    uint256 _totalVotePowerNat,\n    uint256 _totalVotePowerAsset,\n    uint256 _assetWeightRatio,\n    uint256 _votePowerBlock);\n</code></pre> <p>Returns parameters necessary for replicating vote weighting (used in <code>VoterWhitelister</code>).</p> Returns Type Description <code>_assets</code> <code>contract IIVPToken[]</code> The list of assets that are accounted in vote. <code>_assetMultipliers</code> <code>uint256[]</code> Weight multiplier of each asset in (multiasset) FTSO. <code>_totalVotePowerNat</code> <code>uint256</code> Total native token vote power at block. <code>_totalVotePowerAsset</code> <code>uint256</code> Total combined asset vote power at block. <code>_assetWeightRatio</code> <code>uint256</code> Ratio of combined asset vote power vs. native token vp (in BIPS). <code>_votePowerBlock</code> <code>uint256</code> Vote power block for the epoch."},{"location":"apis/smart-contracts/IIFtso/#fn_initializecurrentepochstateforreveal_f670ebe3","title":"<code>initializeCurrentEpochStateForReveal</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function initializeCurrentEpochStateForReveal(\n    uint256 _circulatingSupplyNat,\n    bool _fallbackMode\n) external;\n</code></pre> <p>Initializes current epoch instance for reveal.</p> Parameters Type Description <code>_circulatingSupplyNat</code> <code>uint256</code> Epoch native token circulating supply. <code>_fallbackMode</code> <code>bool</code> Whether the current epoch is in fallback mode."},{"location":"apis/smart-contracts/IIFtso/#fn_revealpricesubmitter_c1f6c36e","title":"<code>revealPriceSubmitter</code>","text":"<p>Defined in <code>IFtsoGenesis</code> (Docs, Source).</p> <pre><code>function revealPriceSubmitter(\n    address _voter,\n    uint256 _epochId,\n    uint256 _price,\n    uint256 _voterWNatVP\n) external;\n</code></pre> <p>Reveals the price submitted by a voter on a specific epoch. The hash of _price and _random must be equal to the submitted hash</p> Parameters Type Description <code>_voter</code> <code>address</code> Voter address. <code>_epochId</code> <code>uint256</code> ID of the epoch in which the price hash was submitted. <code>_price</code> <code>uint256</code> Submitted price. <code>_voterWNatVP</code> <code>uint256</code> Voter's vote power in <code>WNat</code> units."},{"location":"apis/smart-contracts/IIFtso/#fn_setasset_d0d552dd","title":"<code>setAsset</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function setAsset(\n    contract IIVPToken _asset\n) external;\n</code></pre> <p>Sets asset for FTSO to operate as single-asset oracle.</p> Parameters Type Description <code>_asset</code> <code>contract IIVPToken</code> Address of the <code>IIVPToken</code> contract that will be the asset tracked by this FTSO."},{"location":"apis/smart-contracts/IIFtso/#fn_setassetftsos_131fdee2","title":"<code>setAssetFtsos</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function setAssetFtsos(\n    contract IIFtso[] _assetFtsos\n) external;\n</code></pre> <p>Sets an array of FTSOs for FTSO to operate as multi-asset oracle. FTSOs implicitly determine the FTSO assets.</p> Parameters Type Description <code>_assetFtsos</code> <code>contract IIFtso[]</code> Array of FTSOs."},{"location":"apis/smart-contracts/IIFtso/#fn_setvotepowerblock_e536f396","title":"<code>setVotePowerBlock</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function setVotePowerBlock(\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Sets the current vote power block. Current vote power block will update per reward epoch. The FTSO doesn't have notion of reward epochs.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> Vote power block."},{"location":"apis/smart-contracts/IIFtso/#fn_symbol_95d89b41","title":"<code>symbol</code>","text":"<p>Defined in <code>IFtso</code> (Docs, Source).</p> <pre><code>function symbol(\n) external view returns (\n    string);\n</code></pre> <p>Returns the FTSO <code>symbol</code>.</p>"},{"location":"apis/smart-contracts/IIFtso/#fn_updateinitialprice_306ba253","title":"<code>updateInitialPrice</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function updateInitialPrice(\n    uint256 _initialPriceUSD,\n    uint256 _initialPriceTimestamp\n) external;\n</code></pre> <p>Updates initial asset price when the contract is not <code>active</code> yet.</p>"},{"location":"apis/smart-contracts/IIFtso/#fn_wnat_9edbf007","title":"<code>wNat</code>","text":"<p>Defined in <code>IIFtso</code> (Docs, Source).</p> <pre><code>function wNat(\n) external view returns (\n    contract IIVPToken);\n</code></pre> <p>Address of the <code>WNat</code> contract.</p> Returns Type Description [0] <code>contract IIVPToken</code> Address of the <code>WNat</code> contract."},{"location":"apis/smart-contracts/IIFtso/#fn_wnatvotepowercached_f72cab28","title":"<code>wNatVotePowerCached</code>","text":"<p>Defined in <code>IFtsoGenesis</code> (Docs, Source).</p> <pre><code>function wNatVotePowerCached(\n    address _voter,\n    uint256 _epochId\n) external returns (\n    uint256);\n</code></pre> <p>Get and cache the vote power of a voter on a specific epoch, in <code>WNat</code> units.</p> Parameters Type Description <code>_voter</code> <code>address</code> Voter address. <code>_epochId</code> <code>uint256</code> ID of the epoch in which the price hash was submitted. Returns Type Description [0] <code>uint256</code> Voter's vote power in <code>WNat</code> units."},{"location":"apis/smart-contracts/IIFtsoManager/","title":"IIFtsoManager","text":""},{"location":"apis/smart-contracts/IIFtsoManager/#ct_iiftsomanager","title":"<code>IIFtsoManager</code>","text":"<p>Source | Inherits from IFtsoManager, IFlareDaemonize</p> <p>Internal interface for the <code>FtsoManager</code> contract.</p>"},{"location":"apis/smart-contracts/IIFtsoManager/#events","title":"Events","text":""},{"location":"apis/smart-contracts/IIFtsoManager/#ev_accruingunearnedrewardsfailed","title":"<code>AccruingUnearnedRewardsFailed</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event AccruingUnearnedRewardsFailed(\n    uint256 epochId\n)\n</code></pre> <p>Unexpected failure while accruing unearned rewards. This should be a rare occurrence.</p> Parameters Type Description <code>epochId</code> <code>uint256</code> Epoch ID of the failure."},{"location":"apis/smart-contracts/IIFtsoManager/#ev_chillingnonrevealingdataprovidersfailed","title":"<code>ChillingNonrevealingDataProvidersFailed</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>event ChillingNonrevealingDataProvidersFailed(\n)\n</code></pre> <p>Unexpected failure. This should be a rare occurrence.</p>"},{"location":"apis/smart-contracts/IIFtsoManager/#ev_cleanupblocknumbermanagerfailedforblock","title":"<code>CleanupBlockNumberManagerFailedForBlock</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>event CleanupBlockNumberManagerFailedForBlock(\n    uint256 blockNumber\n)\n</code></pre> <p>Unexpected failure. This should be a rare occurrence.</p>"},{"location":"apis/smart-contracts/IIFtsoManager/#ev_closingexpiredrewardepochfailed","title":"<code>ClosingExpiredRewardEpochFailed</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>event ClosingExpiredRewardEpochFailed(\n    uint256 rewardEpoch\n)\n</code></pre> <p>Unexpected failure. This should be a rare occurrence.</p>"},{"location":"apis/smart-contracts/IIFtsoManager/#ev_distributingrewardsfailed","title":"<code>DistributingRewardsFailed</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event DistributingRewardsFailed(\n    address ftso,\n    uint256 epochId\n)\n</code></pre> <p>Unexpected failure while distributing rewards. This should be a rare occurrence.</p> Parameters Type Description <code>ftso</code> <code>address</code> Contract address of the FTSO where the failure happened. <code>epochId</code> <code>uint256</code> Epoch ID of the failure."},{"location":"apis/smart-contracts/IIFtsoManager/#ev_fallbackmode","title":"<code>FallbackMode</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event FallbackMode(\n    bool fallbackMode\n)\n</code></pre> <p>Emitted when the fallback mode of the FTSO manager changes its state. Fallback mode is a recovery mode, where only data from a trusted subset of FTSO data providers is used to calculate the final price.</p> <p>The FTSO Manager enters the fallback mode when ALL FTSOs are in fallback mode.</p> Parameters Type Description <code>fallbackMode</code> <code>bool</code> New state of the FTSO Manager fallback mode."},{"location":"apis/smart-contracts/IIFtsoManager/#ev_finalizingpriceepochfailed","title":"<code>FinalizingPriceEpochFailed</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event FinalizingPriceEpochFailed(\n    contract IIFtso ftso,\n    uint256 epochId,\n    enum IFtso.PriceFinalizationType failingType\n)\n</code></pre> <p>Unexpected failure while finalizing a price epoch. This should be a rare occurrence.</p> Parameters Type Description <code>ftso</code> <code>contract IIFtso</code> Contract address of the FTSO where the failure happened. <code>epochId</code> <code>uint256</code> Epoch ID of the failure. <code>failingType</code> <code>enum IFtso.PriceFinalizationType</code> How was the epoch finalized."},{"location":"apis/smart-contracts/IIFtsoManager/#ev_ftsoadded","title":"<code>FtsoAdded</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event FtsoAdded(\n    contract IIFtso ftso,\n    bool add\n)\n</code></pre> <p>Emitted when a new FTSO has been added or an existing one has been removed.</p> Parameters Type Description <code>ftso</code> <code>contract IIFtso</code> Contract address of the FTSO. <code>add</code> <code>bool</code> True if added, removed otherwise."},{"location":"apis/smart-contracts/IIFtsoManager/#ev_ftsodeactivationfailed","title":"<code>FtsoDeactivationFailed</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>event FtsoDeactivationFailed(\n    contract IIFtso ftso\n)\n</code></pre> <p>Unexpected failure. This should be a rare occurrence.</p>"},{"location":"apis/smart-contracts/IIFtsoManager/#ev_ftsofallbackmode","title":"<code>FtsoFallbackMode</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event FtsoFallbackMode(\n    contract IIFtso ftso,\n    bool fallbackMode\n)\n</code></pre> <p>Emitted when the fallback mode of an FTSO changes its state.</p> Parameters Type Description <code>ftso</code> <code>contract IIFtso</code> Contract address of the FTSO. <code>fallbackMode</code> <code>bool</code> New state of its fallback mode."},{"location":"apis/smart-contracts/IIFtsoManager/#ev_initializingcurrentepochstateforrevealfailed","title":"<code>InitializingCurrentEpochStateForRevealFailed</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event InitializingCurrentEpochStateForRevealFailed(\n    contract IIFtso ftso,\n    uint256 epochId\n)\n</code></pre> <p>Unexpected failure while initializing a price epoch. This should be a rare occurrence.</p> Parameters Type Description <code>ftso</code> <code>contract IIFtso</code> Contract address of the FTSO where the failure happened. <code>epochId</code> <code>uint256</code> Epoch ID that failed initialization."},{"location":"apis/smart-contracts/IIFtsoManager/#ev_priceepochfinalized","title":"<code>PriceEpochFinalized</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event PriceEpochFinalized(\n    address chosenFtso,\n    uint256 rewardEpochId\n)\n</code></pre> <p>Emitted when a price epoch ends, this is, after the reveal phase, when final prices are calculated.</p> Parameters Type Description <code>chosenFtso</code> <code>address</code> Contract address of the FTSO asset that was randomly chosen to be the basis for reward calculation. On this price epoch, rewards will be calculated based on how close each data provider was to the median of all submitted prices FOR THIS FTSO. <code>rewardEpochId</code> <code>uint256</code> Reward epoch ID this price epoch belongs to."},{"location":"apis/smart-contracts/IIFtsoManager/#ev_rewardepochfinalized","title":"<code>RewardEpochFinalized</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event RewardEpochFinalized(\n    uint256 votepowerBlock,\n    uint256 startBlock\n)\n</code></pre> <p>Emitted when a reward epoch ends and rewards are available.</p> Parameters Type Description <code>votepowerBlock</code> <code>uint256</code> The vote power block of the epoch. <code>startBlock</code> <code>uint256</code> The first block of the epoch."},{"location":"apis/smart-contracts/IIFtsoManager/#ev_updatingactivevalidatorstriggerfailed","title":"<code>UpdatingActiveValidatorsTriggerFailed</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>event UpdatingActiveValidatorsTriggerFailed(\n    uint256 rewardEpoch\n)\n</code></pre> <p>Unexpected failure. This should be a rare occurrence.</p>"},{"location":"apis/smart-contracts/IIFtsoManager/#ev_usegoodrandomset","title":"<code>UseGoodRandomSet</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>event UseGoodRandomSet(\n    bool useGoodRandom,\n    uint256 maxWaitForGoodRandomSeconds\n)\n</code></pre> <p>Emitted when the requirement to provide good random numbers has changed.</p> <p>As part of the FTSO protocol, data providers must submit a random number along with their price reveals. When good random numbers are enforced, all providers that submit a hash must then submit a reveal with a random number or they will be punished. This is a measure against random number manipulation.</p> Parameters Type Description <code>useGoodRandom</code> <code>bool</code> Whether good random numbers are now enforced or not. <code>maxWaitForGoodRandomSeconds</code> <code>uint256</code> Max number of seconds to wait for a good random number to be submitted."},{"location":"apis/smart-contracts/IIFtsoManager/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IIFtsoManager/#fn_activate_0f15f4c0","title":"<code>activate</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function activate(\n) external;\n</code></pre> <p>Activates FTSO manager (<code>daemonize</code> will run jobs).</p>"},{"location":"apis/smart-contracts/IIFtsoManager/#fn_active_02fb0c5e","title":"<code>active</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function active(\n) external view returns (\n    bool);\n</code></pre> <p>Returns whether the FTSO Manager is <code>active</code> or not.</p> Returns Type Description [0] <code>bool</code> bool Active status."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_addftso_2663f1b4","title":"<code>addFtso</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function addFtso(\n    contract IIFtso _ftso\n) external;\n</code></pre> <p>Adds FTSO to the list of managed FTSOs, to support a new price pair. All FTSOs in a multi-asset FTSO must be managed by the same FTSO manager.</p> Parameters Type Description <code>_ftso</code> <code>contract IIFtso</code> FTSO contract address to add."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_addftsosbulk_d429cfe5","title":"<code>addFtsosBulk</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function addFtsosBulk(\n    contract IIFtso[] _ftsos\n) external;\n</code></pre> <p>Adds a list of FTSOs to the list of managed FTSOs, to support new price pairs. All FTSOs in a multi-asset FTSO must be managed by the same FTSO manager.</p> Parameters Type Description <code>_ftsos</code> <code>contract IIFtso[]</code> Array of FTSO contract addresses to add."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_currentrewardepochends_d89c39e6","title":"<code>currentRewardEpochEnds</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function currentRewardEpochEnds(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns when the current reward epoch finishes.</p> Returns Type Description [0] <code>uint256</code> uint256 Time in seconds since the UNIX epoch when the current reward epoch will finish."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_daemonize_6d0e8c34","title":"<code>daemonize</code>","text":"<p>Defined in <code>IFlareDaemonize</code> (Docs, Source).</p> <pre><code>function daemonize(\n) external returns (\n    bool);\n</code></pre> <p>Implement this function to receive a trigger from the <code>FlareDaemon</code>. The trigger method is called by the validator right at the end of block state transition.</p> Returns Type Description [0] <code>bool</code> bool Whether the contract is still active after the call. Currently unused."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_getcontractname_f5f5ba72","title":"<code>getContractName</code>","text":"<p>Defined in <code>IFlareDaemonize</code> (Docs, Source).</p> <pre><code>function getContractName(\n) external view returns (\n    string);\n</code></pre> <p>Implement this function to allow updating daemonized contracts through the <code>AddressUpdater</code>.</p> Returns Type Description [0] <code>string</code> string Contract name."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_getcurrentpriceepochdata_93a79025","title":"<code>getCurrentPriceEpochData</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getCurrentPriceEpochData(\n) external view returns (\n    uint256 _priceEpochId,\n    uint256 _priceEpochStartTimestamp,\n    uint256 _priceEpochEndTimestamp,\n    uint256 _priceEpochRevealEndTimestamp,\n    uint256 _currentTimestamp);\n</code></pre> <p>Returns timing information for the current price epoch. All intervals are half-closed: end time is not included. All timestamps are in seconds since UNIX epoch.</p> <p>See the FTSO page for information about the different submission phases.</p> Returns Type Description <code>_priceEpochId</code> <code>uint256</code> Price epoch ID. <code>_priceEpochStartTimestamp</code> <code>uint256</code> Beginning of the commit phase. <code>_priceEpochEndTimestamp</code> <code>uint256</code> End of the commit phase. <code>_priceEpochRevealEndTimestamp</code> <code>uint256</code> End of the reveal phase. <code>_currentTimestamp</code> <code>uint256</code> Current time."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_getcurrentpriceepochid_08a7f402","title":"<code>getCurrentPriceEpochId</code>","text":"<p>Defined in <code>IFtsoManagerGenesis</code> (Docs, Source).</p> <pre><code>function getCurrentPriceEpochId(\n) external view returns (\n    uint256 _priceEpochId);\n</code></pre> <p>Returns current price epoch ID.</p> Returns Type Description <code>_priceEpochId</code> <code>uint256</code> Currently running epoch ID. IDs are consecutive numbers starting from zero."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_getcurrentrewardepoch_e7c830d4","title":"<code>getCurrentRewardEpoch</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getCurrentRewardEpoch(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns current reward epoch ID (the one currently running).</p> Returns Type Description [0] <code>uint256</code> Reward epoch ID. A monotonically increasing integer."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_getelasticbandwidthppmftso_5bb44e9a","title":"<code>getElasticBandWidthPPMFtso</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function getElasticBandWidthPPMFtso(\n    contract IIFtso _ftso\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the secondary band's width in PPM (parts-per-million) of the median value, for a given FTSO.</p> Parameters Type Description <code>_ftso</code> <code>contract IIFtso</code> The queried FTSO contract address. Returns Type Description [0] <code>uint256</code> uint256 Secondary band width in PPM. To obtain the actual band width, divide this number by 10^6 and multiply by the price median value."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_getfallbackmode_4b48dd5e","title":"<code>getFallbackMode</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getFallbackMode(\n) external view returns (\n    bool _fallbackMode,\n    contract IIFtso[] _ftsos,\n    bool[] _ftsoInFallbackMode);\n</code></pre> <p>Returns whether the FTSO Manager is currently in fallback mode.</p> <p>In this mode only submissions from trusted providers are used.</p> Returns Type Description <code>_fallbackMode</code> <code>bool</code> True if fallback mode is enabled for the manager. <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all currently active FTSO assets. <code>_ftsoInFallbackMode</code> <code>bool[]</code> Boolean array indicating which FTSO assets are in fallback mode. If the FTSO Manager is in fallback mode then ALL FTSOs are in fallback mode."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_getftsos_ce69f833","title":"<code>getFtsos</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getFtsos(\n) external view returns (\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Returns the list of currently <code>active</code> FTSOs.</p> Returns Type Description <code>_ftsos</code> <code>contract IIFtso[]</code> Array of contract addresses for the FTSOs."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_getlastunprocessedpriceepochdata_6ca051e6","title":"<code>getLastUnprocessedPriceEpochData</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function getLastUnprocessedPriceEpochData(\n) external view returns (\n    uint256 _lastUnprocessedPriceEpoch,\n    uint256 _lastUnprocessedPriceEpochRevealEnds,\n    bool _lastUnprocessedPriceEpochInitialized);\n</code></pre> <p>Returns information regarding the currently unprocessed price epoch. This epoch is not necessarily the last one, in case the network halts for some time due to validator node problems, for example.</p> Returns Type Description <code>_lastUnprocessedPriceEpoch</code> <code>uint256</code> ID of the price epoch that is currently waiting finalization. <code>_lastUnprocessedPriceEpochRevealEnds</code> <code>uint256</code> When that price epoch can be finalized, in seconds since UNIX epoch. <code>_lastUnprocessedPriceEpochInitialized</code> <code>bool</code> Whether this price epoch has been already initialized and therefore it must be finalized before the corresponding reward epoch can be finalized."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_getpriceepochconfiguration_144e1591","title":"<code>getPriceEpochConfiguration</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getPriceEpochConfiguration(\n) external view returns (\n    uint256 _firstPriceEpochStartTs,\n    uint256 _priceEpochDurationSeconds,\n    uint256 _revealEpochDurationSeconds);\n</code></pre> <p>Returns the current values for price epoch timing configuration.</p> <p>See the FTSO page for information about the different submission phases.</p> Returns Type Description <code>_firstPriceEpochStartTs</code> <code>uint256</code> Timestamp, in seconds since UNIX epoch, of the first price epoch. <code>_priceEpochDurationSeconds</code> <code>uint256</code> Duration in seconds of the commit phase. <code>_revealEpochDurationSeconds</code> <code>uint256</code> Duration in seconds of the reveal phase."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_getrewardepochconfiguration_1cb513f7","title":"<code>getRewardEpochConfiguration</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochConfiguration(\n) external view returns (\n    uint256 _firstRewardEpochStartTs,\n    uint256 _rewardEpochDurationSeconds);\n</code></pre> <p>Returns the current values for reward epoch timing configuration.</p> <p>See the Reward epochs box.</p> Returns Type Description <code>_firstRewardEpochStartTs</code> <code>uint256</code> Timestamp, in seconds since UNIX epoch, of the first reward epoch. <code>_rewardEpochDurationSeconds</code> <code>uint256</code> Duration in seconds of the reward epochs."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_getrewardepochdata_e5399da3","title":"<code>getRewardEpochData</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochData(\n    uint256 _rewardEpochId\n) external view returns (\n    struct IIFtsoManager.RewardEpochData);\n</code></pre> <p>Returns data regarding a specific reward epoch ID.</p> Parameters Type Description <code>_rewardEpochId</code> <code>uint256</code> Epoch ID. Returns Type Description [0] <code>struct IIFtsoManager.RewardEpochData</code> RewardEpochData Its associated data."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_getrewardepochtoexpirenext_3e7ff857","title":"<code>getRewardEpochToExpireNext</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochToExpireNext(\n) external view returns (\n    uint256);\n</code></pre> <p>Return reward epoch that will expire next, when a new reward epoch is initialized.</p> <p>Reward epochs older than 90 days expire, and any unclaimed rewards in them become inaccessible.</p> Returns Type Description [0] <code>uint256</code> uint256 Reward epoch ID."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_getrewardepochvotepowerblock_f2edab5a","title":"<code>getRewardEpochVotePowerBlock</code>","text":"<p>Defined in <code>IFtsoManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochVotePowerBlock(\n    uint256 _rewardEpoch\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the vote power block that was used for a past reward epoch.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> The queried reward epoch ID. Returns Type Description [0] <code>uint256</code> uint256 The block number of that reward epoch's vote power block."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_getrewardexpiryoffsetseconds_ec31db0c","title":"<code>getRewardExpiryOffsetSeconds</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function getRewardExpiryOffsetSeconds(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the currently configured reward expiration time.</p> Returns Type Description [0] <code>uint256</code> uint256 Unclaimed rewards accrued in reward epochs more than this amount of seconds in the past expire and become inaccessible."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_notinitializedftsos_823033a9","title":"<code>notInitializedFtsos</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function notInitializedFtsos(\n    contract IIFtso\n) external view returns (\n    bool);\n</code></pre> <p>Returns whether an FTSO has been initialized.</p> Returns Type Description [0] <code>bool</code> bool Initialization state."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_removeftso_a670ff87","title":"<code>removeFtso</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function removeFtso(\n    contract IIFtso _ftso\n) external;\n</code></pre> <p>Removes an FTSO from the list of managed FTSOs. Reverts if FTSO is used in a multi-asset FTSO. Deactivates the <code>_ftso</code>.</p> Parameters Type Description <code>_ftso</code> <code>contract IIFtso</code> FTSO contract address to remove."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_replaceftso_3758e679","title":"<code>replaceFtso</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function replaceFtso(\n    contract IIFtso _ftsoToAdd,\n    bool copyCurrentPrice,\n    bool copyAssetOrAssetFtsos\n) external;\n</code></pre> <p>Replaces one FTSO with another with the same symbol. All FTSOs in a multi-asset FTSO must be managed by the same FTSO manager. Deactivates the old FTSO.</p> Parameters Type Description <code>_ftsoToAdd</code> <code>contract IIFtso</code> FTSO contract address to add. An existing FTSO with the same symbol will be removed. <code>copyCurrentPrice</code> <code>bool</code> When true, initializes the new FTSO with the current price of the previous FTSO. <code>copyAssetOrAssetFtsos</code> <code>bool</code> When true, initializes the new FTSO with the current asset or asset FTSOs of the previous FTSO."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_replaceftsosbulk_758ff1da","title":"<code>replaceFtsosBulk</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function replaceFtsosBulk(\n    contract IIFtso[] _ftsosToAdd,\n    bool copyCurrentPrice,\n    bool copyAssetOrAssetFtsos\n) external;\n</code></pre> <p>Replaces a list of FTSOs with other FTSOs with the same symbol. All FTSOs in a multi-asset FTSO must be managed by the same FTSO manager. Deactivates the old FTSOs.</p> Parameters Type Description <code>_ftsosToAdd</code> <code>contract IIFtso[]</code> Array of FTSO contract addresses to add. Every existing FTSO with the same symbols will be removed. <code>copyCurrentPrice</code> <code>bool</code> When true, initializes the new FTSOs with the current price of the previous FTSOs. <code>copyAssetOrAssetFtsos</code> <code>bool</code> When true, initializes the new FTSOs with the current asset or asset FTSOs of the previous FTSOs."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_rewardepochdurationseconds_85f3c9c9","title":"<code>rewardEpochDurationSeconds</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function rewardEpochDurationSeconds(\n) external view returns (\n    uint256);\n</code></pre> <p>Currently configured reward epoch duration.</p> Returns Type Description [0] <code>uint256</code> uint256 Reward epoch duration, in seconds."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_rewardepochs_a795f409","title":"<code>rewardEpochs</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function rewardEpochs(\n    uint256 _rewardEpochId\n) external view returns (\n    uint256 _votepowerBlock,\n    uint256 _startBlock,\n    uint256 _startTimestamp);\n</code></pre> <p>Returns information about a reward epoch.</p> Parameters Type Description <code>_rewardEpochId</code> <code>uint256</code> The epoch ID to query. Returns Type Description <code>_votepowerBlock</code> <code>uint256</code> The vote power block of the epoch. <code>_startBlock</code> <code>uint256</code> The first block of the epoch. <code>_startTimestamp</code> <code>uint256</code> Timestamp of the epoch start, in seconds since UNIX epoch."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_rewardepochsstartts_a578f55b","title":"<code>rewardEpochsStartTs</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function rewardEpochsStartTs(\n) external view returns (\n    uint256);\n</code></pre> <p>Time when the current reward epoch started.</p> Returns Type Description [0] <code>uint256</code> uint256 Timestamp, in seconds since UNIX epoch."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_setfallbackmode_ff882fbb","title":"<code>setFallbackMode</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function setFallbackMode(\n    bool _fallbackMode\n) external;\n</code></pre> <p>Sets whether the FTSO Manager is currently in fallback mode. In this mode only submissions from trusted providers are used.</p> Parameters Type Description <code>_fallbackMode</code> <code>bool</code> True if fallback mode is enabled."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_setftsoasset_6b65cc34","title":"<code>setFtsoAsset</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function setFtsoAsset(\n    contract IIFtso _ftso,\n    contract IIVPToken _asset\n) external;\n</code></pre> <p>Sets the asset tracked by an FTSO.</p> Parameters Type Description <code>_ftso</code> <code>contract IIFtso</code> The FTSO contract address. <code>_asset</code> <code>contract IIVPToken</code> The <code>VPToken</code> contract address of the asset to track."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_setftsoassetftsos_a93a6f42","title":"<code>setFtsoAssetFtsos</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function setFtsoAssetFtsos(\n    contract IIFtso _ftso,\n    contract IIFtso[] _assetFtsos\n) external;\n</code></pre> <p>Sets an array of FTSOs to be tracked by a multi-asset FTSO. FTSOs implicitly determine the FTSO assets.</p> Parameters Type Description <code>_ftso</code> <code>contract IIFtso</code> The multi-asset FTSO contract address. <code>_assetFtsos</code> <code>contract IIFtso[]</code> Array of FTSOs to be tracked."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_setftsofallbackmode_af946af7","title":"<code>setFtsoFallbackMode</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function setFtsoFallbackMode(\n    contract IIFtso _ftso,\n    bool _fallbackMode\n) external;\n</code></pre> <p>Sets whether an FTSO is currently in fallback mode. In this mode only submissions from trusted providers are used.</p> Parameters Type Description <code>_ftso</code> <code>contract IIFtso</code> The FTSO contract address. <code>_fallbackMode</code> <code>bool</code> Fallback mode."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_setgovernanceparameters_13226793","title":"<code>setGovernanceParameters</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function setGovernanceParameters(\n    uint256 _updateTs,\n    uint256 _maxVotePowerNatThresholdFraction,\n    uint256 _maxVotePowerAssetThresholdFraction,\n    uint256 _lowAssetUSDThreshold,\n    uint256 _highAssetUSDThreshold,\n    uint256 _highAssetTurnoutThresholdBIPS,\n    uint256 _lowNatTurnoutThresholdBIPS,\n    uint256 _elasticBandRewardBIPS,\n    uint256 _rewardExpiryOffsetSeconds,\n    address[] _trustedAddresses\n) external;\n</code></pre> <p>Sets governance parameters for FTSOs</p> Parameters Type Description <code>_updateTs</code> <code>uint256</code> Time, in seconds since UNIX epoch, when updated settings should be pushed to FTSOs. <code>_maxVotePowerNatThresholdFraction</code> <code>uint256</code> High threshold for native token vote power per voter. <code>_maxVotePowerAssetThresholdFraction</code> <code>uint256</code> High threshold for asset vote power per voter <code>_lowAssetUSDThreshold</code> <code>uint256</code> Threshold for low asset vote power (in scaled USD). <code>_highAssetUSDThreshold</code> <code>uint256</code> Threshold for high asset vote power (in scaled USD). <code>_highAssetTurnoutThresholdBIPS</code> <code>uint256</code> Threshold for high asset turnout (in BIPS). <code>_lowNatTurnoutThresholdBIPS</code> <code>uint256</code> Threshold for low nat turnout (in BIPS). <code>_elasticBandRewardBIPS</code> <code>uint256</code> Secondary reward band, where _elasticBandRewardBIPS goes to the secondary band and 10000 - _elasticBandRewardBIPS to the primary (IQR) band. <code>_rewardExpiryOffsetSeconds</code> <code>uint256</code> Reward epochs closed earlier than block.timestamp - _rewardExpiryOffsetSeconds expire. <code>_trustedAddresses</code> <code>address[]</code> Trusted addresses will be used as a fallback mechanism for setting the price."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_setinitialrewarddata_e080a970","title":"<code>setInitialRewardData</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>function setInitialRewardData(\n    uint256 _nextRewardEpochToExpire,\n    uint256 _rewardEpochsLength,\n    uint256 _currentRewardEpochEnds\n) external;\n</code></pre> <p>Set reward data to values from old ftso manager. Can only be called before activation.</p> Parameters Type Description <code>_nextRewardEpochToExpire</code> <code>uint256</code> See <code>getRewardEpochToExpireNext</code>. <code>_rewardEpochsLength</code> <code>uint256</code> See <code>getRewardEpochConfiguration</code>. <code>_currentRewardEpochEnds</code> <code>uint256</code> See <code>getCurrentRewardEpoch</code>."},{"location":"apis/smart-contracts/IIFtsoManager/#fn_switchtofallbackmode_e22fdece","title":"<code>switchToFallbackMode</code>","text":"<p>Defined in <code>IFlareDaemonize</code> (Docs, Source).</p> <pre><code>function switchToFallbackMode(\n) external returns (\n    bool);\n</code></pre> <p>This function will be called after an error is caught in <code>daemonize</code>. It will switch the contract to a simpler fallback mode, which hopefully works when full mode doesn't. Not every contract needs to support fallback mode (<code>FtsoManager</code> does), so this method may be empty. Switching back to normal mode is left to the contract (typically a governed method call). This function may be called due to low-gas error, so it shouldn't use more than ~30.000 gas.</p> Returns Type Description [0] <code>bool</code> True if switched to fallback mode, false if already in fallback mode or if fallback mode is not supported."},{"location":"apis/smart-contracts/IIFtsoManager/#structures","title":"Structures","text":""},{"location":"apis/smart-contracts/IIFtsoManager/#st_rewardepochdata","title":"<code>RewardEpochData</code>","text":"<p>Defined in <code>IIFtsoManager</code> (Docs, Source).</p> <pre><code>struct RewardEpochData {\n  uint256 votepowerBlock;\n  uint256 startBlock;\n  uint256 startTimestamp;\n}\n</code></pre>"},{"location":"apis/smart-contracts/IIFtsoRegistry/","title":"IIFtsoRegistry","text":""},{"location":"apis/smart-contracts/IIFtsoRegistry/#ct_iiftsoregistry","title":"<code>IIFtsoRegistry</code>","text":"<p>Source | Inherits from IFtsoRegistry</p> <p>Internal interface for the <code>FtsoRegistry</code> contract.</p>"},{"location":"apis/smart-contracts/IIFtsoRegistry/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_addftso_2663f1b4","title":"<code>addFtso</code>","text":"<p>Defined in <code>IIFtsoRegistry</code> (Docs, Source).</p> <pre><code>function addFtso(\n    contract IIFtso _ftsoContract\n) external returns (\n    uint256);\n</code></pre> <p>Add a new FTSO contract to the registry.</p> Parameters Type Description <code>_ftsoContract</code> <code>contract IIFtso</code> New target FTSO contract. Returns Type Description [0] <code>uint256</code> The FTSO index assigned to the new asset."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getallcurrentprices_58f9296f","title":"<code>getAllCurrentPrices</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getAllCurrentPrices(\n) external view returns (\n    struct IFtsoRegistry.PriceInfo[]);\n</code></pre> <p>Returns the current price of all supported assets.</p> Returns Type Description [0] <code>struct IFtsoRegistry.PriceInfo[]</code> Array of <code>PriceInfo</code> structures."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getcurrentprice_c55d0f56","title":"<code>getCurrentPrice</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPrice(\n    uint256 _ftsoIndex\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp);\n</code></pre> <p>Public view function to get the current price of a given active FTSO index. Reverts if the index is not supported.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Index to query. Returns Type Description <code>_price</code> <code>uint256</code> Current price of the asset in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Timestamp for when this price was updated, in seconds since UNIX epoch."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getcurrentprice_42a0f243","title":"<code>getCurrentPrice</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPrice(\n    string _symbol\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp);\n</code></pre> <p>Public view function to get the current price of a given active asset symbol. Reverts if the symbol is not supported.</p> Parameters Type Description <code>_symbol</code> <code>string</code> Symbol to query. Returns Type Description <code>_price</code> <code>uint256</code> Current price of the asset in USD multiplied by 10^<code>ASSET_PRICE_USD_DECIMALS</code>. <code>_timestamp</code> <code>uint256</code> Timestamp for when this price was updated, in seconds since UNIX epoch."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getcurrentpricewithdecimals_257cbd3a","title":"<code>getCurrentPriceWithDecimals</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPriceWithDecimals(\n    uint256 _assetIndex\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals);\n</code></pre> <p>Public view function to get the current price and decimals of a given active FTSO index. Reverts if the index is not supported.</p> Parameters Type Description <code>_assetIndex</code> <code>uint256</code> Index to query. Returns Type Description <code>_price</code> <code>uint256</code> Current price of the asset in USD multiplied by 10^<code>_assetPriceUsdDecimals</code>. <code>_timestamp</code> <code>uint256</code> Timestamp for when this price was updated, in seconds since UNIX epoch. <code>_assetPriceUsdDecimals</code> <code>uint256</code> Number of decimals used to return the <code>_price</code>."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getcurrentpricewithdecimals_a69afdc6","title":"<code>getCurrentPriceWithDecimals</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPriceWithDecimals(\n    string _symbol\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals);\n</code></pre> <p>Public view function to get the current price and decimals of a given active asset symbol. Reverts if the symbol is not supported.</p> Parameters Type Description <code>_symbol</code> <code>string</code> Symbol to query. Returns Type Description <code>_price</code> <code>uint256</code> Current price of the asset in USD multiplied by 10^<code>_assetPriceUsdDecimals</code>. <code>_timestamp</code> <code>uint256</code> Timestamp for when this price was updated, in seconds since UNIX epoch. <code>_assetPriceUsdDecimals</code> <code>uint256</code> Number of decimals used to return the <code>_price</code>."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getcurrentpricesbyindices_6ba31fa1","title":"<code>getCurrentPricesByIndices</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPricesByIndices(\n    uint256[] _indices\n) external view returns (\n    struct IFtsoRegistry.PriceInfo[]);\n</code></pre> <p>Returns the current price of a list of indices. Reverts if any of the indices is not supported.</p> Parameters Type Description <code>_indices</code> <code>uint256[]</code> Array of indices to query. Returns Type Description [0] <code>struct IFtsoRegistry.PriceInfo[]</code> Array of <code>PriceInfo</code> structures."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getcurrentpricesbysymbols_79d5ea4b","title":"<code>getCurrentPricesBySymbols</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getCurrentPricesBySymbols(\n    string[] _symbols\n) external view returns (\n    struct IFtsoRegistry.PriceInfo[]);\n</code></pre> <p>Returns the current price of a list of asset symbols. Reverts if any of the symbols is not supported.</p> Parameters Type Description <code>_symbols</code> <code>string[]</code> Array of symbols to query. Returns Type Description [0] <code>struct IFtsoRegistry.PriceInfo[]</code> Array of <code>PriceInfo</code> structures."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getftso_d75f6d81","title":"<code>getFtso</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getFtso(\n    uint256 _activeFtso\n) external view returns (\n    contract IIFtso _activeFtsoAddress);\n</code></pre> <p>Returns the address of the FTSO contract for a given index. Reverts if unsupported index is passed.</p> Parameters Type Description <code>_activeFtso</code> <code>uint256</code> The queried index. Returns Type Description <code>_activeFtsoAddress</code> <code>contract IIFtso</code> FTSO contract address for the queried index."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getftsobysymbol_97da6af4","title":"<code>getFtsoBySymbol</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getFtsoBySymbol(\n    string _symbol\n) external view returns (\n    contract IIFtso _activeFtsoAddress);\n</code></pre> <p>Returns the address of the FTSO contract for a given symbol. Reverts if unsupported symbol is passed.</p> Parameters Type Description <code>_symbol</code> <code>string</code> The queried symbol. Returns Type Description <code>_activeFtsoAddress</code> <code>contract IIFtso</code> FTSO contract address for the queried symbol."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getftsoindex_e848da30","title":"<code>getFtsoIndex</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getFtsoIndex(\n    string _symbol\n) external view returns (\n    uint256 _assetIndex);\n</code></pre> <p>Returns the FTSO index corresponding to a given asset symbol. Reverts if the symbol is not supported.</p> Parameters Type Description <code>_symbol</code> <code>string</code> Symbol to query. Returns Type Description <code>_assetIndex</code> <code>uint256</code> The corresponding asset index."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getftsosymbol_136d3f64","title":"<code>getFtsoSymbol</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getFtsoSymbol(\n    uint256 _ftsoIndex\n) external view returns (\n    string _symbol);\n</code></pre> <p>Returns the asset symbol corresponding to a given FTSO index. Reverts if the index is not supported.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Index to query. Returns Type Description <code>_symbol</code> <code>string</code> The corresponding asset symbol."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getftsos_9cb47538","title":"<code>getFtsos</code>","text":"<p>Defined in <code>IFtsoRegistryGenesis</code> (Docs, Source).</p> <pre><code>function getFtsos(\n    uint256[] _indices\n) external view returns (\n    contract IFtsoGenesis[] _ftsos);\n</code></pre> <p>Get the addresses of the active FTSOs at the given indices. Reverts if any of the provided indices is non-existing or inactive.</p> Parameters Type Description <code>_indices</code> <code>uint256[]</code> Array of FTSO indices to query. Returns Type Description <code>_ftsos</code> <code>contract IFtsoGenesis[]</code> The array of FTSO addresses."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getsupportedftsos_a40060ba","title":"<code>getSupportedFtsos</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedFtsos(\n) external view returns (\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Get array of all FTSO contracts for all supported asset indices. The index of FTSO in returned array does not necessarily correspond to the asset's index. Due to deletion, some indices might be unsupported.</p> <p>Use <code>getSupportedIndicesAndFtsos</code> to retrieve pairs of correct indices and FTSOs, where possible \"null\" holes are readily apparent.</p> Returns Type Description <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all supported FTSOs."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getsupportedindices_798aac5b","title":"<code>getSupportedIndices</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedIndices(\n) external view returns (\n    uint256[] _supportedIndices);\n</code></pre> <p>Returns the indices of the currently supported FTSOs. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of all active FTSO indices in increasing order."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getsupportedindicesandftsos_06a2ba29","title":"<code>getSupportedIndicesAndFtsos</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedIndicesAndFtsos(\n) external view returns (\n    uint256[] _supportedIndices,\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Get all supported indices and corresponding FTSO addresses. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of all supported indices. <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all supported FTSO addresses."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getsupportedindicesandsymbols_e68f283b","title":"<code>getSupportedIndicesAndSymbols</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedIndicesAndSymbols(\n) external view returns (\n    uint256[] _supportedIndices,\n    string[] _supportedSymbols);\n</code></pre> <p>Get all supported indices and corresponding symbols. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of all supported indices. <code>_supportedSymbols</code> <code>string[]</code> Array of all supported symbols."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getsupportedindicessymbolsandftsos_7687542c","title":"<code>getSupportedIndicesSymbolsAndFtsos</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedIndicesSymbolsAndFtsos(\n) external view returns (\n    uint256[] _supportedIndices,\n    string[] _supportedSymbols,\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Get all supported indices, symbols, and corresponding FTSO addresses. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of all supported indices. <code>_supportedSymbols</code> <code>string[]</code> Array of all supported symbols. <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all supported FTSO addresses."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getsupportedsymbols_ce1c0e4d","title":"<code>getSupportedSymbols</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedSymbols(\n) external view returns (\n    string[] _supportedSymbols);\n</code></pre> <p>Returns the symbols of the currently supported FTSOs. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedSymbols</code> <code>string[]</code> Array of all active FTSO symbols in increasing order."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_getsupportedsymbolsandftsos_0cf48497","title":"<code>getSupportedSymbolsAndFtsos</code>","text":"<p>Defined in <code>IFtsoRegistry</code> (Docs, Source).</p> <pre><code>function getSupportedSymbolsAndFtsos(\n) external view returns (\n    string[] _supportedSymbols,\n    contract IIFtso[] _ftsos);\n</code></pre> <p>Get all supported symbols and corresponding FTSO addresses. Active FTSOs are ones that currently receive price feeds.</p> Returns Type Description <code>_supportedSymbols</code> <code>string[]</code> Array of all supported symbols. <code>_ftsos</code> <code>contract IIFtso[]</code> Array of all supported FTSO addresses."},{"location":"apis/smart-contracts/IIFtsoRegistry/#fn_removeftso_a670ff87","title":"<code>removeFtso</code>","text":"<p>Defined in <code>IIFtsoRegistry</code> (Docs, Source).</p> <pre><code>function removeFtso(\n    contract IIFtso _ftso\n) external;\n</code></pre> <p>Removes the FTSO and keeps part of the history. Reverts if the provided address is not supported.</p> <p>From now on, the index this asset was using is \"reserved\" and cannot be used again. It will not be returned in any list of currently supported assets.</p> Parameters Type Description <code>_ftso</code> <code>contract IIFtso</code> Address of the FTSO contract to remove."},{"location":"apis/smart-contracts/IIFtsoRewardManager/","title":"IIFtsoRewardManager","text":""},{"location":"apis/smart-contracts/IIFtsoRewardManager/#ct_iiftsorewardmanager","title":"<code>IIFtsoRewardManager</code>","text":"<p>Source | Inherits from IFtsoRewardManager, IIInflationReceiver, IITokenPool</p> <p>Internal interface for the <code>FtsoRewardManager</code>.</p>"},{"location":"apis/smart-contracts/IIFtsoRewardManager/#events","title":"Events","text":""},{"location":"apis/smart-contracts/IIFtsoRewardManager/#ev_dailyauthorizedinflationset","title":"<code>DailyAuthorizedInflationSet</code>","text":"<p>Defined in <code>IIFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event DailyAuthorizedInflationSet(\n    uint256 authorizedAmountWei\n)\n</code></pre> <p>Emitted when the contract's daily authorized inflation has been set.</p> Parameters Type Description <code>authorizedAmountWei</code> <code>uint256</code> Authorized amount of native tokens, in wei."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#ev_feepercentagechanged","title":"<code>FeePercentageChanged</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event FeePercentageChanged(\n    address dataProvider,\n    uint256 value,\n    uint256 validFromEpoch\n)\n</code></pre> <p>Emitted when a data provider changes its fee.</p> Parameters Type Description <code>dataProvider</code> <code>address</code> Address of the data provider. <code>value</code> <code>uint256</code> New fee, in BIPS. <code>validFromEpoch</code> <code>uint256</code> Epoch ID where the new fee takes effect."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#ev_ftsorewardmanageractivated","title":"<code>FtsoRewardManagerActivated</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event FtsoRewardManagerActivated(\n    address ftsoRewardManager\n)\n</code></pre> <p>Emitted when the reward manager contract is activated.</p> Parameters Type Description <code>ftsoRewardManager</code> <code>address</code> The reward manager contract."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#ev_ftsorewardmanagerdeactivated","title":"<code>FtsoRewardManagerDeactivated</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event FtsoRewardManagerDeactivated(\n    address ftsoRewardManager\n)\n</code></pre> <p>Emitted when the reward manager contract is deactivated.</p> Parameters Type Description <code>ftsoRewardManager</code> <code>address</code> The reward manager contract."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#ev_inflationreceived","title":"<code>InflationReceived</code>","text":"<p>Defined in <code>IIFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event InflationReceived(\n    uint256 amountReceivedWei\n)\n</code></pre> <p>Emitted when the contract has received the daily inflation amount.</p> Parameters Type Description <code>amountReceivedWei</code> <code>uint256</code> Received amount of native tokens, in wei."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#ev_rewardclaimed","title":"<code>RewardClaimed</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event RewardClaimed(\n    address dataProvider,\n    address whoClaimed,\n    address sentTo,\n    uint256 rewardEpoch,\n    uint256 amount\n)\n</code></pre> <p>Emitted when a data provider claims its FTSO rewards.</p> Parameters Type Description <code>dataProvider</code> <code>address</code> Address of the data provider that accrued the reward. <code>whoClaimed</code> <code>address</code> Address that actually performed the claim. <code>sentTo</code> <code>address</code> Address that received the reward. <code>rewardEpoch</code> <code>uint256</code> ID of the reward epoch where the reward was accrued. <code>amount</code> <code>uint256</code> Amount of rewarded native tokens (wei)."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#ev_rewardclaimsenabled","title":"<code>RewardClaimsEnabled</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event RewardClaimsEnabled(\n    uint256 rewardEpochId\n)\n</code></pre> <p>Emitted when reward claims have been enabled.</p> Parameters Type Description <code>rewardEpochId</code> <code>uint256</code> First claimable reward epoch."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#ev_rewardclaimsexpired","title":"<code>RewardClaimsExpired</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event RewardClaimsExpired(\n    uint256 rewardEpochId\n)\n</code></pre> <p>Unclaimed rewards have expired and are now inaccessible.</p> <p><code>getUnclaimedReward()</code> can be used to retrieve more information.</p> Parameters Type Description <code>rewardEpochId</code> <code>uint256</code> ID of the reward epoch that has just expired."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#ev_rewardsburned","title":"<code>RewardsBurned</code>","text":"<p>Defined in <code>IIFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event RewardsBurned(\n    uint256 amountBurnedWei\n)\n</code></pre> <p>Emitted when unclaimed rewards are burned.</p> Parameters Type Description <code>amountBurnedWei</code> <code>uint256</code> Burned amount of native tokens, in wei."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#ev_rewardsdistributed","title":"<code>RewardsDistributed</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event RewardsDistributed(\n    address ftso,\n    uint256 epochId,\n    address[] addresses,\n    uint256[] rewards\n)\n</code></pre> <p>Emitted every price epoch, when rewards have been distributed to each contributing data provider. Note that rewards are not claimable until the reward epoch finishes.</p> Parameters Type Description <code>ftso</code> <code>address</code> Address of the FTSO that generated the rewards. <code>epochId</code> <code>uint256</code> ID of the reward epoch where the rewards were accrued. <code>addresses</code> <code>address[]</code> Data provider addresses that have rewards to claim. <code>rewards</code> <code>uint256[]</code> Amounts available for claiming (wei)."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#ev_unearnedrewardsaccrued","title":"<code>UnearnedRewardsAccrued</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>event UnearnedRewardsAccrued(\n    uint256 epochId,\n    uint256 reward\n)\n</code></pre> <p>Emitted when rewards cannot be distributed during a reward epoch (for example, because the FTSO went into fallback mode) and they are accrued for later burning.</p> Parameters Type Description <code>epochId</code> <code>uint256</code> ID of the reward epoch where the reward was accrued. <code>reward</code> <code>uint256</code> Total amount of accrued rewards (wei)."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_accrueunearnedrewards_67dcac53","title":"<code>accrueUnearnedRewards</code>","text":"<p>Defined in <code>IIFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function accrueUnearnedRewards(\n    uint256 epochId,\n    uint256 priceEpochDurationSeconds,\n    uint256 priceEpochEndTime\n) external;\n</code></pre> <p>Accrue unearned rewards for a given price epoch. Typically done when the FTSO is in fallback mode or because of insufficient vote power. Simply accrue them so they will not be distributed and will be burned later.</p> <p>The amount of rewards that will be burned is calculated in the same way as in <code>distributeRewards</code>.</p> Parameters Type Description <code>epochId</code> <code>uint256</code> Price epoch ID. <code>priceEpochDurationSeconds</code> <code>uint256</code> Duration of price epochs (180s). <code>priceEpochEndTime</code> <code>uint256</code> Timestamp of the price epoch end time (end of submit period), in seconds since UNIX epoch."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_activate_0f15f4c0","title":"<code>activate</code>","text":"<p>Defined in <code>IIFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function activate(\n) external;\n</code></pre> <p>Activates reward manager (allows claiming rewards).</p>"},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_active_02fb0c5e","title":"<code>active</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function active(\n) external view returns (\n    bool);\n</code></pre> <p>Whether rewards can be claimed from this reward manager.</p>"},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_autoclaim_8dc305fa","title":"<code>autoClaim</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function autoClaim(\n    address[] _rewardOwners,\n    uint256 _rewardEpoch\n) external;\n</code></pre> <p>Allows claiming rewards simultaneously for a list of reward owners and all unclaimed epochs before the specified one.</p> <p>This is meant as a convenience all-in-one reward claiming method to be used both by reward owners and registered executors. It performs a series of operations, besides claiming rewards:</p> <ul> <li> <p>If a reward owner has enabled its Personal Delegation Account, rewards are also claimed for the PDA and the total claimed amount is sent to that PDA. Otherwise, the claimed amount is sent to the reward owner's account.</p> </li> <li> <p>Claimed amount is automatically wrapped through the <code>WNat</code> contract.</p> </li> <li> <p>If the caller is a registered executor with a non-zero fee, the fee is paid to the executor for each claimed address.</p> </li> </ul> Parameters Type Description <code>_rewardOwners</code> <code>address[]</code> List of reward owners to claim for. <code>_rewardEpoch</code> <code>uint256</code> Last reward epoch ID to claim for. All previous epochs with pending rewards will be claimed too."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_claim_b2c12192","title":"<code>claim</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function claim(\n    address _rewardOwner,\n    address payable _recipient,\n    uint256 _rewardEpoch,\n    bool _wrap\n) external returns (\n    uint256 _rewardAmount);\n</code></pre> <p>Allows the caller to <code>claim</code> rewards for a reward owner. The caller does not have to be the owner of the rewards, but must be approved by the owner to <code>claim</code> on his behalf by using <code>setClaimExecutors</code> on the <code>claimSetupManager</code>.</p> <p>This function is intended to be used to <code>claim</code> rewards in case of delegation by percentage. Reverts if <code>msg.sender</code> is delegating by amount.</p> <p>Anybody can call this method, but rewards can only be sent to the reward owner, therefore no funds can be stolen. However, by limiting the authorized callers, the owner can control the timing of the calls.</p> <p>When the reward owner is the caller, rewards can be sent to any recipient set by <code>setAllowedClaimRecipients</code> on the <code>claimSetupManager</code>. The reward owner's Personal Delegation Account is always an authorized recipient.</p> Parameters Type Description <code>_rewardOwner</code> <code>address</code> Address of the reward owner. <code>_recipient</code> <code>address payable</code> Address to transfer claimed rewards to. <code>_rewardEpoch</code> <code>uint256</code> Last reward epoch to claim for. All previous epochs with pending rewards will be claimed too. <code>_wrap</code> <code>bool</code> Whether claimed rewards should be wrapped through the <code>WNat</code> contract before transferring them to the <code>_recipient</code>. This parameter is offered as a convenience. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Total amount of claimed rewards (wei)."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_claimfromdataproviders_21bb25af","title":"<code>claimFromDataProviders</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function claimFromDataProviders(\n    address _rewardOwner,\n    address payable _recipient,\n    uint256[] _rewardEpochs,\n    address[] _dataProviders,\n    bool _wrap\n) external returns (\n    uint256 _rewardAmount);\n</code></pre> <p>Allows the caller to <code>claim</code> rewards for a reward owner from specific data providers. The caller does not have to be the owner of the rewards, but must be approved by the owner to <code>claim</code> on his behalf by using <code>setClaimExecutors</code> on the <code>claimSetupManager</code>.</p> <p>This function is intended to be used to <code>claim</code> rewards in case of delegation by amount (explicit delegation). Reverts if <code>msg.sender</code> is delegating by percentage.</p> <p>Anybody can call this method, but rewards can only be sent to the reward owner, therefore no funds can be stolen. However, by limiting the authorized callers, the owner can control the timing of the calls.</p> <p>When the reward owner is the caller, rewards can be sent to any recipient set by <code>setAllowedClaimRecipients</code> on the <code>claimSetupManager</code>. The reward owner's Personal Delegation Account is always an authorized recipient.</p> Parameters Type Description <code>_rewardOwner</code> <code>address</code> Address of the reward owner. <code>_recipient</code> <code>address payable</code> Address to transfer claimed rewards to. <code>_rewardEpochs</code> <code>uint256[]</code> Array of reward epoch IDs to claim for. <code>_dataProviders</code> <code>address[]</code> Array of addresses of the data providers to claim the reward from. <code>_wrap</code> <code>bool</code> Whether claimed rewards should be wrapped through the <code>WNat</code> contract before transferring them to the <code>_recipient</code>. This parameter is offered as a convenience. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Total amount of claimed rewards (wei)."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_claimreward_b2af870a","title":"<code>claimReward</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function claimReward(\n    address payable _recipient,\n    uint256[] _rewardEpochs\n) external returns (\n    uint256 _rewardAmount);\n</code></pre> <p>Allows a percentage delegator to <code>claim</code> rewards. This function is intended to be used to <code>claim</code> rewards in case of delegation by percentage.</p> <p>This function is deprecated: use <code>claim</code> instead.</p> <p>Reverts if <code>msg.sender</code> is delegating by amount. Claims for all unclaimed reward epochs to the 'max(_rewardEpochs)'. Retained for backward compatibility.</p> Parameters Type Description <code>_recipient</code> <code>address payable</code> Address to transfer funds to. <code>_rewardEpochs</code> <code>uint256[]</code> Array of reward epoch numbers to claim for. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Amount of total claimed rewards (wei)."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_claimrewardfromdataproviders_d20bb542","title":"<code>claimRewardFromDataProviders</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function claimRewardFromDataProviders(\n    address payable _recipient,\n    uint256[] _rewardEpochs,\n    address[] _dataProviders\n) external returns (\n    uint256 _rewardAmount);\n</code></pre> <p>Allows the caller to <code>claim</code> rewards from specific data providers. This function is intended to be used to <code>claim</code> rewards in case of delegation by amount.</p> <p>This function is deprecated: use <code>claimFromDataProviders</code> instead.</p> Parameters Type Description <code>_recipient</code> <code>address payable</code> Address to transfer funds to. <code>_rewardEpochs</code> <code>uint256[]</code> Array of reward epoch numbers to claim for. <code>_dataProviders</code> <code>address[]</code> Array of addresses of the data providers to claim the reward from. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Total amount of claimed rewards (wei)."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_closeexpiredrewardepoch_d6c1dbee","title":"<code>closeExpiredRewardEpoch</code>","text":"<p>Defined in <code>IIFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function closeExpiredRewardEpoch(\n    uint256 _rewardEpochId\n) external;\n</code></pre> <p>Collects funds from expired reward epoch and calculates totals.</p> <p>Triggered by ftsoManager on finalization of a reward epoch. Operation is irreversible: when some reward epoch is closed according to current settings, it cannot be reopened even if new parameters would allow it, because <code>nextRewardEpochToExpire</code> in ftsoManager never decreases.</p> Parameters Type Description <code>_rewardEpochId</code> <code>uint256</code> ID of the epoch to close."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_deactivate_51b42b00","title":"<code>deactivate</code>","text":"<p>Defined in <code>IIFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function deactivate(\n) external;\n</code></pre> <p>Deactivates reward manager (prevents claiming rewards).</p>"},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_distributerewards_a9b79e17","title":"<code>distributeRewards</code>","text":"<p>Defined in <code>IIFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function distributeRewards(\n    address[] addresses,\n    uint256[] weights,\n    uint256 totalWeight,\n    uint256 epochId,\n    address ftso,\n    uint256 priceEpochDurationSeconds,\n    uint256 currentRewardEpoch,\n    uint256 priceEpochEndTime,\n    uint256 votePowerBlock\n) external;\n</code></pre> <p>Distributes price epoch rewards to data provider accounts, according to input parameters. Must be called with <code>totalWeight</code> &gt; 0 and <code>addresses.length</code> &gt; 0.</p> <p>The amount of rewards for a given price epoch ID are calculated in <code>FtsoRewardManager</code> from <code>priceEpochDurationSeconds</code>, <code>priceEpochEndTime</code> and inflation authorization data (see <code>_getTotalPriceEpochRewardWei</code> in <code>FtsoRewardManager</code>. Then each data provider address is given a portion of this amount according to corresponding weight and total sum of weights.</p> <p>Parameters <code>epochId</code> and <code>ftso</code> are only needed so they can be passed onto the emitted event.</p> Parameters Type Description <code>addresses</code> <code>address[]</code> Data provider addresses to reward. <code>weights</code> <code>uint256[]</code> Weights corresponding to rewarded addresses. <code>totalWeight</code> <code>uint256</code> Sum of all weights. <code>epochId</code> <code>uint256</code> Price epoch ID. <code>ftso</code> <code>address</code> Randomly chosen FTSO contract used to calculate the weights. <code>priceEpochDurationSeconds</code> <code>uint256</code> Duration of price epochs (180s). <code>currentRewardEpoch</code> <code>uint256</code> ID of the current reward epoch. Rewards for the price epoch are added to this reward epoch. <code>priceEpochEndTime</code> <code>uint256</code> Timestamp of the price epoch end time (end of submit period), in seconds since UNIX epoch. <code>votePowerBlock</code> <code>uint256</code> Vote power block used in the given reward epoch."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_enableclaims_ea28edad","title":"<code>enableClaims</code>","text":"<p>Defined in <code>IIFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function enableClaims(\n) external;\n</code></pre> <p>Enable claiming for current and all future reward epochs.</p>"},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_firstclaimablerewardepoch_7b6b2c0a","title":"<code>firstClaimableRewardEpoch</code>","text":"<p>Defined in <code>IIFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function firstClaimableRewardEpoch(\n) external view returns (\n    uint256);\n</code></pre> <p>Epochs before the token distribution event at Flare launch were not be claimable. Use this method to know the first reward epoch that was claimable.</p> Returns Type Description [0] <code>uint256</code> uint256 The first reward epoch that can be claimed."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getclaimedreward_85b4c538","title":"<code>getClaimedReward</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getClaimedReward(\n    uint256 _rewardEpoch,\n    address _dataProvider,\n    address _claimer\n) external view returns (\n    bool _claimed,\n    uint256 _amount);\n</code></pre> <p>Returns information on the rewards accrued by a reward owner from a specific data provider at a specific reward epoch.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID to query. <code>_dataProvider</code> <code>address</code> Address of the data provider to query. <code>_claimer</code> <code>address</code> Address of the reward owner to query. Returns Type Description <code>_claimed</code> <code>bool</code> Whether the reward has been claimed or not. <code>_amount</code> <code>uint256</code> Accrued amount in wei."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getcontractname_f5f5ba72","title":"<code>getContractName</code>","text":"<p>Defined in <code>IIInflationReceiver</code> (Docs, Source).</p> <pre><code>function getContractName(\n) external view returns (\n    string);\n</code></pre> <p>Implement this function to allow updating inflation receiver contracts through <code>AddressUpdater</code>.</p> Returns Type Description [0] <code>string</code> Contract name."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getcurrentrewardepoch_e7c830d4","title":"<code>getCurrentRewardEpoch</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getCurrentRewardEpoch(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the current reward epoch ID.</p>"},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getdataprovidercurrentfeepercentage_cfbcd25f","title":"<code>getDataProviderCurrentFeePercentage</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getDataProviderCurrentFeePercentage(\n    address _dataProvider\n) external view returns (\n    uint256 _feePercentageBIPS);\n</code></pre> <p>Returns the current fee percentage of a data provider.</p> Parameters Type Description <code>_dataProvider</code> <code>address</code> Address of the queried data provider. Returns Type Description <code>_feePercentageBIPS</code> <code>uint256</code> Fee percentage in BIPS."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getdataproviderfeepercentage_961c00ed","title":"<code>getDataProviderFeePercentage</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getDataProviderFeePercentage(\n    address _dataProvider,\n    uint256 _rewardEpoch\n) external view returns (\n    uint256 _feePercentageBIPS);\n</code></pre> <p>Returns the fee percentage of a data provider at a given reward epoch.</p> Parameters Type Description <code>_dataProvider</code> <code>address</code> Address of the queried data provider. <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID. Returns Type Description <code>_feePercentageBIPS</code> <code>uint256</code> Fee percentage in BIPS."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getdataproviderperformanceinfo_eb82dd7f","title":"<code>getDataProviderPerformanceInfo</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getDataProviderPerformanceInfo(\n    uint256 _rewardEpoch,\n    address _dataProvider\n) external view returns (\n    uint256 _rewardAmount,\n    uint256 _votePowerIgnoringRevocation);\n</code></pre> <p>Returns information on rewards and vote power of a data provider at a given reward epoch.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID. <code>_dataProvider</code> <code>address</code> Address of the data provider to query. Returns Type Description <code>_rewardAmount</code> <code>uint256</code> Amount of rewards (wei). <code>_votePowerIgnoringRevocation</code> <code>uint256</code> Vote power, not including revocations."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getdataproviderscheduledfeepercentagechanges_33b7971e","title":"<code>getDataProviderScheduledFeePercentageChanges</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getDataProviderScheduledFeePercentageChanges(\n    address _dataProvider\n) external view returns (\n    uint256[] _feePercentageBIPS,\n    uint256[] _validFromEpoch,\n    bool[] _fixed);\n</code></pre> <p>Returns the scheduled fee percentage changes for a data provider.</p> Parameters Type Description <code>_dataProvider</code> <code>address</code> Address of the queried data provider. Returns Type Description <code>_feePercentageBIPS</code> <code>uint256[]</code> Array of fee percentages in BIPS. <code>_validFromEpoch</code> <code>uint256[]</code> Array of block numbers from which the fee settings are effective. <code>_fixed</code> <code>bool[]</code> Array of boolean values indicating whether settings are subject to change or not."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getepochreward_d418634a","title":"<code>getEpochReward</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getEpochReward(\n    uint256 _rewardEpoch\n) external view returns (\n    uint256 _totalReward,\n    uint256 _claimedReward);\n</code></pre> <p>Returns information on an epoch's rewards.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID. Returns Type Description <code>_totalReward</code> <code>uint256</code> Total amount of rewards accrued on that epoch, in wei. <code>_claimedReward</code> <code>uint256</code> Total amount of rewards that have already been claimed, in wei."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getepochswithclaimablerewards_0441218e","title":"<code>getEpochsWithClaimableRewards</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getEpochsWithClaimableRewards(\n) external view returns (\n    uint256 _startEpochId,\n    uint256 _endEpochId);\n</code></pre> <p>Returns the reward epoch range for which rewards can be claimed. Rewards outside this range are unclaimable, either because they have expired or because the reward epoch is still ongoing.</p> Returns Type Description <code>_startEpochId</code> <code>uint256</code> The oldest epoch ID that allows reward claiming. <code>_endEpochId</code> <code>uint256</code> The newest epoch ID that allows reward claiming."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getepochswithunclaimedrewards_b4a2043d","title":"<code>getEpochsWithUnclaimedRewards</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getEpochsWithUnclaimedRewards(\n    address _beneficiary\n) external view returns (\n    uint256[] _epochIds);\n</code></pre> <p>Returns the array of claimable epoch IDs for which the rewards of a reward owner have not yet been claimed.</p> Parameters Type Description <code>_beneficiary</code> <code>address</code> Address of the reward owner to query. Reverts if it uses delegation by amount. Returns Type Description <code>_epochIds</code> <code>uint256[]</code> Array of epoch IDs."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getexpectedbalance_af04cd3b","title":"<code>getExpectedBalance</code>","text":"<p>Defined in <code>IIInflationReceiver</code> (Docs, Source).</p> <pre><code>function getExpectedBalance(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the contract's expected balance (actual balance may be higher due to self-destruct funds).</p> Returns Type Description [0] <code>uint256</code> Expected native token balance."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getinflationaddress_ed39d3f8","title":"<code>getInflationAddress</code>","text":"<p>Defined in <code>IIInflationReceiver</code> (Docs, Source).</p> <pre><code>function getInflationAddress(\n) external returns (\n    address);\n</code></pre> <p>Returns the address of the <code>Inflation</code> contract.</p>"},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getinitialrewardepoch_3123b7d8","title":"<code>getInitialRewardEpoch</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getInitialRewardEpoch(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the initial reward epoch ID for this reward manager contract. This corresponds to the oldest reward epoch with claimable rewards in the previous reward manager when this one took over. Set by governance through <code>setInitialRewardData</code>.</p>"},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getrewardepochtoexpirenext_3e7ff857","title":"<code>getRewardEpochToExpireNext</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochToExpireNext(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the reward epoch that will expire next once a new reward epoch starts.</p>"},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getrewardepochvotepowerblock_f2edab5a","title":"<code>getRewardEpochVotePowerBlock</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getRewardEpochVotePowerBlock(\n    uint256 _rewardEpoch\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the vote power block of a given reward epoch.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getstateofrewards_a4472c10","title":"<code>getStateOfRewards</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getStateOfRewards(\n    address _beneficiary,\n    uint256 _rewardEpoch\n) external view returns (\n    address[] _dataProviders,\n    uint256[] _rewardAmounts,\n    bool[] _claimed,\n    bool _claimable);\n</code></pre> <p>Returns the state of rewards for a given address at a specific reward epoch.</p> Parameters Type Description <code>_beneficiary</code> <code>address</code> Address of the beneficiary to query. It can be a data provider or a delegator, for example.Reverts if the queried address is delegating by amount. <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID to query. Returns Type Description <code>_dataProviders</code> <code>address[]</code> Array of addresses of data providers. <code>_rewardAmounts</code> <code>uint256[]</code> Array of reward amounts received from each provider, in wei. <code>_claimed</code> <code>bool[]</code> Array of boolean values indicating whether each reward has been claimed or not. <code>_claimable</code> <code>bool</code> Boolean value indicating whether rewards are claimable or not."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getstateofrewardsfromdataproviders_e416b7e1","title":"<code>getStateOfRewardsFromDataProviders</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getStateOfRewardsFromDataProviders(\n    address _beneficiary,\n    uint256 _rewardEpoch,\n    address[] _dataProviders\n) external view returns (\n    uint256[] _rewardAmounts,\n    bool[] _claimed,\n    bool _claimable);\n</code></pre> <p>Returns the state of rewards for a given address coming from a specific set of data providers, at a specific reward epoch.</p> Parameters Type Description <code>_beneficiary</code> <code>address</code> Address of beneficiary to query. <code>_rewardEpoch</code> <code>uint256</code> Reward epoch ID to query. <code>_dataProviders</code> <code>address[]</code> Array of addresses of the data providers to query. Returns Type Description <code>_rewardAmounts</code> <code>uint256[]</code> Array of reward amounts received from each provider, in wei. <code>_claimed</code> <code>bool[]</code> Array of boolean values indicating whether each reward has been claimed or not. <code>_claimable</code> <code>bool</code> Boolean value indicating whether rewards are claimable or not."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_gettokenpoolsupplydata_2dafdbbf","title":"<code>getTokenPoolSupplyData</code>","text":"<p>Defined in <code>IITokenPool</code> (Docs, Source).</p> <pre><code>function getTokenPoolSupplyData(\n) external returns (\n    uint256 _lockedFundsWei,\n    uint256 _totalInflationAuthorizedWei,\n    uint256 _totalClaimedWei);\n</code></pre> <p>Returns token pool supply data.</p> Returns Type Description <code>_lockedFundsWei</code> <code>uint256</code> Total amount of funds ever locked in the token pool (wei). <code>_lockedFundsWei</code> - <code>_totalClaimedWei</code> is the amount currently locked and outside the circulating supply. <code>_totalInflationAuthorizedWei</code> <code>uint256</code> Total inflation authorized amount (wei). <code>_totalClaimedWei</code> <code>uint256</code> Total claimed amount (wei)."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_getunclaimedreward_657d9695","title":"<code>getUnclaimedReward</code>","text":"<p>Defined in <code>IIFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function getUnclaimedReward(\n    uint256 _rewardEpoch,\n    address _dataProvider\n) external view returns (\n    uint256 _amount,\n    uint256 _weight);\n</code></pre> <p>Returns information on unclaimed rewards for a given data provider and epoch.</p> Parameters Type Description <code>_rewardEpoch</code> <code>uint256</code> Queried reward epoch ID. <code>_dataProvider</code> <code>address</code> Address of the queried data provider. Returns Type Description <code>_amount</code> <code>uint256</code> Amount available to be claimed, in wei. <code>_weight</code> <code>uint256</code> Portion of total vote power used in this reward epoch that has not yet claimed its reward, in BIPS. It decreases to 0 when all data providers have claimed their rewards."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_nextclaimablerewardepoch_69b91b59","title":"<code>nextClaimableRewardEpoch</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function nextClaimableRewardEpoch(\n    address _rewardOwner\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the next claimable reward epoch for a reward owner.</p> Parameters Type Description <code>_rewardOwner</code> <code>address</code> Address of the reward owner to query."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_receiveinflation_06201f1d","title":"<code>receiveInflation</code>","text":"<p>Defined in <code>IIInflationReceiver</code> (Docs, Source).</p> <pre><code>function receiveInflation(\n) external payable;\n</code></pre> <p>Receive native tokens from inflation.</p>"},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_setdailyauthorizedinflation_e2739563","title":"<code>setDailyAuthorizedInflation</code>","text":"<p>Defined in <code>IIInflationReceiver</code> (Docs, Source).</p> <pre><code>function setDailyAuthorizedInflation(\n    uint256 _toAuthorizeWei\n) external;\n</code></pre> <p>Notify the receiver that it is entitled to receive a new inflation amount.</p> Parameters Type Description <code>_toAuthorizeWei</code> <code>uint256</code> The amount of inflation that can be awarded in the coming day, in wei."},{"location":"apis/smart-contracts/IIFtsoRewardManager/#fn_setdataproviderfeepercentage_16e69328","title":"<code>setDataProviderFeePercentage</code>","text":"<p>Defined in <code>IFtsoRewardManager</code> (Docs, Source).</p> <pre><code>function setDataProviderFeePercentage(\n    uint256 _feePercentageBIPS\n) external returns (\n    uint256 _validFromEpoch);\n</code></pre> <p>Sets the fee a data provider keeps from all delegations.</p> <p>Takes effect after <code>feeValueUpdateOffset</code> reward epochs have elapsed.</p> <p>When called multiple times inside the same reward epoch, only the last value remains.</p> Parameters Type Description <code>_feePercentageBIPS</code> <code>uint256</code> Fee percentage in BIPS. Returns Type Description <code>_validFromEpoch</code> <code>uint256</code> Reward epoch number when the new fee percentage will become effective."},{"location":"apis/smart-contracts/IIGovernanceVotePower/","title":"IIGovernanceVotePower","text":""},{"location":"apis/smart-contracts/IIGovernanceVotePower/#ct_iigovernancevotepower","title":"<code>IIGovernanceVotePower</code>","text":"<p>Source | Inherits from IGovernanceVotePower</p> <p>Internal interface for contracts delegating their governance vote power.</p>"},{"location":"apis/smart-contracts/IIGovernanceVotePower/#events","title":"Events","text":""},{"location":"apis/smart-contracts/IIGovernanceVotePower/#ev_delegatechanged","title":"<code>DelegateChanged</code>","text":"<p>Defined in <code>IIGovernanceVotePower</code> (Docs, Source).</p> <pre><code>event DelegateChanged(\n    address delegator,\n    address fromDelegate,\n    address toDelegate\n)\n</code></pre> <p>Emitted when an account starts delegating vote power or switches its delegation to another address.</p> <p>The event is always emitted from a <code>GovernanceVotePower</code> contract.</p> Parameters Type Description <code>delegator</code> <code>address</code> Account delegating its vote power. <code>fromDelegate</code> <code>address</code> Account receiving the delegation before the change. Can be address(0) if there was no previous delegation. <code>toDelegate</code> <code>address</code> Account receiving the delegation after the change. Can be address(0) if <code>delegator</code> just undelegated all its vote power."},{"location":"apis/smart-contracts/IIGovernanceVotePower/#ev_delegatevoteschanged","title":"<code>DelegateVotesChanged</code>","text":"<p>Defined in <code>IIGovernanceVotePower</code> (Docs, Source).</p> <pre><code>event DelegateVotesChanged(\n    address delegate,\n    uint256 previousBalance,\n    uint256 newBalance\n)\n</code></pre> <p>Emitted when a <code>delegate</code>'s vote power changes, as a result of a new delegation or a token transfer, for example.</p> <p>The event is always emitted from a <code>GovernanceVotePower</code> contract.</p> Parameters Type Description <code>delegate</code> <code>address</code> The account receiving the changing delegated vote power. <code>previousBalance</code> <code>uint256</code> Delegated vote power before the change. <code>newBalance</code> <code>uint256</code> Delegated vote power after the change."},{"location":"apis/smart-contracts/IIGovernanceVotePower/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IIGovernanceVotePower/#fn_delegate_5c19a95c","title":"<code>delegate</code>","text":"<p>Defined in <code>IGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function delegate(\n    address _to\n) external;\n</code></pre> <p>Delegates all governance vote power of <code>msg.sender</code> to address <code>_to</code>.</p> Parameters Type Description <code>_to</code> <code>address</code> The address of the recipient."},{"location":"apis/smart-contracts/IIGovernanceVotePower/#fn_getcleanupblocknumber_a72ec4b6","title":"<code>getCleanupBlockNumber</code>","text":"<p>Defined in <code>IIGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function getCleanupBlockNumber(\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current cleanup block number set with <code>setCleanupBlockNumber</code>.</p> Returns Type Description [0] <code>uint256</code> The currently set cleanup block number."},{"location":"apis/smart-contracts/IIGovernanceVotePower/#fn_getdelegateofat_3c028e9d","title":"<code>getDelegateOfAt</code>","text":"<p>Defined in <code>IGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function getDelegateOfAt(\n    address _who,\n    uint256 _blockNumber\n) external view returns (\n    address);\n</code></pre> <p>Gets the address an account is delegating its governance vote power to, at a given block number.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. <code>_blockNumber</code> <code>uint256</code> The block number at which to fetch the address. Returns Type Description [0] <code>address</code> Address where <code>_who</code> was delegating its governance vote power at block <code>_blockNumber</code>."},{"location":"apis/smart-contracts/IIGovernanceVotePower/#fn_getdelegateofatnow_b3e871ee","title":"<code>getDelegateOfAtNow</code>","text":"<p>Defined in <code>IGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function getDelegateOfAtNow(\n    address _who\n) external view returns (\n    address);\n</code></pre> <p>Gets the address an account is delegating its governance vote power to, at the latest block number.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. Returns Type Description [0] <code>address</code> Address where <code>_who</code> is currently delegating its governance vote power."},{"location":"apis/smart-contracts/IIGovernanceVotePower/#fn_getvotes_9ab24eb0","title":"<code>getVotes</code>","text":"<p>Defined in <code>IGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function getVotes(\n    address _who\n) external view returns (\n    uint256);\n</code></pre> <p>Gets the governance vote power of an address at the latest block, including all delegations made to it.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. Returns Type Description [0] <code>uint256</code> Governance vote power of <code>account</code> at the lastest block."},{"location":"apis/smart-contracts/IIGovernanceVotePower/#fn_ownertoken_65371883","title":"<code>ownerToken</code>","text":"<p>Defined in <code>IIGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function ownerToken(\n) external view returns (\n    contract IVPToken);\n</code></pre> <p>Get the token that this governance vote power contract belongs to.</p> Returns Type Description [0] <code>contract IVPToken</code> The <code>IVPToken</code> interface owning this contract."},{"location":"apis/smart-contracts/IIGovernanceVotePower/#fn_setcleanercontract_f6a494af","title":"<code>setCleanerContract</code>","text":"<p>Defined in <code>IIGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function setCleanerContract(\n    address _cleanerContract\n) external;\n</code></pre> <p>Set the contract that is allowed to call history cleaning methods.</p> Parameters Type Description <code>_cleanerContract</code> <code>address</code> Address of the cleanup contract. Usually this will be an instance of <code>CleanupBlockNumberManager</code>."},{"location":"apis/smart-contracts/IIGovernanceVotePower/#fn_setcleanupblocknumber_13de97f5","title":"<code>setCleanupBlockNumber</code>","text":"<p>Defined in <code>IIGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function setCleanupBlockNumber(\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Set the cleanup block number. Historic data for the blocks before <code>cleanupBlockNumber</code> can be erased. History before that block should never be used since it can be inconsistent. In particular, cleanup block number must be lower than the current vote power block.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The new cleanup block number."},{"location":"apis/smart-contracts/IIGovernanceVotePower/#fn_undelegate_92ab89bb","title":"<code>undelegate</code>","text":"<p>Defined in <code>IGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function undelegate(\n) external;\n</code></pre> <p>Undelegates all governance vote power of <code>msg.sender</code>.</p>"},{"location":"apis/smart-contracts/IIGovernanceVotePower/#fn_updateattokentransfer_eadb4362","title":"<code>updateAtTokenTransfer</code>","text":"<p>Defined in <code>IIGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function updateAtTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _fromBalance,\n    uint256 _toBalance,\n    uint256 _amount\n) external;\n</code></pre> <p>Update governance vote power of all involved delegates after tokens are transferred.</p> <p>This function MUST be called after each governance token transfer for the delegates to reflect the correct balance.</p> Parameters Type Description <code>_from</code> <code>address</code> Source address of the transfer. <code>_to</code> <code>address</code> Destination address of the transfer. <code>_fromBalance</code> <code>uint256</code> Ignored. <code>_toBalance</code> <code>uint256</code> Ignored. <code>_amount</code> <code>uint256</code> Amount being transferred."},{"location":"apis/smart-contracts/IIGovernanceVotePower/#fn_votepowerofat_92bfe6d8","title":"<code>votePowerOfAt</code>","text":"<p>Defined in <code>IGovernanceVotePower</code> (Docs, Source).</p> <pre><code>function votePowerOfAt(\n    address _who,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Gets the governance vote power of an address at a given block number, including all delegations made to it.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. <code>_blockNumber</code> <code>uint256</code> The block number at which to fetch the vote power. Returns Type Description [0] <code>uint256</code> Governance vote power of <code>_who</code> at <code>_blockNumber</code>."},{"location":"apis/smart-contracts/IIInflationReceiver/","title":"IIInflationReceiver","text":""},{"location":"apis/smart-contracts/IIInflationReceiver/#ct_iiinflationreceiver","title":"<code>IIInflationReceiver</code>","text":"<p>Source</p> <p>Internal interface for contracts that can receive inflation.</p>"},{"location":"apis/smart-contracts/IIInflationReceiver/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IIInflationReceiver/#fn_getcontractname_f5f5ba72","title":"<code>getContractName</code>","text":"<p>Defined in <code>IIInflationReceiver</code> (Docs, Source).</p> <pre><code>function getContractName(\n) external view returns (\n    string);\n</code></pre> <p>Implement this function to allow updating inflation receiver contracts through <code>AddressUpdater</code>.</p> Returns Type Description [0] <code>string</code> Contract name."},{"location":"apis/smart-contracts/IIInflationReceiver/#fn_getexpectedbalance_af04cd3b","title":"<code>getExpectedBalance</code>","text":"<p>Defined in <code>IIInflationReceiver</code> (Docs, Source).</p> <pre><code>function getExpectedBalance(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the contract's expected balance (actual balance may be higher due to self-destruct funds).</p> Returns Type Description [0] <code>uint256</code> Expected native token balance."},{"location":"apis/smart-contracts/IIInflationReceiver/#fn_getinflationaddress_ed39d3f8","title":"<code>getInflationAddress</code>","text":"<p>Defined in <code>IIInflationReceiver</code> (Docs, Source).</p> <pre><code>function getInflationAddress(\n) external returns (\n    address);\n</code></pre> <p>Returns the address of the <code>Inflation</code> contract.</p>"},{"location":"apis/smart-contracts/IIInflationReceiver/#fn_receiveinflation_06201f1d","title":"<code>receiveInflation</code>","text":"<p>Defined in <code>IIInflationReceiver</code> (Docs, Source).</p> <pre><code>function receiveInflation(\n) external payable;\n</code></pre> <p>Receive native tokens from inflation.</p>"},{"location":"apis/smart-contracts/IIInflationReceiver/#fn_setdailyauthorizedinflation_e2739563","title":"<code>setDailyAuthorizedInflation</code>","text":"<p>Defined in <code>IIInflationReceiver</code> (Docs, Source).</p> <pre><code>function setDailyAuthorizedInflation(\n    uint256 _toAuthorizeWei\n) external;\n</code></pre> <p>Notify the receiver that it is entitled to receive a new inflation amount.</p> Parameters Type Description <code>_toAuthorizeWei</code> <code>uint256</code> The amount of inflation that can be awarded in the coming day, in wei."},{"location":"apis/smart-contracts/IIPriceSubmitter/","title":"IIPriceSubmitter","text":""},{"location":"apis/smart-contracts/IIPriceSubmitter/#ct_iipricesubmitter","title":"<code>IIPriceSubmitter</code>","text":"<p>Source | Inherits from IPriceSubmitter</p> <p>Internal interface for the <code>PriceSubmitter</code> contract.</p>"},{"location":"apis/smart-contracts/IIPriceSubmitter/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IIPriceSubmitter/#fn_getcurrentrandom_d89601fd","title":"<code>getCurrentRandom</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function getCurrentRandom(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the random number for the previous epoch, obtained from the random numbers provided by all data providers along with their data submissions. Note that the random number for the previous epoch keeps updating as new submissions are revealed.</p> Returns Type Description [0] <code>uint256</code> Random number calculated from all data provider's submissions."},{"location":"apis/smart-contracts/IIPriceSubmitter/#fn_getftsomanager_b39c6858","title":"<code>getFtsoManager</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function getFtsoManager(\n) external view returns (\n    contract IFtsoManagerGenesis);\n</code></pre> <p>Returns the address of the <code>FtsoManager</code> contract.</p>"},{"location":"apis/smart-contracts/IIPriceSubmitter/#fn_getftsoregistry_8c9d28b6","title":"<code>getFtsoRegistry</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function getFtsoRegistry(\n) external view returns (\n    contract IFtsoRegistryGenesis);\n</code></pre> <p>Returns the address of the <code>FtsoRegistry</code> contract.</p>"},{"location":"apis/smart-contracts/IIPriceSubmitter/#fn_getrandom_cd4b6914","title":"<code>getRandom</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function getRandom(\n    uint256 _epochId\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the random number used in a specific past epoch, obtained from the random numbers provided by all data providers along with their data submissions.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the queried epoch. Current epoch cannot be queried, and the previous epoch is constantly updated as data providers reveal their prices and random numbers. Note that only the last 50 epochs can be queried and there is no bounds checking for this parameter. Out-of-bounds queries return undefined values. Returns Type Description [0] <code>uint256</code> The random number used in that epoch."},{"location":"apis/smart-contracts/IIPriceSubmitter/#fn_gettrustedaddresses_ffacb84e","title":"<code>getTrustedAddresses</code>","text":"<p>Defined in <code>IIPriceSubmitter</code> (Docs, Source).</p> <pre><code>function getTrustedAddresses(\n) external view returns (\n    address[]);\n</code></pre> <p>Returns the list of trusted addresses that are always allowed to submit and reveal.</p> Returns Type Description [0] <code>address[]</code> address[] Array of trusted voter addresses."},{"location":"apis/smart-contracts/IIPriceSubmitter/#fn_getvoterwhitelister_71e1fad9","title":"<code>getVoterWhitelister</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function getVoterWhitelister(\n) external view returns (\n    address);\n</code></pre> <p>Returns the address of the <code>VoterWhitelister</code> contract managing the data provider whitelist.</p>"},{"location":"apis/smart-contracts/IIPriceSubmitter/#fn_revealprices_e2db5a52","title":"<code>revealPrices</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function revealPrices(\n    uint256 _epochId,\n    uint256[] _ftsoIndices,\n    uint256[] _prices,\n    uint256 _random\n) external;\n</code></pre> <p>Reveals submitted prices during the epoch reveal period. The hash of FTSO indices, prices, random number, and voter address must be equal to the hash previously submitted with <code>submitHash</code>. Emits a <code>PricesRevealed</code> event.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch to which the price hashes are submitted. <code>_ftsoIndices</code> <code>uint256[]</code> List of FTSO indices in ascending order. <code>_prices</code> <code>uint256[]</code> List of submitted prices in USD. <code>_random</code> <code>uint256</code> Submitted random number."},{"location":"apis/smart-contracts/IIPriceSubmitter/#fn_settrustedaddresses_9ec2b581","title":"<code>setTrustedAddresses</code>","text":"<p>Defined in <code>IIPriceSubmitter</code> (Docs, Source).</p> <pre><code>function setTrustedAddresses(\n    address[] _trustedAddresses\n) external;\n</code></pre> <p>Set trusted addresses that are always allowed to submit and reveal. Only ftso manager can call this method.</p> Parameters Type Description <code>_trustedAddresses</code> <code>address[]</code> Array of voter addresses."},{"location":"apis/smart-contracts/IIPriceSubmitter/#fn_submithash_8fc6f667","title":"<code>submitHash</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function submitHash(\n    uint256 _epochId,\n    bytes32 _hash\n) external;\n</code></pre> <p>Submits a hash for the current epoch. Can only be called by FTSO data providers whitelisted through the <code>VoterWhitelisted</code> contract. Emits the <code>HashSubmitted</code> event.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the target epoch to which the hash is submitted. <code>_hash</code> <code>bytes32</code> A hash of the FTSO indices, prices, random number, and voter address."},{"location":"apis/smart-contracts/IIPriceSubmitter/#fn_voterwhitelistbitmap_7ac420ad","title":"<code>voterWhitelistBitmap</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function voterWhitelistBitmap(\n    address _voter\n) external view returns (\n    uint256);\n</code></pre> <p>Returns a bitmap of all FTSOs for which a data provider is allowed to submit prices or hashes.</p> Parameters Type Description <code>_voter</code> <code>address</code> Address of the voter. Returns Type Description [0] <code>uint256</code> If a data provider is allowed to vote for a given FTSO index, the corresponding bit in the result is 1."},{"location":"apis/smart-contracts/IIPriceSubmitter/#fn_voterwhitelisted_9d986f91","title":"<code>voterWhitelisted</code>","text":"<p>Defined in <code>IIPriceSubmitter</code> (Docs, Source).</p> <pre><code>function voterWhitelisted(\n    address _voter,\n    uint256 _ftsoIndex\n) external;\n</code></pre> <p>Called from the <code>VoterWhitelister</code> contract when a new voter has been whitelisted.</p> Parameters Type Description <code>_voter</code> <code>address</code> Voter address that has been added to the whitelist. <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO to which the voter has registered. Each FTSO has its own whitelist."},{"location":"apis/smart-contracts/IIPriceSubmitter/#fn_votersremovedfromwhitelist_76794efb","title":"<code>votersRemovedFromWhitelist</code>","text":"<p>Defined in <code>IIPriceSubmitter</code> (Docs, Source).</p> <pre><code>function votersRemovedFromWhitelist(\n    address[] _voters,\n    uint256 _ftsoIndex\n) external;\n</code></pre> <p>Called from the <code>VoterWhitelister</code> contract when one or more voters have been removed.</p> Parameters Type Description <code>_voters</code> <code>address[]</code> Array of voter addresses that have been removed. <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO to which the voters were registered. Each FTSO has its own whitelist."},{"location":"apis/smart-contracts/IITokenPool/","title":"IITokenPool","text":""},{"location":"apis/smart-contracts/IITokenPool/#ct_iitokenpool","title":"<code>IITokenPool</code>","text":"<p>Source</p> <p>Internal interface for token pools.</p>"},{"location":"apis/smart-contracts/IITokenPool/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IITokenPool/#fn_gettokenpoolsupplydata_2dafdbbf","title":"<code>getTokenPoolSupplyData</code>","text":"<p>Defined in <code>IITokenPool</code> (Docs, Source).</p> <pre><code>function getTokenPoolSupplyData(\n) external returns (\n    uint256 _lockedFundsWei,\n    uint256 _totalInflationAuthorizedWei,\n    uint256 _totalClaimedWei);\n</code></pre> <p>Returns token pool supply data.</p> Returns Type Description <code>_lockedFundsWei</code> <code>uint256</code> Total amount of funds ever locked in the token pool (wei). <code>_lockedFundsWei</code> - <code>_totalClaimedWei</code> is the amount currently locked and outside the circulating supply. <code>_totalInflationAuthorizedWei</code> <code>uint256</code> Total inflation authorized amount (wei). <code>_totalClaimedWei</code> <code>uint256</code> Total claimed amount (wei)."},{"location":"apis/smart-contracts/IIVPContract/","title":"IIVPContract","text":""},{"location":"apis/smart-contracts/IIVPContract/#ct_iivpcontract","title":"<code>IIVPContract</code>","text":"<p>Source | Inherits from IICleanable, IVPContractEvents</p> <p>Internal interface for helper contracts handling functionality for an associated <code>VPToken</code>.</p>"},{"location":"apis/smart-contracts/IIVPContract/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IIVPContract/#fn_batchvotepowerofat_49e3c7e5","title":"<code>batchVotePowerOfAt</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function batchVotePowerOfAt(\n    address[] _owners,\n    uint256 _blockNumber\n) external view returns (\n    uint256[]);\n</code></pre> <p>Get the vote power of a set of addresses at a given block number.</p> Parameters Type Description <code>_owners</code> <code>address[]</code> The list of addresses being queried. <code>_blockNumber</code> <code>uint256</code> The block number being queried. Returns Type Description [0] <code>uint256[]</code> Vote power of each address at <code>_blockNumber</code>, including any delegation received."},{"location":"apis/smart-contracts/IIVPContract/#fn_cleanupblocknumber_deea13e7","title":"<code>cleanupBlockNumber</code>","text":"<p>Defined in <code>IICleanable</code> (Docs, Source).</p> <pre><code>function cleanupBlockNumber(\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current cleanup block number set with <code>setCleanupBlockNumber</code>.</p> Returns Type Description [0] <code>uint256</code> The currently set cleanup block number."},{"location":"apis/smart-contracts/IIVPContract/#fn_delegate_6230001a","title":"<code>delegate</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function delegate(\n    address _from,\n    address _to,\n    uint256 _balance,\n    uint256 _bips\n) external;\n</code></pre> <p><code>Delegate</code> <code>_bips</code> percentage of voting power from a delegator address to a delegatee address.</p> Parameters Type Description <code>_from</code> <code>address</code> The address of the delegator. <code>_to</code> <code>address</code> The address of the delegatee. <code>_balance</code> <code>uint256</code> The delegator's current balance <code>_bips</code> <code>uint256</code> The percentage of voting power to be delegated expressed in basis points (1/100 of one percent). Not cumulative: every call resets the delegation value (and a value of 0 revokes delegation)."},{"location":"apis/smart-contracts/IIVPContract/#fn_delegateexplicit_404d9e82","title":"<code>delegateExplicit</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function delegateExplicit(\n    address _from,\n    address _to,\n    uint256 _balance,\n    uint256 _amount\n) external;\n</code></pre> <p>Explicitly <code>delegate</code> <code>_amount</code> tokens of voting power from a delegator address to a delegatee address.</p> Parameters Type Description <code>_from</code> <code>address</code> The address of the delegator. <code>_to</code> <code>address</code> The address of the delegatee. <code>_balance</code> <code>uint256</code> The delegator's current balance. <code>_amount</code> <code>uint256</code> An explicit vote power amount to be delegated. Not cumulative: every call resets the delegation value (and a value of 0 undelegates <code>_to</code>)."},{"location":"apis/smart-contracts/IIVPContract/#fn_delegatesof_7de5b8ed","title":"<code>delegatesOf</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function delegatesOf(\n    address _owner\n) external view returns (\n    address[] _delegateAddresses,\n    uint256[] _bips,\n    uint256 _count,\n    uint256 _delegationMode);\n</code></pre> <p>Get the percentages and addresses being delegated to by a vote power delegator.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address of the delegator being queried. Returns Type Description <code>_delegateAddresses</code> <code>address[]</code> Array of delegatee addresses. <code>_bips</code> <code>uint256[]</code> Array of delegation percents specified in basis points (1/100 or 1 percent), for each delegatee. <code>_count</code> <code>uint256</code> The number of returned delegatees. <code>_delegationMode</code> <code>uint256</code> The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2). See <code>Delegatable</code>.DelegationMode."},{"location":"apis/smart-contracts/IIVPContract/#fn_delegatesofat_ed475a79","title":"<code>delegatesOfAt</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function delegatesOfAt(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    address[] _delegateAddresses,\n    uint256[] _bips,\n    uint256 _count,\n    uint256 _delegationMode);\n</code></pre> <p>Get the percentages and addresses being delegated to by a vote power delegator, at a given block.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address of the delegator being queried. <code>_blockNumber</code> <code>uint256</code> The block number being queried. Returns Type Description <code>_delegateAddresses</code> <code>address[]</code> Array of delegatee addresses. <code>_bips</code> <code>uint256[]</code> Array of delegation percents specified in basis points (1/100 or 1 percent), for each delegatee. <code>_count</code> <code>uint256</code> The number of returned delegatees. <code>_delegationMode</code> <code>uint256</code> The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2). See <code>Delegatable</code>.DelegationMode."},{"location":"apis/smart-contracts/IIVPContract/#fn_delegationmodeof_f6837767","title":"<code>delegationModeOf</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function delegationModeOf(\n    address _who\n) external view returns (\n    uint256);\n</code></pre> <p>Get the delegation mode of an address. This mode determines whether vote power is allocated by percentage or by explicit value and cannot be changed once set with <code>delegate</code> or <code>delegateExplicit</code>.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. Returns Type Description [0] <code>uint256</code> Delegation mode (NOTSET=0, PERCENTAGE=1, AMOUNT=2). See <code>Delegatable</code>.DelegationMode."},{"location":"apis/smart-contracts/IIVPContract/#fn_isreplacement_aa94d3f2","title":"<code>isReplacement</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function isReplacement(\n) external view returns (\n    bool);\n</code></pre> <p>Return true if this <code>IIVPContract</code> is configured to be used as a replacement for other contract. It means that vote powers are not necessarily correct at the initialization, therefore every method that reads vote power must check whether it is initialized for that address and block.</p>"},{"location":"apis/smart-contracts/IIVPContract/#fn_ownertoken_65371883","title":"<code>ownerToken</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function ownerToken(\n) external view returns (\n    contract IVPToken);\n</code></pre> <p>The <code>VPToken</code> (or some other contract) that owns this <code>VPContract</code>. All state changing methods may be called only from this address. This is because original <code>msg.sender</code> is typically sent in a parameter and we must make sure that it cannot be faked by directly calling <code>IIVPContract</code> methods. Owner token is also used in case of replacement to recover vote powers from balances.</p>"},{"location":"apis/smart-contracts/IIVPContract/#fn_revokedelegationat_c7c62fab","title":"<code>revokeDelegationAt</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function revokeDelegationAt(\n    address _from,\n    address _to,\n    uint256 _balance,\n    uint256 _blockNumber\n) external;\n</code></pre> <p><code>Revoke</code> all vote power delegation from a delegator address to a delegatee address at a given block. Only affects the reads via <code>votePowerOfAtCached</code> in the block <code>_blockNumber</code>. This method should be used only to prevent rogue <code>delegate</code> voting in the current voting block. To stop delegating use <code>delegate</code> or <code>delegateExplicit</code> with value of 0, or <code>undelegateAll</code>/ <code>undelegateAllExplicit</code>.</p> Parameters Type Description <code>_from</code> <code>address</code> The address of the delegator. <code>_to</code> <code>address</code> Address of the delegatee. <code>_balance</code> <code>uint256</code> The delegator's current balance. <code>_blockNumber</code> <code>uint256</code> The block number at which to revoke delegation. Must be in the past."},{"location":"apis/smart-contracts/IIVPContract/#fn_setcleanercontract_f6a494af","title":"<code>setCleanerContract</code>","text":"<p>Defined in <code>IICleanable</code> (Docs, Source).</p> <pre><code>function setCleanerContract(\n    address _cleanerContract\n) external;\n</code></pre> <p>Set the contract that is allowed to call history cleaning methods.</p> Parameters Type Description <code>_cleanerContract</code> <code>address</code> Address of the cleanup contract. Usually this will be an instance of <code>CleanupBlockNumberManager</code>."},{"location":"apis/smart-contracts/IIVPContract/#fn_setcleanupblocknumber_13de97f5","title":"<code>setCleanupBlockNumber</code>","text":"<p>Defined in <code>IICleanable</code> (Docs, Source).</p> <pre><code>function setCleanupBlockNumber(\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Set the cleanup block number. Historic data for the blocks before <code>cleanupBlockNumber</code> can be erased. History before that block should never be used since it can be inconsistent. In particular, cleanup block number must be lower than the current vote power block.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The new cleanup block number."},{"location":"apis/smart-contracts/IIVPContract/#fn_undelegateall_05109ecf","title":"<code>undelegateAll</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function undelegateAll(\n    address _from,\n    uint256 _balance\n) external;\n</code></pre> <p>Undelegate all voting power for a delegator address. Can only be used with percentage delegation. Does not reset delegation mode back to <code>NOTSET</code>.</p> Parameters Type Description <code>_from</code> <code>address</code> The address of the delegator. <code>_balance</code> <code>uint256</code> The delegator's current balance."},{"location":"apis/smart-contracts/IIVPContract/#fn_undelegateallexplicit_0f8b8af7","title":"<code>undelegateAllExplicit</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function undelegateAllExplicit(\n    address _from,\n    address[] _delegateAddresses\n) external returns (\n    uint256);\n</code></pre> <p>Undelegate all explicit vote power by amount for a delegator address. Can only be used with explicit delegation. Does not reset delegation mode back to <code>NOTSET</code>.</p> Parameters Type Description <code>_from</code> <code>address</code> The address of the delegator. <code>_delegateAddresses</code> <code>address[]</code> Explicit delegation does not store delegatees' addresses, so the caller must supply them. Returns Type Description [0] <code>uint256</code> The amount still delegated (in case the list of delegates was incomplete)."},{"location":"apis/smart-contracts/IIVPContract/#fn_undelegatedvotepowerof_4a03d556","title":"<code>undelegatedVotePowerOf</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function undelegatedVotePowerOf(\n    address _owner,\n    uint256 _balance\n) external view returns (\n    uint256);\n</code></pre> <p>Compute the current undelegated vote power of an address.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address being queried. <code>_balance</code> <code>uint256</code> Current balance of that address. Returns Type Description [0] <code>uint256</code> The unallocated vote power of <code>_owner</code>, this is, the amount of vote power currently not being delegated to other addresses."},{"location":"apis/smart-contracts/IIVPContract/#fn_undelegatedvotepowerofat_31503927","title":"<code>undelegatedVotePowerOfAt</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function undelegatedVotePowerOfAt(\n    address _owner,\n    uint256 _balance,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Compute the undelegated vote power of an address at a given block.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address being queried. <code>_balance</code> <code>uint256</code> <code>_blockNumber</code> <code>uint256</code> The block number being queried. Returns Type Description [0] <code>uint256</code> The unallocated vote power of <code>_owner</code>, this is, the amount of vote power that was not being delegated to other addresses at that block number."},{"location":"apis/smart-contracts/IIVPContract/#fn_updateattokentransfer_eadb4362","title":"<code>updateAtTokenTransfer</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function updateAtTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _fromBalance,\n    uint256 _toBalance,\n    uint256 _amount\n) external;\n</code></pre> <p>Update vote powers when tokens are transferred. Also update delegated vote powers for percentage delegation and check for enough funds for explicit delegations.</p> Parameters Type Description <code>_from</code> <code>address</code> Source account of the transfer. <code>_to</code> <code>address</code> Destination account of the transfer. <code>_fromBalance</code> <code>uint256</code> Balance of the source account before the transfer. <code>_toBalance</code> <code>uint256</code> Balance of the destination account before the transfer. <code>_amount</code> <code>uint256</code> Amount that has been transferred."},{"location":"apis/smart-contracts/IIVPContract/#fn_votepowerfromto_9dc6b9f2","title":"<code>votePowerFromTo</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function votePowerFromTo(\n    address _from,\n    address _to,\n    uint256 _balance\n) external view returns (\n    uint256);\n</code></pre> <p>Get current delegated vote power from a delegator to a delegatee.</p> Parameters Type Description <code>_from</code> <code>address</code> Address of the delegator. <code>_to</code> <code>address</code> Address of the delegatee. <code>_balance</code> <code>uint256</code> The delegator's current balance. Returns Type Description [0] <code>uint256</code> The delegated vote power."},{"location":"apis/smart-contracts/IIVPContract/#fn_votepowerfromtoat_833aca92","title":"<code>votePowerFromToAt</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function votePowerFromToAt(\n    address _from,\n    address _to,\n    uint256 _balance,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get delegated the vote power from a delegator to a delegatee at a given block number.</p> Parameters Type Description <code>_from</code> <code>address</code> Address of the delegator. <code>_to</code> <code>address</code> Address of the delegatee. <code>_balance</code> <code>uint256</code> The delegator's current balance. <code>_blockNumber</code> <code>uint256</code> The block number being queried. Returns Type Description [0] <code>uint256</code> The delegated vote power."},{"location":"apis/smart-contracts/IIVPContract/#fn_votepowerof_142d1018","title":"<code>votePowerOf</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function votePowerOf(\n    address _who\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current vote power of an address.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. Returns Type Description [0] <code>uint256</code> Current vote power of <code>_who</code>, including any delegation received."},{"location":"apis/smart-contracts/IIVPContract/#fn_votepowerofat_92bfe6d8","title":"<code>votePowerOfAt</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function votePowerOfAt(\n    address _who,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the vote power of an address at a given block number</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. <code>_blockNumber</code> <code>uint256</code> The block number being queried. Returns Type Description [0] <code>uint256</code> Vote power of <code>_who</code> at <code>_blockNumber</code>, including any delegation received."},{"location":"apis/smart-contracts/IIVPContract/#fn_votepowerofatcached_e587497e","title":"<code>votePowerOfAtCached</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function votePowerOfAtCached(\n    address _who,\n    uint256 _blockNumber\n) external returns (\n    uint256);\n</code></pre> <p>Get the vote power of an address at a given block number. Reads/updates cache and upholds revocations.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. <code>_blockNumber</code> <code>uint256</code> The block number being queried. Returns Type Description [0] <code>uint256</code> Vote power of <code>_who</code> at <code>_blockNumber</code>, including any delegation received."},{"location":"apis/smart-contracts/IIVPContract/#fn_votepowerofatignoringrevocation_04bb4e43","title":"<code>votePowerOfAtIgnoringRevocation</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function votePowerOfAtIgnoringRevocation(\n    address _who,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the vote power of an address at a given block number, ignoring revocation information and cache.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. <code>_blockNumber</code> <code>uint256</code> The block number being queried. Returns Type Description [0] <code>uint256</code> Vote power of <code>_who</code> at <code>_blockNumber</code>, including any delegation received. Result doesn't change if vote power is revoked."},{"location":"apis/smart-contracts/IIVPToken/","title":"IIVPToken","text":""},{"location":"apis/smart-contracts/IIVPToken/#ct_iivptoken","title":"<code>IIVPToken</code>","text":"<p>Source | Inherits from IVPToken, IICleanable</p> <p>Vote power token internal interface.</p>"},{"location":"apis/smart-contracts/IIVPToken/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IIVPToken/#fn_allowance_dd62ed3e","title":"<code>allowance</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function allowance(\n    address owner,\n    address spender\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the remaining number of tokens that <code>spender</code> will be allowed to spend on behalf of <code>owner</code> through <code>transferFrom</code>. This is zero by default.</p> <p>This value changes when <code>approve</code> or <code>transferFrom</code> are called.</p>"},{"location":"apis/smart-contracts/IIVPToken/#fn_approve_095ea7b3","title":"<code>approve</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function approve(\n    address spender,\n    uint256 amount\n) external returns (\n    bool);\n</code></pre> <p>Sets <code>amount</code> as the <code>allowance</code> of <code>spender</code> over the caller's tokens.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>IMPORTANT: Beware that changing an <code>allowance</code> with this method brings the risk that someone may use both the old and the new <code>allowance</code> by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's <code>allowance</code> to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</p> <p>Emits an <code>Approval</code> event.</p>"},{"location":"apis/smart-contracts/IIVPToken/#fn_balanceof_70a08231","title":"<code>balanceOf</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function balanceOf(\n    address account\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the amount of tokens owned by <code>account</code>.</p>"},{"location":"apis/smart-contracts/IIVPToken/#fn_balanceofat_4ee2cd7e","title":"<code>balanceOfAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function balanceOfAt(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Queries the token balance of <code>_owner</code> at a specific <code>_blockNumber</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address from which the balance will be retrieved. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The balance at <code>_blockNumber</code>."},{"location":"apis/smart-contracts/IIVPToken/#fn_batchdelegate_dc4fcda7","title":"<code>batchDelegate</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function batchDelegate(\n    address[] _delegatees,\n    uint256[] _bips\n) external;\n</code></pre> <p>Undelegate all percentage delegations from the sender and then <code>delegate</code> corresponding   <code>_bips</code> percentage of voting power from the sender to each member of the <code>_delegatees</code> array.</p> Parameters Type Description <code>_delegatees</code> <code>address[]</code> The addresses of the new recipients. <code>_bips</code> <code>uint256[]</code> The percentages of voting power to be delegated expressed in basis points (1/100 of one percent).   The sum of all <code>_bips</code> values must be at most 10000 (100%)."},{"location":"apis/smart-contracts/IIVPToken/#fn_batchvotepowerofat_49e3c7e5","title":"<code>batchVotePowerOfAt</code>","text":"<p>Defined in <code>IIVPToken</code> (Docs, Source).</p> <pre><code>function batchVotePowerOfAt(\n    address[] _owners,\n    uint256 _blockNumber\n) external view returns (\n    uint256[]);\n</code></pre> <p>Return the vote power for several addresses.</p> Parameters Type Description <code>_owners</code> <code>address[]</code> The list of addresses to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256[]</code> Array of vote power for each queried address."},{"location":"apis/smart-contracts/IIVPToken/#fn_cleanupblocknumber_deea13e7","title":"<code>cleanupBlockNumber</code>","text":"<p>Defined in <code>IICleanable</code> (Docs, Source).</p> <pre><code>function cleanupBlockNumber(\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current cleanup block number set with <code>setCleanupBlockNumber</code>.</p> Returns Type Description [0] <code>uint256</code> The currently set cleanup block number."},{"location":"apis/smart-contracts/IIVPToken/#fn_decimals_313ce567","title":"<code>decimals</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function decimals(\n) external view returns (\n    uint8);\n</code></pre> <p>Returns the number of <code>decimals</code> used to get its user representation. For example, if <code>decimals</code> equals 2, a balance of 505 tokens should be displayed to a user as 5.05 (505 / 10<sup>2</sup>).</p> <p>Tokens usually opt for a value of 18, imitating the relationship between Ether and wei. This is the default value returned by this function, unless it's overridden.</p> <p>NOTE: This information is only used for display purposes: it in no way affects any of the arithmetic of the contract, including <code>balanceOf</code> and <code>transfer</code>.</p> <p>Should be compatible with ERC20 method.</p>"},{"location":"apis/smart-contracts/IIVPToken/#fn_delegate_026e402b","title":"<code>delegate</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function delegate(\n    address _to,\n    uint256 _bips\n) external;\n</code></pre> <p>Delegate voting power to account <code>_to</code> from <code>msg.sender</code>, by percentage.</p> Parameters Type Description <code>_to</code> <code>address</code> The address of the recipient. <code>_bips</code> <code>uint256</code> The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).   Not cumulative: every call resets the delegation value (and a value of 0 revokes all previous delegations)."},{"location":"apis/smart-contracts/IIVPToken/#fn_delegateexplicit_d06dc3ad","title":"<code>delegateExplicit</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function delegateExplicit(\n    address _to,\n    uint256 _amount\n) external;\n</code></pre> <p>Explicitly <code>delegate</code> <code>_amount</code> voting power to account <code>_to</code> from <code>msg.sender</code>. Compare with <code>delegate</code> which delegates by percentage.</p> Parameters Type Description <code>_to</code> <code>address</code> The address of the recipient. <code>_amount</code> <code>uint256</code> An explicit vote power amount to be delegated.   Not cumulative: every call resets the delegation value (and a value of 0 revokes all previous delegations)."},{"location":"apis/smart-contracts/IIVPToken/#fn_delegatesof_7de5b8ed","title":"<code>delegatesOf</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function delegatesOf(\n    address _who\n) external view returns (\n    address[] _delegateAddresses,\n    uint256[] _bips,\n    uint256 _count,\n    uint256 _delegationMode);\n</code></pre> <p>Get the list of addresses to which <code>_who</code> is delegating, and their percentages.</p> Parameters Type Description <code>_who</code> <code>address</code> The address to query. Returns Type Description <code>_delegateAddresses</code> <code>address[]</code> Positional array of addresses being delegated to. <code>_bips</code> <code>uint256[]</code> Positional array of delegation percents specified in basis points (1/100 of 1 percent).    Each one matches the address in the same position in the <code>_delegateAddresses</code> array. <code>_count</code> <code>uint256</code> The number of delegates. <code>_delegationMode</code> <code>uint256</code> Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)."},{"location":"apis/smart-contracts/IIVPToken/#fn_delegatesofat_ed475a79","title":"<code>delegatesOfAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function delegatesOfAt(\n    address _who,\n    uint256 _blockNumber\n) external view returns (\n    address[] _delegateAddresses,\n    uint256[] _bips,\n    uint256 _count,\n    uint256 _delegationMode);\n</code></pre> <p>Get the list of addresses to which <code>_who</code> is delegating, and their percentages, at the given block.</p> Parameters Type Description <code>_who</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description <code>_delegateAddresses</code> <code>address[]</code> Positional array of addresses being delegated to. <code>_bips</code> <code>uint256[]</code> Positional array of delegation percents specified in basis points (1/100 of 1 percent).    Each one matches the address in the same position in the <code>_delegateAddresses</code> array. <code>_count</code> <code>uint256</code> The number of delegates. <code>_delegationMode</code> <code>uint256</code> Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)."},{"location":"apis/smart-contracts/IIVPToken/#fn_delegationmodeof_f6837767","title":"<code>delegationModeOf</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function delegationModeOf(\n    address _who\n) external view returns (\n    uint256);\n</code></pre> <p>Get the delegation mode for account '_who'. This mode determines whether vote power is allocated by percentage or by explicit amount. Once the delegation mode is set, it can never be changed, even if all delegations are removed.</p> Parameters Type Description <code>_who</code> <code>address</code> The address to get delegation mode. Returns Type Description [0] <code>uint256</code> Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)."},{"location":"apis/smart-contracts/IIVPToken/#fn_governancevotepower_8c2b8ae1","title":"<code>governanceVotePower</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function governanceVotePower(\n) external view returns (\n    contract IGovernanceVotePower);\n</code></pre> <p>When set, allows token owners to participate in governance voting and delegating governance vote power.</p>"},{"location":"apis/smart-contracts/IIVPToken/#fn_name_06fdde03","title":"<code>name</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function name(\n) external view returns (\n    string);\n</code></pre> <p>Returns the <code>name</code> of the token.</p> <p>Should be compatible with ERC20 method.</p>"},{"location":"apis/smart-contracts/IIVPToken/#fn_readvotepowercontract_9b3baa0e","title":"<code>readVotePowerContract</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function readVotePowerContract(\n) external view returns (\n    contract IVPContractEvents);\n</code></pre> <p>Returns <code>VPContract</code> event interface used for read-only operations (view methods). The only non-view method that might be called on it is <code>revokeDelegationAt</code>.</p> <p><code>readVotePowerContract</code> is almost always equal to <code>writeVotePowerContract</code> except during an upgrade from one <code>VPContract</code> to a new version (which should happen rarely or never and will be announced beforehand).</p> <p>Do not call any methods on <code>VPContract</code> directly. State changing methods are forbidden from direct calls. All methods are exposed via <code>VPToken</code>. This is the reason that this method returns <code>IVPContractEvents</code>. Use it only for listening to events and revoking.</p>"},{"location":"apis/smart-contracts/IIVPToken/#fn_revokedelegationat_bbd6fbf8","title":"<code>revokeDelegationAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function revokeDelegationAt(\n    address _who,\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Revoke all delegation from sender to <code>_who</code> at given block. Only affects the reads via <code>votePowerOfAtCached()</code> in the block <code>_blockNumber</code>. Block <code>_blockNumber</code> must be in the past. This method should be used only to prevent rogue <code>delegate</code> voting in the current voting block. To stop delegating use <code>delegate</code> / <code>delegateExplicit</code> with value of 0 or <code>undelegateAll</code> / <code>undelegateAllExplicit</code>.</p> Parameters Type Description <code>_who</code> <code>address</code> Address of the delegatee. <code>_blockNumber</code> <code>uint256</code> The block number at which to revoke delegation.."},{"location":"apis/smart-contracts/IIVPToken/#fn_setcleanercontract_f6a494af","title":"<code>setCleanerContract</code>","text":"<p>Defined in <code>IICleanable</code> (Docs, Source).</p> <pre><code>function setCleanerContract(\n    address _cleanerContract\n) external;\n</code></pre> <p>Set the contract that is allowed to call history cleaning methods.</p> Parameters Type Description <code>_cleanerContract</code> <code>address</code> Address of the cleanup contract. Usually this will be an instance of <code>CleanupBlockNumberManager</code>."},{"location":"apis/smart-contracts/IIVPToken/#fn_setcleanupblocknumber_13de97f5","title":"<code>setCleanupBlockNumber</code>","text":"<p>Defined in <code>IICleanable</code> (Docs, Source).</p> <pre><code>function setCleanupBlockNumber(\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Set the cleanup block number. Historic data for the blocks before <code>cleanupBlockNumber</code> can be erased. History before that block should never be used since it can be inconsistent. In particular, cleanup block number must be lower than the current vote power block.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The new cleanup block number."},{"location":"apis/smart-contracts/IIVPToken/#fn_setcleanupblocknumbermanager_7f4fcaa9","title":"<code>setCleanupBlockNumberManager</code>","text":"<p>Defined in <code>IIVPToken</code> (Docs, Source).</p> <pre><code>function setCleanupBlockNumberManager(\n    address _cleanupBlockNumberManager\n) external;\n</code></pre> <p>Set the contract that is allowed to set <code>cleanupBlockNumber</code>. Usually this will be an instance of <code>CleanupBlockNumberManager</code>.</p>"},{"location":"apis/smart-contracts/IIVPToken/#fn_setgovernancevotepower_9ca2231a","title":"<code>setGovernanceVotePower</code>","text":"<p>Defined in <code>IIVPToken</code> (Docs, Source).</p> <pre><code>function setGovernanceVotePower(\n    contract IIGovernanceVotePower _governanceVotePower\n) external;\n</code></pre> <p>Sets new governance vote power contract that allows token owners to participate in governance voting and <code>delegate</code> governance vote power.</p>"},{"location":"apis/smart-contracts/IIVPToken/#fn_symbol_95d89b41","title":"<code>symbol</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function symbol(\n) external view returns (\n    string);\n</code></pre> <p>Returns the <code>symbol</code> of the token, usually a shorter version of the <code>name</code>.</p> <p>Should be compatible with ERC20 method.</p>"},{"location":"apis/smart-contracts/IIVPToken/#fn_totalsupply_18160ddd","title":"<code>totalSupply</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function totalSupply(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the amount of tokens in existence.</p>"},{"location":"apis/smart-contracts/IIVPToken/#fn_totalsupplyat_981b24d0","title":"<code>totalSupplyAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function totalSupplyAt(\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Total amount of tokens held by all accounts at a specific block number.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The total amount of tokens at <code>_blockNumber</code>."},{"location":"apis/smart-contracts/IIVPToken/#fn_totalvotepower_f5f3d4f7","title":"<code>totalVotePower</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function totalVotePower(\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current total vote power.</p> Returns Type Description [0] <code>uint256</code> The current total vote power (sum of all accounts' vote power)."},{"location":"apis/smart-contracts/IIVPToken/#fn_totalvotepowerat_3e5aa26a","title":"<code>totalVotePowerAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function totalVotePowerAt(\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the total vote power at block <code>_blockNumber</code>.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The total vote power at the queried block (sum of all accounts' vote powers)."},{"location":"apis/smart-contracts/IIVPToken/#fn_totalvotepoweratcached_caeb942b","title":"<code>totalVotePowerAtCached</code>","text":"<p>Defined in <code>IIVPToken</code> (Docs, Source).</p> <pre><code>function totalVotePowerAtCached(\n    uint256 _blockNumber\n) external returns (\n    uint256);\n</code></pre> <p>Get the total vote power at block <code>_blockNumber</code> using cache.   It tries to read the cached value and if it is not found, reads the actual value and stores it in the cache.   Can only be used if <code>_blockNumber</code> is in the past, otherwise reverts.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The total vote power at the queried block (sum of all accounts' vote powers)."},{"location":"apis/smart-contracts/IIVPToken/#fn_transfer_a9059cbb","title":"<code>transfer</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function transfer(\n    address recipient,\n    uint256 amount\n) external returns (\n    bool);\n</code></pre> <p>Moves <code>amount</code> tokens from the caller's account to <code>recipient</code>.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>Emits a <code>Transfer</code> event.</p>"},{"location":"apis/smart-contracts/IIVPToken/#fn_transferfrom_23b872dd","title":"<code>transferFrom</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n) external returns (\n    bool);\n</code></pre> <p>Moves <code>amount</code> tokens from <code>sender</code> to <code>recipient</code> using the <code>allowance</code> mechanism. <code>amount</code> is then deducted from the caller's <code>allowance</code>.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>Emits a <code>Transfer</code> event.</p>"},{"location":"apis/smart-contracts/IIVPToken/#fn_undelegateall_b302f393","title":"<code>undelegateAll</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function undelegateAll(\n) external;\n</code></pre> <p>Undelegate all voting power of <code>msg.sender</code>. This effectively revokes all previous delegations. Can only be used with percentage delegation. Does not reset delegation mode back to NOT SET.</p>"},{"location":"apis/smart-contracts/IIVPToken/#fn_undelegateallexplicit_5d6d11eb","title":"<code>undelegateAllExplicit</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function undelegateAllExplicit(\n    address[] _delegateAddresses\n) external returns (\n    uint256);\n</code></pre> <p>Undelegate all explicit vote power by amount of <code>msg.sender</code>. Can only be used with explicit delegation. Does not reset delegation mode back to NOT SET.</p> Parameters Type Description <code>_delegateAddresses</code> <code>address[]</code> Explicit delegation does not store delegatees' addresses,   so the caller must supply them. Returns Type Description [0] <code>uint256</code> The amount still delegated (in case the list of delegates was incomplete)."},{"location":"apis/smart-contracts/IIVPToken/#fn_undelegatedvotepowerof_d6aa0b77","title":"<code>undelegatedVotePowerOf</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function undelegatedVotePowerOf(\n    address _owner\n) external view returns (\n    uint256);\n</code></pre> <p>Compute the current undelegated vote power of the <code>_owner</code> account.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. Returns Type Description [0] <code>uint256</code> The unallocated vote power of <code>_owner</code>."},{"location":"apis/smart-contracts/IIVPToken/#fn_undelegatedvotepowerofat_83035a82","title":"<code>undelegatedVotePowerOfAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function undelegatedVotePowerOfAt(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the undelegated vote power of the <code>_owner</code> account at a given block number.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The unallocated vote power of <code>_owner</code>."},{"location":"apis/smart-contracts/IIVPToken/#fn_votepowerfromto_be0ca747","title":"<code>votePowerFromTo</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function votePowerFromTo(\n    address _from,\n    address _to\n) external view returns (\n    uint256);\n</code></pre> <p>Get current delegated vote power from delegator <code>_from</code> to delegatee <code>_to</code>.</p> Parameters Type Description <code>_from</code> <code>address</code> Address of delegator. <code>_to</code> <code>address</code> Address of delegatee. Returns Type Description [0] <code>uint256</code> votePower The delegated vote power."},{"location":"apis/smart-contracts/IIVPToken/#fn_votepowerfromtoat_e64767aa","title":"<code>votePowerFromToAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function votePowerFromToAt(\n    address _from,\n    address _to,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get delegated vote power from delegator <code>_from</code> to delegatee <code>_to</code> at <code>_blockNumber</code>.</p> Parameters Type Description <code>_from</code> <code>address</code> Address of delegator. <code>_to</code> <code>address</code> Address of delegatee. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The delegated vote power."},{"location":"apis/smart-contracts/IIVPToken/#fn_votepowerof_142d1018","title":"<code>votePowerOf</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function votePowerOf(\n    address _owner\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current vote power of <code>_owner</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. Returns Type Description [0] <code>uint256</code> Current vote power of <code>_owner</code>."},{"location":"apis/smart-contracts/IIVPToken/#fn_votepowerofat_92bfe6d8","title":"<code>votePowerOfAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function votePowerOfAt(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the vote power of <code>_owner</code> at block <code>_blockNumber</code></p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> Vote power of <code>_owner</code> at block number <code>_blockNumber</code>."},{"location":"apis/smart-contracts/IIVPToken/#fn_votepowerofatcached_e587497e","title":"<code>votePowerOfAtCached</code>","text":"<p>Defined in <code>IIVPToken</code> (Docs, Source).</p> <pre><code>function votePowerOfAtCached(\n    address _owner,\n    uint256 _blockNumber\n) external returns (\n    uint256);\n</code></pre> <p>Get the vote power of <code>_owner</code> at block <code>_blockNumber</code> using cache.   It tries to read the cached value and if it is not found, reads the actual value and stores it in the cache.   Can only be used if <code>_blockNumber</code> is in the past, otherwise reverts.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> Vote power of <code>_owner</code> at <code>_blockNumber</code>."},{"location":"apis/smart-contracts/IIVPToken/#fn_votepowerofatignoringrevocation_04bb4e43","title":"<code>votePowerOfAtIgnoringRevocation</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function votePowerOfAtIgnoringRevocation(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the vote power of <code>_owner</code> at block <code>_blockNumber</code>, ignoring revocation information (and cache).</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> Vote power of <code>_owner</code> at block number <code>_blockNumber</code>. Result doesn't change if vote power is revoked."},{"location":"apis/smart-contracts/IIVPToken/#fn_writevotepowercontract_1fec092a","title":"<code>writeVotePowerContract</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function writeVotePowerContract(\n) external view returns (\n    contract IVPContractEvents);\n</code></pre> <p>Returns <code>VPContract</code> event interface used for state-changing operations (non-view methods). The only non-view method that might be called on it is <code>revokeDelegationAt</code>.</p> <p><code>writeVotePowerContract</code> is almost always equal to <code>readVotePowerContract</code>, except during upgrade from one <code>VPContract</code> to a new version (which should happen rarely or never and will be announced beforehand). In the case of an upgrade, <code>writeVotePowerContract</code> is replaced first to establish delegations. After some period (e.g., after a reward epoch ends), <code>readVotePowerContract</code> is set equal to it.</p> <p>Do not call any methods on <code>VPContract</code> directly. State changing methods are forbidden from direct calls. All are exposed via <code>VPToken</code>. This is the reason that this method returns <code>IVPContractEvents</code> Use it only for listening to events, delegating, and revoking.</p>"},{"location":"apis/smart-contracts/IIVoterWhitelister/","title":"IIVoterWhitelister","text":""},{"location":"apis/smart-contracts/IIVoterWhitelister/#ct_iivoterwhitelister","title":"<code>IIVoterWhitelister</code>","text":"<p>Source | Inherits from IVoterWhitelister</p> <p>Internal interface for managers of the FTSO whitelist.</p> <p>Only addresses registered in this contract can submit data to the FTSO system.</p>"},{"location":"apis/smart-contracts/IIVoterWhitelister/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IIVoterWhitelister/#fn_addftso_345705a4","title":"<code>addFtso</code>","text":"<p>Defined in <code>IIVoterWhitelister</code> (Docs, Source).</p> <pre><code>function addFtso(\n    uint256 _ftsoIndex\n) external;\n</code></pre> <p>Create an empty whitelist with default size for a new FTSO.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Index of the new FTSO."},{"location":"apis/smart-contracts/IIVoterWhitelister/#fn_chillvoter_2b4faebb","title":"<code>chillVoter</code>","text":"<p>Defined in <code>IIVoterWhitelister</code> (Docs, Source).</p> <pre><code>function chillVoter(\n    address _voter,\n    uint256 _noOfRewardEpochs,\n    uint256[] _ftsoIndices\n) external returns (\n    bool[] _removed,\n    uint256 _untilRewardEpoch);\n</code></pre> <p>Used to chill a data provider, this is, remove it from the whitelist for a specified number of reward epochs.</p> Parameters Type Description <code>_voter</code> <code>address</code> Data provider being chilled. <code>_noOfRewardEpochs</code> <code>uint256</code> Number of epochs to chill the provider for. <code>_ftsoIndices</code> <code>uint256[]</code> Array of indices of the FTSOs that will not allow this provider to submit data."},{"location":"apis/smart-contracts/IIVoterWhitelister/#fn_chilleduntilrewardepoch_46538074","title":"<code>chilledUntilRewardEpoch</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function chilledUntilRewardEpoch(\n    address _voter\n) external view returns (\n    uint256);\n</code></pre> <p>In case of providing bad prices (e.g. collusion), the voter can be chilled for a few reward epochs. A voter can whitelist again from a returned reward epoch onwards.</p> Parameters Type Description <code>_voter</code> <code>address</code> Address of the queried data provider. Returns Type Description [0] <code>uint256</code> uint256 ID of the epoch where the data provider can start submitting prices again."},{"location":"apis/smart-contracts/IIVoterWhitelister/#fn_defaultmaxvotersforftso_47ed51b1","title":"<code>defaultMaxVotersForFtso</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function defaultMaxVotersForFtso(\n) external view returns (\n    uint256);\n</code></pre> <p>Maximum number of voters in the whitelist for a new FTSO.</p> Returns Type Description [0] <code>uint256</code> uint256 Default maximum allowed voters."},{"location":"apis/smart-contracts/IIVoterWhitelister/#fn_getftsowhitelistedpriceproviders_09fcb400","title":"<code>getFtsoWhitelistedPriceProviders</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function getFtsoWhitelistedPriceProviders(\n    uint256 _ftsoIndex\n) external view returns (\n    address[]);\n</code></pre> <p>Gets whitelisted price providers for the FTSO at a given index.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Queried index. Returns Type Description [0] <code>address[]</code> Array of addresses of the whitelisted data providers."},{"location":"apis/smart-contracts/IIVoterWhitelister/#fn_getftsowhitelistedpriceprovidersbysymbol_aa89dfd4","title":"<code>getFtsoWhitelistedPriceProvidersBySymbol</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function getFtsoWhitelistedPriceProvidersBySymbol(\n    string _symbol\n) external view returns (\n    address[]);\n</code></pre> <p>Gets whitelisted price providers for the FTSO with a specified symbol.</p> Parameters Type Description <code>_symbol</code> <code>string</code> Queried symbol. Returns Type Description [0] <code>address[]</code> Array of addresses of the whitelisted data providers."},{"location":"apis/smart-contracts/IIVoterWhitelister/#fn_maxvotersforftso_98dccfc2","title":"<code>maxVotersForFtso</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function maxVotersForFtso(\n    uint256 _ftsoIndex\n) external view returns (\n    uint256);\n</code></pre> <p>Maximum number of voters in the whitelist for a specific FTSO. Adjustable separately for each index.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO. Returns Type Description [0] <code>uint256</code> uint256 Maximum allowed voters."},{"location":"apis/smart-contracts/IIVoterWhitelister/#fn_removeftso_d8736171","title":"<code>removeFtso</code>","text":"<p>Defined in <code>IIVoterWhitelister</code> (Docs, Source).</p> <pre><code>function removeFtso(\n    uint256 _ftsoIndex\n) external;\n</code></pre> <p>Clear whitelist for a removed FTSO.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Index of the removed FTSO."},{"location":"apis/smart-contracts/IIVoterWhitelister/#fn_removetrustedaddressfromwhitelist_9dc950ab","title":"<code>removeTrustedAddressFromWhitelist</code>","text":"<p>Defined in <code>IIVoterWhitelister</code> (Docs, Source).</p> <pre><code>function removeTrustedAddressFromWhitelist(\n    address _trustedAddress,\n    uint256 _ftsoIndex\n) external;\n</code></pre> <p>Remove a trusted address from whitelist.</p> Parameters Type Description <code>_trustedAddress</code> <code>address</code> Address to remove. <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO being modified."},{"location":"apis/smart-contracts/IIVoterWhitelister/#fn_requestfullvoterwhitelisting_b06cbaf7","title":"<code>requestFullVoterWhitelisting</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function requestFullVoterWhitelisting(\n    address _voter\n) external returns (\n    uint256[] _supportedIndices,\n    bool[] _success);\n</code></pre> <p>Requests whitelisting an account to act as a data provider for all active FTSOs. May be called by any address, including the voter itself.</p> Parameters Type Description <code>_voter</code> <code>address</code> Address of the voter to be whitelisted. Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of currently supported FTSO indices. <code>_success</code> <code>bool[]</code> Array of success flags by FTSO index."},{"location":"apis/smart-contracts/IIVoterWhitelister/#fn_requestwhitelistingvoter_3de2cb1c","title":"<code>requestWhitelistingVoter</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function requestWhitelistingVoter(\n    address _voter,\n    uint256 _ftsoIndex\n) external;\n</code></pre> <p>Requests whitelisting an account to act as a data provider for a specific FTSO. Reverts if the vote power of the account is too low. May be called by any address, including the voter itself.</p> Parameters Type Description <code>_voter</code> <code>address</code> Address of the voter to be whitelisted. <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO."},{"location":"apis/smart-contracts/IIVoterWhitelister/#fn_setdefaultmaxvotersforftso_2ee96140","title":"<code>setDefaultMaxVotersForFtso</code>","text":"<p>Defined in <code>IIVoterWhitelister</code> (Docs, Source).</p> <pre><code>function setDefaultMaxVotersForFtso(\n    uint256 _defaultMaxVotersForFtso\n) external;\n</code></pre> <p>Set the maximum number of voters in the whitelist for a new FTSOs.</p> Parameters Type Description <code>_defaultMaxVotersForFtso</code> <code>uint256</code> New maximum default value."},{"location":"apis/smart-contracts/IIVoterWhitelister/#fn_setmaxvotersforftso_7ecfcfa3","title":"<code>setMaxVotersForFtso</code>","text":"<p>Defined in <code>IIVoterWhitelister</code> (Docs, Source).</p> <pre><code>function setMaxVotersForFtso(\n    uint256 _ftsoIndex,\n    uint256 _newMaxVoters\n) external;\n</code></pre> <p>Set the maximum number of voters in the whitelist for a specific FTSO. Can remove voters with the least votepower from the whitelist.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO to modify. <code>_newMaxVoters</code> <code>uint256</code> New size of the whitelist."},{"location":"apis/smart-contracts/IInflationGenesis/","title":"IInflationGenesis","text":""},{"location":"apis/smart-contracts/IInflationGenesis/#ct_iinflationgenesis","title":"<code>IInflationGenesis</code>","text":"<p>Source</p> <p>Portion of the <code>Inflation</code> contract that is available to contracts deployed at genesis.</p>"},{"location":"apis/smart-contracts/IInflationGenesis/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IInflationGenesis/#fn_receiveminting_c611c2c5","title":"<code>receiveMinting</code>","text":"<p>Defined in <code>IInflationGenesis</code> (Docs, Source).</p> <pre><code>function receiveMinting(\n) external payable;\n</code></pre> <p>Receive newly minted native tokens from the <code>FlareDaemon</code>.</p> <p>Assume that the received amount will be &gt;= last topup requested across all services. If there is not enough balance sent to cover the topup request, expect the library method to revert. Also assume that any received balance greater than the calculated topup request came from self-destructor sending a balance to this contract.</p>"},{"location":"apis/smart-contracts/IPriceSubmitter/","title":"IPriceSubmitter","text":""},{"location":"apis/smart-contracts/IPriceSubmitter/#ct_ipricesubmitter","title":"<code>IPriceSubmitter</code>","text":"<p>Source</p> <p>Interface for the <code>PriceSubmitter</code> contract.</p> <p>This is the contract used by all FTSO data providers to submit their data.</p>"},{"location":"apis/smart-contracts/IPriceSubmitter/#events","title":"Events","text":""},{"location":"apis/smart-contracts/IPriceSubmitter/#ev_hashsubmitted","title":"<code>HashSubmitted</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>event HashSubmitted(\n    address submitter,\n    uint256 epochId,\n    bytes32 hash,\n    uint256 timestamp\n)\n</code></pre> <p>Emitted when a hash is submitted through <code>submitHash</code>.</p> Parameters Type Description <code>submitter</code> <code>address</code> Address of the submitting data provider. <code>epochId</code> <code>uint256</code> Current price epoch ID. <code>hash</code> <code>bytes32</code> Submitted hash. <code>timestamp</code> <code>uint256</code> Current block timestamp."},{"location":"apis/smart-contracts/IPriceSubmitter/#ev_pricesrevealed","title":"<code>PricesRevealed</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>event PricesRevealed(\n    address voter,\n    uint256 epochId,\n    contract IFtsoGenesis[] ftsos,\n    uint256[] prices,\n    uint256 random,\n    uint256 timestamp\n)\n</code></pre> <p>Emitted when prices are revealed through <code>revealPrice</code>.</p> Parameters Type Description <code>voter</code> <code>address</code> Address of the revealing data provider. <code>epochId</code> <code>uint256</code> ID of the epoch in which the price hash is revealed. <code>ftsos</code> <code>contract IFtsoGenesis[]</code> Array of FTSOs that correspond to the indexes in the call. <code>prices</code> <code>uint256[]</code> List of revealed prices. <code>random</code> <code>uint256</code> Revealed random number. <code>timestamp</code> <code>uint256</code> Current block timestamp."},{"location":"apis/smart-contracts/IPriceSubmitter/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IPriceSubmitter/#fn_getcurrentrandom_d89601fd","title":"<code>getCurrentRandom</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function getCurrentRandom(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the random number for the previous epoch, obtained from the random numbers provided by all data providers along with their data submissions. Note that the random number for the previous epoch keeps updating as new submissions are revealed.</p> Returns Type Description [0] <code>uint256</code> Random number calculated from all data provider's submissions."},{"location":"apis/smart-contracts/IPriceSubmitter/#fn_getftsomanager_b39c6858","title":"<code>getFtsoManager</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function getFtsoManager(\n) external view returns (\n    contract IFtsoManagerGenesis);\n</code></pre> <p>Returns the address of the <code>FtsoManager</code> contract.</p>"},{"location":"apis/smart-contracts/IPriceSubmitter/#fn_getftsoregistry_8c9d28b6","title":"<code>getFtsoRegistry</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function getFtsoRegistry(\n) external view returns (\n    contract IFtsoRegistryGenesis);\n</code></pre> <p>Returns the address of the <code>FtsoRegistry</code> contract.</p>"},{"location":"apis/smart-contracts/IPriceSubmitter/#fn_getrandom_cd4b6914","title":"<code>getRandom</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function getRandom(\n    uint256 _epochId\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the random number used in a specific past epoch, obtained from the random numbers provided by all data providers along with their data submissions.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the queried epoch. Current epoch cannot be queried, and the previous epoch is constantly updated as data providers reveal their prices and random numbers. Note that only the last 50 epochs can be queried and there is no bounds checking for this parameter. Out-of-bounds queries return undefined values. Returns Type Description [0] <code>uint256</code> The random number used in that epoch."},{"location":"apis/smart-contracts/IPriceSubmitter/#fn_getvoterwhitelister_71e1fad9","title":"<code>getVoterWhitelister</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function getVoterWhitelister(\n) external view returns (\n    address);\n</code></pre> <p>Returns the address of the <code>VoterWhitelister</code> contract managing the data provider whitelist.</p>"},{"location":"apis/smart-contracts/IPriceSubmitter/#fn_revealprices_e2db5a52","title":"<code>revealPrices</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function revealPrices(\n    uint256 _epochId,\n    uint256[] _ftsoIndices,\n    uint256[] _prices,\n    uint256 _random\n) external;\n</code></pre> <p>Reveals submitted prices during the epoch reveal period. The hash of FTSO indices, prices, random number, and voter address must be equal to the hash previously submitted with <code>submitHash</code>. Emits a <code>PricesRevealed</code> event.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch to which the price hashes are submitted. <code>_ftsoIndices</code> <code>uint256[]</code> List of FTSO indices in ascending order. <code>_prices</code> <code>uint256[]</code> List of submitted prices in USD. <code>_random</code> <code>uint256</code> Submitted random number."},{"location":"apis/smart-contracts/IPriceSubmitter/#fn_submithash_8fc6f667","title":"<code>submitHash</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function submitHash(\n    uint256 _epochId,\n    bytes32 _hash\n) external;\n</code></pre> <p>Submits a hash for the current epoch. Can only be called by FTSO data providers whitelisted through the <code>VoterWhitelisted</code> contract. Emits the <code>HashSubmitted</code> event.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the target epoch to which the hash is submitted. <code>_hash</code> <code>bytes32</code> A hash of the FTSO indices, prices, random number, and voter address."},{"location":"apis/smart-contracts/IPriceSubmitter/#fn_voterwhitelistbitmap_7ac420ad","title":"<code>voterWhitelistBitmap</code>","text":"<p>Defined in <code>IPriceSubmitter</code> (Docs, Source).</p> <pre><code>function voterWhitelistBitmap(\n    address _voter\n) external view returns (\n    uint256);\n</code></pre> <p>Returns a bitmap of all FTSOs for which a data provider is allowed to submit prices or hashes.</p> Parameters Type Description <code>_voter</code> <code>address</code> Address of the voter. Returns Type Description [0] <code>uint256</code> If a data provider is allowed to vote for a given FTSO index, the corresponding bit in the result is 1."},{"location":"apis/smart-contracts/IVPContractEvents/","title":"IVPContractEvents","text":""},{"location":"apis/smart-contracts/IVPContractEvents/#ct_ivpcontractevents","title":"<code>IVPContractEvents</code>","text":"<p>Source</p> <p>Events interface for vote-power related operations.</p>"},{"location":"apis/smart-contracts/IVPContractEvents/#events","title":"Events","text":""},{"location":"apis/smart-contracts/IVPContractEvents/#ev_delegate","title":"<code>Delegate</code>","text":"<p>Defined in <code>IVPContractEvents</code> (Docs, Source).</p> <pre><code>event Delegate(\n    address from,\n    address to,\n    uint256 priorVotePower,\n    uint256 newVotePower\n)\n</code></pre> <p>Emitted when the amount of vote power delegated from one account to another changes.</p> <p>Note: This event is always emitted from <code>VPToken</code>'s <code>writeVotePowerContract</code>.</p> Parameters Type Description <code>from</code> <code>address</code> The account that has changed the amount of vote power it is delegating. <code>to</code> <code>address</code> The account whose received vote power has changed. <code>priorVotePower</code> <code>uint256</code> The vote power originally delegated. <code>newVotePower</code> <code>uint256</code> The new vote power that triggered this event. It can be 0 if the delegation is completely canceled."},{"location":"apis/smart-contracts/IVPContractEvents/#ev_revoke","title":"<code>Revoke</code>","text":"<p>Defined in <code>IVPContractEvents</code> (Docs, Source).</p> <pre><code>event Revoke(\n    address delegator,\n    address delegatee,\n    uint256 votePower,\n    uint256 blockNumber\n)\n</code></pre> <p>Emitted when an account revokes its vote power delegation to another account for a single current or past block (typically the current vote block).</p> <p>Note: This event is always emitted from <code>VPToken</code>'s <code>writeVotePowerContract</code> or <code>readVotePowerContract</code>.</p> <p>See <code>revokeDelegationAt</code> in <code>IVPToken</code>.</p> Parameters Type Description <code>delegator</code> <code>address</code> The account that revoked the delegation. <code>delegatee</code> <code>address</code> The account that has been revoked. <code>votePower</code> <code>uint256</code> The revoked vote power. <code>blockNumber</code> <code>uint256</code> The block number at which the delegation has been revoked."},{"location":"apis/smart-contracts/IVPToken/","title":"IVPToken","text":""},{"location":"apis/smart-contracts/IVPToken/#ct_ivptoken","title":"<code>IVPToken</code>","text":"<p>Source | Inherits from IERC20</p> <p>Vote power token interface.</p>"},{"location":"apis/smart-contracts/IVPToken/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IVPToken/#fn_allowance_dd62ed3e","title":"<code>allowance</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function allowance(\n    address owner,\n    address spender\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the remaining number of tokens that <code>spender</code> will be allowed to spend on behalf of <code>owner</code> through <code>transferFrom</code>. This is zero by default.</p> <p>This value changes when <code>approve</code> or <code>transferFrom</code> are called.</p>"},{"location":"apis/smart-contracts/IVPToken/#fn_approve_095ea7b3","title":"<code>approve</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function approve(\n    address spender,\n    uint256 amount\n) external returns (\n    bool);\n</code></pre> <p>Sets <code>amount</code> as the <code>allowance</code> of <code>spender</code> over the caller's tokens.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>IMPORTANT: Beware that changing an <code>allowance</code> with this method brings the risk that someone may use both the old and the new <code>allowance</code> by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's <code>allowance</code> to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</p> <p>Emits an <code>Approval</code> event.</p>"},{"location":"apis/smart-contracts/IVPToken/#fn_balanceof_70a08231","title":"<code>balanceOf</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function balanceOf(\n    address account\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the amount of tokens owned by <code>account</code>.</p>"},{"location":"apis/smart-contracts/IVPToken/#fn_balanceofat_4ee2cd7e","title":"<code>balanceOfAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function balanceOfAt(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Queries the token balance of <code>_owner</code> at a specific <code>_blockNumber</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address from which the balance will be retrieved. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The balance at <code>_blockNumber</code>."},{"location":"apis/smart-contracts/IVPToken/#fn_batchdelegate_dc4fcda7","title":"<code>batchDelegate</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function batchDelegate(\n    address[] _delegatees,\n    uint256[] _bips\n) external;\n</code></pre> <p>Undelegate all percentage delegations from the sender and then <code>delegate</code> corresponding   <code>_bips</code> percentage of voting power from the sender to each member of the <code>_delegatees</code> array.</p> Parameters Type Description <code>_delegatees</code> <code>address[]</code> The addresses of the new recipients. <code>_bips</code> <code>uint256[]</code> The percentages of voting power to be delegated expressed in basis points (1/100 of one percent).   The sum of all <code>_bips</code> values must be at most 10000 (100%)."},{"location":"apis/smart-contracts/IVPToken/#fn_decimals_313ce567","title":"<code>decimals</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function decimals(\n) external view returns (\n    uint8);\n</code></pre> <p>Returns the number of <code>decimals</code> used to get its user representation. For example, if <code>decimals</code> equals 2, a balance of 505 tokens should be displayed to a user as 5.05 (505 / 10<sup>2</sup>).</p> <p>Tokens usually opt for a value of 18, imitating the relationship between Ether and wei. This is the default value returned by this function, unless it's overridden.</p> <p>NOTE: This information is only used for display purposes: it in no way affects any of the arithmetic of the contract, including <code>balanceOf</code> and <code>transfer</code>.</p> <p>Should be compatible with ERC20 method.</p>"},{"location":"apis/smart-contracts/IVPToken/#fn_delegate_026e402b","title":"<code>delegate</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function delegate(\n    address _to,\n    uint256 _bips\n) external;\n</code></pre> <p>Delegate voting power to account <code>_to</code> from <code>msg.sender</code>, by percentage.</p> Parameters Type Description <code>_to</code> <code>address</code> The address of the recipient. <code>_bips</code> <code>uint256</code> The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).   Not cumulative: every call resets the delegation value (and a value of 0 revokes all previous delegations)."},{"location":"apis/smart-contracts/IVPToken/#fn_delegateexplicit_d06dc3ad","title":"<code>delegateExplicit</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function delegateExplicit(\n    address _to,\n    uint256 _amount\n) external;\n</code></pre> <p>Explicitly <code>delegate</code> <code>_amount</code> voting power to account <code>_to</code> from <code>msg.sender</code>. Compare with <code>delegate</code> which delegates by percentage.</p> Parameters Type Description <code>_to</code> <code>address</code> The address of the recipient. <code>_amount</code> <code>uint256</code> An explicit vote power amount to be delegated.   Not cumulative: every call resets the delegation value (and a value of 0 revokes all previous delegations)."},{"location":"apis/smart-contracts/IVPToken/#fn_delegatesof_7de5b8ed","title":"<code>delegatesOf</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function delegatesOf(\n    address _who\n) external view returns (\n    address[] _delegateAddresses,\n    uint256[] _bips,\n    uint256 _count,\n    uint256 _delegationMode);\n</code></pre> <p>Get the list of addresses to which <code>_who</code> is delegating, and their percentages.</p> Parameters Type Description <code>_who</code> <code>address</code> The address to query. Returns Type Description <code>_delegateAddresses</code> <code>address[]</code> Positional array of addresses being delegated to. <code>_bips</code> <code>uint256[]</code> Positional array of delegation percents specified in basis points (1/100 of 1 percent).    Each one matches the address in the same position in the <code>_delegateAddresses</code> array. <code>_count</code> <code>uint256</code> The number of delegates. <code>_delegationMode</code> <code>uint256</code> Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)."},{"location":"apis/smart-contracts/IVPToken/#fn_delegatesofat_ed475a79","title":"<code>delegatesOfAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function delegatesOfAt(\n    address _who,\n    uint256 _blockNumber\n) external view returns (\n    address[] _delegateAddresses,\n    uint256[] _bips,\n    uint256 _count,\n    uint256 _delegationMode);\n</code></pre> <p>Get the list of addresses to which <code>_who</code> is delegating, and their percentages, at the given block.</p> Parameters Type Description <code>_who</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description <code>_delegateAddresses</code> <code>address[]</code> Positional array of addresses being delegated to. <code>_bips</code> <code>uint256[]</code> Positional array of delegation percents specified in basis points (1/100 of 1 percent).    Each one matches the address in the same position in the <code>_delegateAddresses</code> array. <code>_count</code> <code>uint256</code> The number of delegates. <code>_delegationMode</code> <code>uint256</code> Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)."},{"location":"apis/smart-contracts/IVPToken/#fn_delegationmodeof_f6837767","title":"<code>delegationModeOf</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function delegationModeOf(\n    address _who\n) external view returns (\n    uint256);\n</code></pre> <p>Get the delegation mode for account '_who'. This mode determines whether vote power is allocated by percentage or by explicit amount. Once the delegation mode is set, it can never be changed, even if all delegations are removed.</p> Parameters Type Description <code>_who</code> <code>address</code> The address to get delegation mode. Returns Type Description [0] <code>uint256</code> Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)."},{"location":"apis/smart-contracts/IVPToken/#fn_governancevotepower_8c2b8ae1","title":"<code>governanceVotePower</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function governanceVotePower(\n) external view returns (\n    contract IGovernanceVotePower);\n</code></pre> <p>When set, allows token owners to participate in governance voting and delegating governance vote power.</p>"},{"location":"apis/smart-contracts/IVPToken/#fn_name_06fdde03","title":"<code>name</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function name(\n) external view returns (\n    string);\n</code></pre> <p>Returns the <code>name</code> of the token.</p> <p>Should be compatible with ERC20 method.</p>"},{"location":"apis/smart-contracts/IVPToken/#fn_readvotepowercontract_9b3baa0e","title":"<code>readVotePowerContract</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function readVotePowerContract(\n) external view returns (\n    contract IVPContractEvents);\n</code></pre> <p>Returns <code>VPContract</code> event interface used for read-only operations (view methods). The only non-view method that might be called on it is <code>revokeDelegationAt</code>.</p> <p><code>readVotePowerContract</code> is almost always equal to <code>writeVotePowerContract</code> except during an upgrade from one <code>VPContract</code> to a new version (which should happen rarely or never and will be announced beforehand).</p> <p>Do not call any methods on <code>VPContract</code> directly. State changing methods are forbidden from direct calls. All methods are exposed via <code>VPToken</code>. This is the reason that this method returns <code>IVPContractEvents</code>. Use it only for listening to events and revoking.</p>"},{"location":"apis/smart-contracts/IVPToken/#fn_revokedelegationat_bbd6fbf8","title":"<code>revokeDelegationAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function revokeDelegationAt(\n    address _who,\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Revoke all delegation from sender to <code>_who</code> at given block. Only affects the reads via <code>votePowerOfAtCached()</code> in the block <code>_blockNumber</code>. Block <code>_blockNumber</code> must be in the past. This method should be used only to prevent rogue <code>delegate</code> voting in the current voting block. To stop delegating use <code>delegate</code> / <code>delegateExplicit</code> with value of 0 or <code>undelegateAll</code> / <code>undelegateAllExplicit</code>.</p> Parameters Type Description <code>_who</code> <code>address</code> Address of the delegatee. <code>_blockNumber</code> <code>uint256</code> The block number at which to revoke delegation.."},{"location":"apis/smart-contracts/IVPToken/#fn_symbol_95d89b41","title":"<code>symbol</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function symbol(\n) external view returns (\n    string);\n</code></pre> <p>Returns the <code>symbol</code> of the token, usually a shorter version of the <code>name</code>.</p> <p>Should be compatible with ERC20 method.</p>"},{"location":"apis/smart-contracts/IVPToken/#fn_totalsupply_18160ddd","title":"<code>totalSupply</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function totalSupply(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the amount of tokens in existence.</p>"},{"location":"apis/smart-contracts/IVPToken/#fn_totalsupplyat_981b24d0","title":"<code>totalSupplyAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function totalSupplyAt(\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Total amount of tokens held by all accounts at a specific block number.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The total amount of tokens at <code>_blockNumber</code>."},{"location":"apis/smart-contracts/IVPToken/#fn_totalvotepower_f5f3d4f7","title":"<code>totalVotePower</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function totalVotePower(\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current total vote power.</p> Returns Type Description [0] <code>uint256</code> The current total vote power (sum of all accounts' vote power)."},{"location":"apis/smart-contracts/IVPToken/#fn_totalvotepowerat_3e5aa26a","title":"<code>totalVotePowerAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function totalVotePowerAt(\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the total vote power at block <code>_blockNumber</code>.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The total vote power at the queried block (sum of all accounts' vote powers)."},{"location":"apis/smart-contracts/IVPToken/#fn_transfer_a9059cbb","title":"<code>transfer</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function transfer(\n    address recipient,\n    uint256 amount\n) external returns (\n    bool);\n</code></pre> <p>Moves <code>amount</code> tokens from the caller's account to <code>recipient</code>.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>Emits a <code>Transfer</code> event.</p>"},{"location":"apis/smart-contracts/IVPToken/#fn_transferfrom_23b872dd","title":"<code>transferFrom</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n) external returns (\n    bool);\n</code></pre> <p>Moves <code>amount</code> tokens from <code>sender</code> to <code>recipient</code> using the <code>allowance</code> mechanism. <code>amount</code> is then deducted from the caller's <code>allowance</code>.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>Emits a <code>Transfer</code> event.</p>"},{"location":"apis/smart-contracts/IVPToken/#fn_undelegateall_b302f393","title":"<code>undelegateAll</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function undelegateAll(\n) external;\n</code></pre> <p>Undelegate all voting power of <code>msg.sender</code>. This effectively revokes all previous delegations. Can only be used with percentage delegation. Does not reset delegation mode back to NOT SET.</p>"},{"location":"apis/smart-contracts/IVPToken/#fn_undelegateallexplicit_5d6d11eb","title":"<code>undelegateAllExplicit</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function undelegateAllExplicit(\n    address[] _delegateAddresses\n) external returns (\n    uint256);\n</code></pre> <p>Undelegate all explicit vote power by amount of <code>msg.sender</code>. Can only be used with explicit delegation. Does not reset delegation mode back to NOT SET.</p> Parameters Type Description <code>_delegateAddresses</code> <code>address[]</code> Explicit delegation does not store delegatees' addresses,   so the caller must supply them. Returns Type Description [0] <code>uint256</code> The amount still delegated (in case the list of delegates was incomplete)."},{"location":"apis/smart-contracts/IVPToken/#fn_undelegatedvotepowerof_d6aa0b77","title":"<code>undelegatedVotePowerOf</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function undelegatedVotePowerOf(\n    address _owner\n) external view returns (\n    uint256);\n</code></pre> <p>Compute the current undelegated vote power of the <code>_owner</code> account.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. Returns Type Description [0] <code>uint256</code> The unallocated vote power of <code>_owner</code>."},{"location":"apis/smart-contracts/IVPToken/#fn_undelegatedvotepowerofat_83035a82","title":"<code>undelegatedVotePowerOfAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function undelegatedVotePowerOfAt(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the undelegated vote power of the <code>_owner</code> account at a given block number.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The unallocated vote power of <code>_owner</code>."},{"location":"apis/smart-contracts/IVPToken/#fn_votepowerfromto_be0ca747","title":"<code>votePowerFromTo</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function votePowerFromTo(\n    address _from,\n    address _to\n) external view returns (\n    uint256);\n</code></pre> <p>Get current delegated vote power from delegator <code>_from</code> to delegatee <code>_to</code>.</p> Parameters Type Description <code>_from</code> <code>address</code> Address of delegator. <code>_to</code> <code>address</code> Address of delegatee. Returns Type Description [0] <code>uint256</code> votePower The delegated vote power."},{"location":"apis/smart-contracts/IVPToken/#fn_votepowerfromtoat_e64767aa","title":"<code>votePowerFromToAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function votePowerFromToAt(\n    address _from,\n    address _to,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get delegated vote power from delegator <code>_from</code> to delegatee <code>_to</code> at <code>_blockNumber</code>.</p> Parameters Type Description <code>_from</code> <code>address</code> Address of delegator. <code>_to</code> <code>address</code> Address of delegatee. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The delegated vote power."},{"location":"apis/smart-contracts/IVPToken/#fn_votepowerof_142d1018","title":"<code>votePowerOf</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function votePowerOf(\n    address _owner\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current vote power of <code>_owner</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. Returns Type Description [0] <code>uint256</code> Current vote power of <code>_owner</code>."},{"location":"apis/smart-contracts/IVPToken/#fn_votepowerofat_92bfe6d8","title":"<code>votePowerOfAt</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function votePowerOfAt(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the vote power of <code>_owner</code> at block <code>_blockNumber</code></p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> Vote power of <code>_owner</code> at block number <code>_blockNumber</code>."},{"location":"apis/smart-contracts/IVPToken/#fn_votepowerofatignoringrevocation_04bb4e43","title":"<code>votePowerOfAtIgnoringRevocation</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function votePowerOfAtIgnoringRevocation(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the vote power of <code>_owner</code> at block <code>_blockNumber</code>, ignoring revocation information (and cache).</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> Vote power of <code>_owner</code> at block number <code>_blockNumber</code>. Result doesn't change if vote power is revoked."},{"location":"apis/smart-contracts/IVPToken/#fn_writevotepowercontract_1fec092a","title":"<code>writeVotePowerContract</code>","text":"<p>Defined in <code>IVPToken</code> (Docs, Source).</p> <pre><code>function writeVotePowerContract(\n) external view returns (\n    contract IVPContractEvents);\n</code></pre> <p>Returns <code>VPContract</code> event interface used for state-changing operations (non-view methods). The only non-view method that might be called on it is <code>revokeDelegationAt</code>.</p> <p><code>writeVotePowerContract</code> is almost always equal to <code>readVotePowerContract</code>, except during upgrade from one <code>VPContract</code> to a new version (which should happen rarely or never and will be announced beforehand). In the case of an upgrade, <code>writeVotePowerContract</code> is replaced first to establish delegations. After some period (e.g., after a reward epoch ends), <code>readVotePowerContract</code> is set equal to it.</p> <p>Do not call any methods on <code>VPContract</code> directly. State changing methods are forbidden from direct calls. All are exposed via <code>VPToken</code>. This is the reason that this method returns <code>IVPContractEvents</code> Use it only for listening to events, delegating, and revoking.</p>"},{"location":"apis/smart-contracts/IVoterWhitelister/","title":"IVoterWhitelister","text":""},{"location":"apis/smart-contracts/IVoterWhitelister/#ct_ivoterwhitelister","title":"<code>IVoterWhitelister</code>","text":"<p>Source</p> <p>Interface for managers of the FTSO whitelist.</p> <p>Only addresses registered in this contract can submit data to the FTSO system.</p>"},{"location":"apis/smart-contracts/IVoterWhitelister/#events","title":"Events","text":""},{"location":"apis/smart-contracts/IVoterWhitelister/#ev_voterchilled","title":"<code>VoterChilled</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>event VoterChilled(\n    address voter,\n    uint256 untilRewardEpoch\n)\n</code></pre> <p>Emitted when an account is chilled from the voter whitelist.</p> Parameters Type Description <code>voter</code> <code>address</code> Address of the chilled account. <code>untilRewardEpoch</code> <code>uint256</code> Epoch ID when the chill will be lifted."},{"location":"apis/smart-contracts/IVoterWhitelister/#ev_voterremovedfromwhitelist","title":"<code>VoterRemovedFromWhitelist</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>event VoterRemovedFromWhitelist(\n    address voter,\n    uint256 ftsoIndex\n)\n</code></pre> <p>Emitted when an account is removed from the voter whitelist.</p> Parameters Type Description <code>voter</code> <code>address</code> Address of the removed account. <code>ftsoIndex</code> <code>uint256</code> Index of the FTSO in which it was registered."},{"location":"apis/smart-contracts/IVoterWhitelister/#ev_voterwhitelisted","title":"<code>VoterWhitelisted</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>event VoterWhitelisted(\n    address voter,\n    uint256 ftsoIndex\n)\n</code></pre> <p>Emitted when an account is added to the voter whitelist.</p> Parameters Type Description <code>voter</code> <code>address</code> Address of the added account. <code>ftsoIndex</code> <code>uint256</code> Index of the FTSO to which it has been registered."},{"location":"apis/smart-contracts/IVoterWhitelister/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IVoterWhitelister/#fn_chilleduntilrewardepoch_46538074","title":"<code>chilledUntilRewardEpoch</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function chilledUntilRewardEpoch(\n    address _voter\n) external view returns (\n    uint256);\n</code></pre> <p>In case of providing bad prices (e.g. collusion), the voter can be chilled for a few reward epochs. A voter can whitelist again from a returned reward epoch onwards.</p> Parameters Type Description <code>_voter</code> <code>address</code> Address of the queried data provider. Returns Type Description [0] <code>uint256</code> uint256 ID of the epoch where the data provider can start submitting prices again."},{"location":"apis/smart-contracts/IVoterWhitelister/#fn_defaultmaxvotersforftso_47ed51b1","title":"<code>defaultMaxVotersForFtso</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function defaultMaxVotersForFtso(\n) external view returns (\n    uint256);\n</code></pre> <p>Maximum number of voters in the whitelist for a new FTSO.</p> Returns Type Description [0] <code>uint256</code> uint256 Default maximum allowed voters."},{"location":"apis/smart-contracts/IVoterWhitelister/#fn_getftsowhitelistedpriceproviders_09fcb400","title":"<code>getFtsoWhitelistedPriceProviders</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function getFtsoWhitelistedPriceProviders(\n    uint256 _ftsoIndex\n) external view returns (\n    address[]);\n</code></pre> <p>Gets whitelisted price providers for the FTSO at a given index.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Queried index. Returns Type Description [0] <code>address[]</code> Array of addresses of the whitelisted data providers."},{"location":"apis/smart-contracts/IVoterWhitelister/#fn_getftsowhitelistedpriceprovidersbysymbol_aa89dfd4","title":"<code>getFtsoWhitelistedPriceProvidersBySymbol</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function getFtsoWhitelistedPriceProvidersBySymbol(\n    string _symbol\n) external view returns (\n    address[]);\n</code></pre> <p>Gets whitelisted price providers for the FTSO with a specified symbol.</p> Parameters Type Description <code>_symbol</code> <code>string</code> Queried symbol. Returns Type Description [0] <code>address[]</code> Array of addresses of the whitelisted data providers."},{"location":"apis/smart-contracts/IVoterWhitelister/#fn_maxvotersforftso_98dccfc2","title":"<code>maxVotersForFtso</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function maxVotersForFtso(\n    uint256 _ftsoIndex\n) external view returns (\n    uint256);\n</code></pre> <p>Maximum number of voters in the whitelist for a specific FTSO. Adjustable separately for each index.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO. Returns Type Description [0] <code>uint256</code> uint256 Maximum allowed voters."},{"location":"apis/smart-contracts/IVoterWhitelister/#fn_requestfullvoterwhitelisting_b06cbaf7","title":"<code>requestFullVoterWhitelisting</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function requestFullVoterWhitelisting(\n    address _voter\n) external returns (\n    uint256[] _supportedIndices,\n    bool[] _success);\n</code></pre> <p>Requests whitelisting an account to act as a data provider for all active FTSOs. May be called by any address, including the voter itself.</p> Parameters Type Description <code>_voter</code> <code>address</code> Address of the voter to be whitelisted. Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of currently supported FTSO indices. <code>_success</code> <code>bool[]</code> Array of success flags by FTSO index."},{"location":"apis/smart-contracts/IVoterWhitelister/#fn_requestwhitelistingvoter_3de2cb1c","title":"<code>requestWhitelistingVoter</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function requestWhitelistingVoter(\n    address _voter,\n    uint256 _ftsoIndex\n) external;\n</code></pre> <p>Requests whitelisting an account to act as a data provider for a specific FTSO. Reverts if the vote power of the account is too low. May be called by any address, including the voter itself.</p> Parameters Type Description <code>_voter</code> <code>address</code> Address of the voter to be whitelisted. <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO."},{"location":"apis/smart-contracts/IWNat/","title":"IWNat","text":""},{"location":"apis/smart-contracts/IWNat/#ct_iwnat","title":"<code>IWNat</code>","text":"<p>Source</p> <p>Wrapped native token interface.</p> <p>This contract converts native tokens into <code>WNAT</code> (wrapped native) tokens and vice versa. <code>WNAT</code> tokens are a one-to-one ERC20 representation of native tokens, which are minted and burned as needed by this contract.</p> <p>The wrapped versions of the native <code>FLR</code> and <code>SGB</code> tokens are called <code>WFLR</code> and <code>WSGB</code> respectively.</p> <p>Code attribution: WETH9.</p>"},{"location":"apis/smart-contracts/IWNat/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/IWNat/#fn_deposit_d0e30db0","title":"<code>deposit</code>","text":"<p>Defined in <code>IWNat</code> (Docs, Source).</p> <pre><code>function deposit(\n) external payable;\n</code></pre> <p>Deposits native tokens and mints the same amount of <code>WNAT</code> tokens, which are added to the <code>msg.sender</code>'s balance. This operation is commonly known as \"wrapping\".</p>"},{"location":"apis/smart-contracts/IWNat/#fn_depositto_b760faf9","title":"<code>depositTo</code>","text":"<p>Defined in <code>IWNat</code> (Docs, Source).</p> <pre><code>function depositTo(\n    address _recipient\n) external payable;\n</code></pre> <p>Deposits native tokens and mints the same amount of <code>WNAT</code> tokens, which are added to <code>_recipient</code>'s balance. This operation is commonly known as \"wrapping\".</p> <p>This is equivalent to using <code>deposit</code> followed by <code>transfer</code>.</p> Parameters Type Description <code>_recipient</code> <code>address</code> The address to receive the minted <code>WNAT</code>."},{"location":"apis/smart-contracts/IWNat/#fn_withdraw_2e1a7d4d","title":"<code>withdraw</code>","text":"<p>Defined in <code>IWNat</code> (Docs, Source).</p> <pre><code>function withdraw(\n    uint256 _amount\n) external;\n</code></pre> <p>Burns <code>_amount</code> of <code>WNAT</code> tokens from <code>msg.sender</code>'s <code>WNAT</code> balance and transfers the same amount of native tokens to <code>msg.sender</code>. This operation is commonly known as \"unwrapping\".</p> <p>Reverts if <code>_amount</code> is higher than <code>msg.sender</code>'s <code>WNAT</code> balance.</p> Parameters Type Description <code>_amount</code> <code>uint256</code> The amount to withdraw."},{"location":"apis/smart-contracts/IWNat/#fn_withdrawfrom_9470b0bd","title":"<code>withdrawFrom</code>","text":"<p>Defined in <code>IWNat</code> (Docs, Source).</p> <pre><code>function withdrawFrom(\n    address _owner,\n    uint256 _amount\n) external;\n</code></pre> <p>Burns <code>_amount</code> of <code>WNAT</code> tokens from <code>_owner</code>'s <code>WNAT</code> balance and transfers the same amount of native tokens to <code>msg.sender</code>. This operation is commonly known as \"unwrapping\".</p> <p><code>msg.sender</code> must have been authorized to <code>withdraw</code> from <code>_owner</code>'s account through ERC-20's approve mechanism.</p> <p>Reverts if <code>_amount</code> is higher than <code>_owners</code>'s <code>WNAT</code> balance or than <code>msg.sender</code>'s allowance over <code>_owner</code>'s tokens.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address containing the tokens to withdraw. <code>_amount</code> <code>uint256</code> The amount to withdraw."},{"location":"apis/smart-contracts/Inflation/","title":"Inflation","text":""},{"location":"apis/smart-contracts/Inflation/#ct_inflation","title":"<code>Inflation</code>","text":"<p>Source | Inherits from IInflationGenesis, GovernedAndFlareDaemonized, IFlareDaemonize, AddressUpdatable</p> <p>Recognizes, authorizes, mints, and funds native tokens to Flare services that are rewardable through inflation.</p> <p>See the technical specification.</p>"},{"location":"apis/smart-contracts/Inflation/#events","title":"Events","text":""},{"location":"apis/smart-contracts/Inflation/#ev_governancecalltimelocked","title":"<code>GovernanceCallTimelocked</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernanceCallTimelocked(\n    bytes4 selector,\n    uint256 allowedAfterTimestamp,\n    bytes encodedCall\n)\n</code></pre> <p>Emitted when a new <code>governance</code> call has been recorded and is now waiting for the time lock to expire.</p>"},{"location":"apis/smart-contracts/Inflation/#ev_governanceinitialised","title":"<code>GovernanceInitialised</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernanceInitialised(\n    address initialGovernance\n)\n</code></pre> <p>Emitted when the <code>governance</code> address is initialized. This address will be used until production mode is entered (see <code>GovernedProductionModeEntered</code>). At that point the <code>governance</code> address is taken from <code>GovernanceSettings</code>.</p>"},{"location":"apis/smart-contracts/Inflation/#ev_governedproductionmodeentered","title":"<code>GovernedProductionModeEntered</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernedProductionModeEntered(\n    address governanceSettings\n)\n</code></pre> <p>Emitted when <code>governance</code> is enabled and the <code>governance</code> address cannot be changed anymore (only through a network fork).</p>"},{"location":"apis/smart-contracts/Inflation/#ev_inflationallocationset","title":"<code>InflationAllocationSet</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>event InflationAllocationSet(\n    contract IIInflationAllocation inflationAllocation\n)\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#ev_inflationauthorized","title":"<code>InflationAuthorized</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>event InflationAuthorized(\n    uint256 amountWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#ev_inflationrewardservicedailyauthorizedinflationcomputed","title":"<code>InflationRewardServiceDailyAuthorizedInflationComputed</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>event InflationRewardServiceDailyAuthorizedInflationComputed(\n    contract IIInflationReceiver inflationReceiver,\n    uint256 amountWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#ev_inflationrewardservicetopupcomputed","title":"<code>InflationRewardServiceTopupComputed</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>event InflationRewardServiceTopupComputed(\n    contract IIInflationReceiver inflationReceiver,\n    uint256 amountWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#ev_inflationrewardservicetopuprequestreceived","title":"<code>InflationRewardServiceTopupRequestReceived</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>event InflationRewardServiceTopupRequestReceived(\n    contract IIInflationReceiver inflationReceiver,\n    uint256 amountWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#ev_mintingreceived","title":"<code>MintingReceived</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>event MintingReceived(\n    uint256 amountWei,\n    uint256 selfDestructAmountWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#ev_newtimeslotinitialized","title":"<code>NewTimeSlotInitialized</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>event NewTimeSlotInitialized(\n    uint256 startTimeStamp,\n    uint256 endTimeStamp,\n    uint256 inflatableSupplyWei,\n    uint256 recognizedInflationWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#ev_supplyset","title":"<code>SupplySet</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>event SupplySet(\n    contract IISupply oldSupply,\n    contract IISupply newSupply\n)\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#ev_timelockedgovernancecallcanceled","title":"<code>TimelockedGovernanceCallCanceled</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event TimelockedGovernanceCallCanceled(\n    bytes4 selector,\n    uint256 timestamp\n)\n</code></pre> <p>Emitted when a timelocked <code>governance</code> call is canceled before execution.</p>"},{"location":"apis/smart-contracts/Inflation/#ev_timelockedgovernancecallexecuted","title":"<code>TimelockedGovernanceCallExecuted</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event TimelockedGovernanceCallExecuted(\n    bytes4 selector,\n    uint256 timestamp\n)\n</code></pre> <p>Emitted when a timelocked <code>governance</code> call is executed.</p>"},{"location":"apis/smart-contracts/Inflation/#ev_topupconfigurationset","title":"<code>TopupConfigurationSet</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>event TopupConfigurationSet(\n    struct TopupConfiguration topupConfiguration\n)\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#ev_topuprequested","title":"<code>TopupRequested</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>event TopupRequested(\n    uint256 requestAmountWei,\n    uint256 reRequestAmountWei\n)\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/Inflation/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/Inflation/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance,\n    contract FlareDaemon _flareDaemon,\n    address _addressUpdater,\n    uint256 _rewardEpochStartTs\n) public;\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>GovernedAndFlareDaemonized</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance,\n    contract FlareDaemon _flareDaemon\n) public;\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>Governed</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance\n) public;\n</code></pre> Parameters Type Description <code>_governance</code> <code>address</code> Governance contract. Must not be zero."},{"location":"apis/smart-contracts/Inflation/#fn_daemonize_6d0e8c34","title":"<code>daemonize</code>","text":"<p>Defined in <code>IFlareDaemonize</code> (Docs, Source).</p> <pre><code>function daemonize(\n) external returns (\n    bool);\n</code></pre> <p>Implement this function to receive a trigger from the <code>FlareDaemon</code>. The trigger method is called by the validator right at the end of block state transition.</p> Returns Type Description [0] <code>bool</code> bool Whether the contract is still active after the call. Currently unused."},{"location":"apis/smart-contracts/Inflation/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/Inflation/#fn_getaddressupdater_5267a15d","title":"<code>getAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function getAddressUpdater(\n) public view returns (\n    address _addressUpdater);\n</code></pre> <p>Returns the configured address updater.</p> Returns Type Description <code>_addressUpdater</code> <code>address</code> The <code>AddresUpdater</code> contract that can update our contract address list, as a response to a governance call."},{"location":"apis/smart-contracts/Inflation/#fn_getcontractname_f5f5ba72","title":"<code>getContractName</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>function getContractName(\n) external pure returns (\n    string);\n</code></pre> <p>Implement this function to allow updating daemonized contracts through the <code>AddressUpdater</code>.</p> Returns Type Description [0] <code>string</code> string Contract name."},{"location":"apis/smart-contracts/Inflation/#fn_getcurrenttimeslot_5f61a576","title":"<code>getCurrentTimeSlot</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>function getCurrentTimeSlot(\n) external view returns (\n    struct InflationTimeSlots.InflationTimeSlot);\n</code></pre> <p>Return the current time slot.</p> <p>Expect library to revert if there is no current time slot.</p> Returns Type Description [0] <code>struct InflationTimeSlots.InflationTimeSlot</code> The inflation time slot state of the current time slot."},{"location":"apis/smart-contracts/Inflation/#fn_getcurrenttimeslotid_7292d727","title":"<code>getCurrentTimeSlotId</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>function getCurrentTimeSlotId(\n) external view returns (\n    uint256);\n</code></pre> <p>Return current time slot id.</p> <p>Expect library to revert if there is no current time slot.</p> Returns Type Description [0] <code>uint256</code> Id of the current time slot."},{"location":"apis/smart-contracts/Inflation/#fn_getnextexpectedtopupts_f639c12c","title":"<code>getNextExpectedTopupTs</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>function getNextExpectedTopupTs(\n) external view returns (\n    uint256 _nextTopupTs);\n</code></pre> <p>Returns next expected inflation topup time stamp which is also inflation authorization time. The returned time from this API is actually the time of the block in which the topup is requested. The Actual topup will take place in the next block. Expected diff is up to a few seconds (max is less then a minute).</p>"},{"location":"apis/smart-contracts/Inflation/#fn_getrewardservices_aa5b5eca","title":"<code>getRewardServices</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>function getRewardServices(\n) external view returns (\n    struct InflationRewardServices.RewardService[]);\n</code></pre> <p>Return the structure of reward services.</p> Returns Type Description [0] <code>struct InflationRewardServices.RewardService[]</code> Reward services structure."},{"location":"apis/smart-contracts/Inflation/#fn_gettimeslot_2b85dcc9","title":"<code>getTimeSlot</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>function getTimeSlot(\n    uint256 _index\n) external view returns (\n    struct InflationTimeSlots.InflationTimeSlot);\n</code></pre> <p>Given an index, return the time slot at that index.</p> <p>Expect library to revert if index not found.</p> Parameters Type Description <code>_index</code> <code>uint256</code> The index of the time slot to fetch. Returns Type Description [0] <code>struct InflationTimeSlots.InflationTimeSlot</code> The inflation time slot state."},{"location":"apis/smart-contracts/Inflation/#fn_gettopupconfiguration_4b13e872","title":"<code>getTopupConfiguration</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>function getTopupConfiguration(\n    contract IIInflationReceiver _inflationReceiver\n) external view returns (\n    struct TopupConfiguration _topupConfiguration);\n</code></pre> <p>Given an inflation receiver, get the topup configuration.</p> Parameters Type Description <code>_inflationReceiver</code> <code>contract IIInflationReceiver</code> The reward service. Returns Type Description <code>_topupConfiguration</code> <code>struct TopupConfiguration</code> The configuration of how the topup requests are calculated for a given                              reward service."},{"location":"apis/smart-contracts/Inflation/#fn_gettotals_84e10a90","title":"<code>getTotals</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>function getTotals(\n) external view returns (\n    uint256 _totalAuthorizedInflationWei,\n    uint256 _totalInflationTopupRequestedWei,\n    uint256 _totalInflationTopupDistributedWei,\n    uint256 _totalRecognizedInflationWei);\n</code></pre> <p>Get a tuple of totals across inflation time slots.</p> Returns Type Description <code>_totalAuthorizedInflationWei</code> <code>uint256</code> Total inflation authorized to be mintable <code>_totalInflationTopupRequestedWei</code> <code>uint256</code> Total inflation requested to be topped up for rewarding <code>_totalInflationTopupDistributedWei</code> <code>uint256</code> Total inflation received for funding reward services <code>_totalRecognizedInflationWei</code> <code>uint256</code> Total inflation recognized for rewarding"},{"location":"apis/smart-contracts/Inflation/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/Inflation/#fn_receiveminting_c611c2c5","title":"<code>receiveMinting</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>function receiveMinting(\n) external payable;\n</code></pre> <p>Receive newly minted native tokens from the <code>FlareDaemon</code>.</p> <p>Assume that the received amount will be &gt;= last topup requested across all services. If there is not enough balance sent to cover the topup request, expect the library method to revert. Also assume that any received balance greater than the calculated topup request came from self-destructor sending a balance to this contract.</p>"},{"location":"apis/smart-contracts/Inflation/#fn_setinitialdata_b6f1f749","title":"<code>setInitialData</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>function setInitialData(\n    contract IIInflationV1 _oldInflation,\n    uint256 _noOfAnnums\n) external;\n</code></pre> <p>Used to copy data from old inflation contract.</p> <p>Only <code>governance</code> can call.</p> Parameters Type Description <code>_oldInflation</code> <code>contract IIInflationV1</code> Address of old inflation. <code>_noOfAnnums</code> <code>uint256</code> Number of annums in old inflation."},{"location":"apis/smart-contracts/Inflation/#fn_setpreinflationcalculation_095bfd5a","title":"<code>setPreInflationCalculation</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>function setPreInflationCalculation(\n    contract IIPreInflationCalculation _preInflationCalculation\n) external;\n</code></pre> <p>Set contract that should be triggered before new inflation is calculated (it can be address(0))</p> <p>Only <code>governance</code> can call.</p>"},{"location":"apis/smart-contracts/Inflation/#fn_settopupconfiguration_6e61ab96","title":"<code>setTopupConfiguration</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>function setTopupConfiguration(\n    contract IIInflationReceiver _inflationReceiver,\n    enum TopupType _topupType,\n    uint256 _topupFactorX100\n) external;\n</code></pre> <p>Set the topup configuration for a reward service.</p> <p>Only <code>governance</code> can call.</p> <p>Topup factor, if _topupType == FACTOROFDAILYAUTHORIZED, must be greater than 100.</p> Parameters Type Description <code>_inflationReceiver</code> <code>contract IIInflationReceiver</code> The reward service to receive the inflation funds for distribution. <code>_topupType</code> <code>enum TopupType</code> The type to signal how the topup amounts are to be calculated.                              FACTOROFDAILYAUTHORIZED = Use a factor of last daily authorized to set a                              target balance for a reward service to maintain as a reserve for claiming.                              ALLAUTHORIZED = Mint enough native tokens to topup reward service contract to hold                              all authorized but unrequested rewards. <code>_topupFactorX100</code> <code>uint256</code> If _topupType == FACTOROFDAILYAUTHORIZED, then this factor (times 100)                              is multiplied by last daily authorized inflation to obtain the                              maximum balance that a reward service can hold at any given time. If it holds less,                              then this max amount is used to compute the mint request topup required to                              bring the reward service contract native token balance up to that amount."},{"location":"apis/smart-contracts/Inflation/#fn_switchtofallbackmode_e22fdece","title":"<code>switchToFallbackMode</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>function switchToFallbackMode(\n) external view returns (\n    bool);\n</code></pre> <p>This function will be called after an error is caught in <code>daemonize</code>. It will switch the contract to a simpler fallback mode, which hopefully works when full mode doesn't. Not every contract needs to support fallback mode (<code>FtsoManager</code> does), so this method may be empty. Switching back to normal mode is left to the contract (typically a governed method call). This function may be called due to low-gas error, so it shouldn't use more than ~30.000 gas.</p> Returns Type Description [0] <code>bool</code> True if switched to fallback mode, false if already in fallback mode or if fallback mode is not supported."},{"location":"apis/smart-contracts/Inflation/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/Inflation/#fn_updatecontractaddresses_b00c0b76","title":"<code>updateContractAddresses</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function updateContractAddresses(\n    bytes32[] _contractNameHashes,\n    address[] _contractAddresses\n) external;\n</code></pre> <p>External method called from <code>AddressUpdater</code> only.</p>"},{"location":"apis/smart-contracts/Inflation/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/Inflation/#md_notzero","title":"<code>notZero</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>modifier notZero(    address _address)\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#md_onlyaddressupdater","title":"<code>onlyAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>modifier onlyAddressUpdater()\n</code></pre> <p>Only the <code>AdressUpdater</code> contract can call this method. Its address is set at construction time but it can also update itself.</p>"},{"location":"apis/smart-contracts/Inflation/#md_onlyflaredaemon","title":"<code>onlyFlareDaemon</code>","text":"<p>Defined in <code>GovernedAndFlareDaemonized</code> (Docs, Source).</p> <pre><code>modifier onlyFlareDaemon()\n</code></pre> <p>Only the <code>flareDaemon</code> can call this method.</p>"},{"location":"apis/smart-contracts/Inflation/#md_onlygovernance","title":"<code>onlyGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#md_onlyimmediategovernance","title":"<code>onlyImmediateGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyImmediateGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/Inflation/#va_flaredaemon","title":"<code>flareDaemon</code>","text":"<p>Defined in <code>GovernedAndFlareDaemonized</code> (Docs, Source).</p> <pre><code>    contract FlareDaemon flareDaemon\n</code></pre> <p>The <code>FlareDaemon</code> contract, set at construction time.</p>"},{"location":"apis/smart-contracts/Inflation/#va_governancesettings","title":"<code>governanceSettings</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    contract IGovernanceSettings governanceSettings\n</code></pre> <p>Governance Settings.</p>"},{"location":"apis/smart-contracts/Inflation/#va_inflationallocation","title":"<code>inflationAllocation</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>    contract IIInflationAllocation inflationAllocation\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#va_lastauthorizationts","title":"<code>lastAuthorizationTs</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>    uint256 lastAuthorizationTs\n</code></pre> <p>The last time inflation was authorized.</p>"},{"location":"apis/smart-contracts/Inflation/#va_preinflationcalculation","title":"<code>preInflationCalculation</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>    contract IIPreInflationCalculation preInflationCalculation\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#va_productionmode","title":"<code>productionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    bool productionMode\n</code></pre> <p>When true, <code>governance</code> is enabled and cannot be disabled. See <code>switchToProductionMode</code>.</p>"},{"location":"apis/smart-contracts/Inflation/#va_rewardepochstartts","title":"<code>rewardEpochStartTs</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>    uint256 rewardEpochStartTs\n</code></pre> <p>Do not start inflation time slots before this, in seconds after UNIX epoch.</p>"},{"location":"apis/smart-contracts/Inflation/#va_rewardepochstartedts","title":"<code>rewardEpochStartedTs</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>    uint256 rewardEpochStartedTs\n</code></pre> <p>When the first reward epoch was started, in seconds after UNIX epoch.</p>"},{"location":"apis/smart-contracts/Inflation/#va_supply","title":"<code>supply</code>","text":"<p>Defined in <code>Inflation</code> (Docs, Source).</p> <pre><code>    contract IISupply supply\n</code></pre>"},{"location":"apis/smart-contracts/Inflation/#va_timelockedcalls","title":"<code>timelockedCalls</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    mapping(bytes4 =&gt; struct GovernedBase.TimelockedCall) timelockedCalls\n</code></pre> <p>List of pending timelocked <code>governance</code> calls.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/","title":"PriceSubmitter","text":""},{"location":"apis/smart-contracts/PriceSubmitter/#ct_pricesubmitter","title":"<code>PriceSubmitter</code>","text":"<p>Source | Inherits from IIPriceSubmitter, GovernedAtGenesis, AddressUpdatable</p> <p>Receives prices from FTSO data providers.</p> <p>It then forwards the submissions to the appropriate FTSO contract, allowing data providers to perform all required operations in a single transaction per price epoch.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/PriceSubmitter/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/PriceSubmitter/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>constructor(\n) public;\n</code></pre> <p>This <code>constructor</code> should contain no code as this contract is pre-loaded into the genesis block.   The super constructors are called for testing convenience.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/PriceSubmitter/#fn_getaddressupdater_5267a15d","title":"<code>getAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function getAddressUpdater(\n) public view returns (\n    address _addressUpdater);\n</code></pre> <p>Returns the configured address updater.</p> Returns Type Description <code>_addressUpdater</code> <code>address</code> The <code>AddresUpdater</code> contract that can update our contract address list, as a response to a governance call."},{"location":"apis/smart-contracts/PriceSubmitter/#fn_getcurrentrandom_d89601fd","title":"<code>getCurrentRandom</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>function getCurrentRandom(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the random number for the previous epoch, obtained from the random numbers provided by all data providers along with their data submissions. Note that the random number for the previous epoch keeps updating as new submissions are revealed.</p> <p>It never reverts.</p> Returns Type Description [0] <code>uint256</code> Random number calculated from all data provider's submissions."},{"location":"apis/smart-contracts/PriceSubmitter/#fn_getftsomanager_b39c6858","title":"<code>getFtsoManager</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>function getFtsoManager(\n) external view returns (\n    contract IFtsoManagerGenesis);\n</code></pre> <p>Returns the address of the <code>FtsoManager</code> contract.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#fn_getftsoregistry_8c9d28b6","title":"<code>getFtsoRegistry</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>function getFtsoRegistry(\n) external view returns (\n    contract IFtsoRegistryGenesis);\n</code></pre> <p>Returns the address of the <code>FtsoRegistry</code> contract.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#fn_getrandom_cd4b6914","title":"<code>getRandom</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>function getRandom(\n    uint256 _epochId\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the random number used in a specific past epoch, obtained from the random numbers provided by all data providers along with their data submissions.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the queried epoch. Current epoch cannot be queried, and the previous epoch is constantly updated as data providers reveal their prices and random numbers. Note that only the last 50 epochs can be queried and there is no bounds checking for this parameter. Out-of-bounds queries return undefined values. Returns Type Description [0] <code>uint256</code> The random number used in that epoch."},{"location":"apis/smart-contracts/PriceSubmitter/#fn_gettrustedaddresses_ffacb84e","title":"<code>getTrustedAddresses</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>function getTrustedAddresses(\n) external view returns (\n    address[]);\n</code></pre> <p>Returns the list of trusted addresses that are always allowed to submit and reveal.</p> Returns Type Description [0] <code>address[]</code> address[] Array of trusted voter addresses."},{"location":"apis/smart-contracts/PriceSubmitter/#fn_getvoterwhitelister_71e1fad9","title":"<code>getVoterWhitelister</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>function getVoterWhitelister(\n) external view returns (\n    address);\n</code></pre> <p>Returns the address of the <code>VoterWhitelister</code> contract managing the data provider whitelist.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#fn_initialise_9d6a890f","title":"<code>initialise</code>","text":"<p>Defined in <code>GovernedAtGenesis</code> (Docs, Source).</p> <pre><code>function initialise(\n    address _governance\n) public pure;\n</code></pre> <p>Disallow <code>initialise</code> to be called.</p> Parameters Type Description <code>_governance</code> <code>address</code> The governance address for initial claiming."},{"location":"apis/smart-contracts/PriceSubmitter/#fn_revealprices_e2db5a52","title":"<code>revealPrices</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>function revealPrices(\n    uint256 _epochId,\n    uint256[] _ftsoIndices,\n    uint256[] _prices,\n    uint256 _random\n) external;\n</code></pre> <p>Reveals submitted prices during the epoch reveal period. The hash of FTSO indices, prices, random number, and voter address must be equal to the hash previously submitted with <code>submitHash</code>. Emits a <code>PricesRevealed</code> event.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the epoch to which the price hashes are submitted. <code>_ftsoIndices</code> <code>uint256[]</code> List of FTSO indices in ascending order. <code>_prices</code> <code>uint256[]</code> List of submitted prices in USD. <code>_random</code> <code>uint256</code> Submitted random number."},{"location":"apis/smart-contracts/PriceSubmitter/#fn_setaddressupdater_aea36b53","title":"<code>setAddressUpdater</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>function setAddressUpdater(\n    address _addressUpdater\n) external;\n</code></pre> <p>Sets the address updater contract. Only <code>governance</code> cal call this method.</p> Parameters Type Description <code>_addressUpdater</code> <code>address</code> Address of the <code>AddressUpdater</code> contract."},{"location":"apis/smart-contracts/PriceSubmitter/#fn_settrustedaddresses_9ec2b581","title":"<code>setTrustedAddresses</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>function setTrustedAddresses(\n    address[] _trustedAddresses\n) external;\n</code></pre> <p>Set the trusted addresses that are always allowed to submit and reveal. Trusted addresses are used, for example, in fallback mode. Only FTSO Manager can call this method.</p> Parameters Type Description <code>_trustedAddresses</code> <code>address[]</code> Array of FTSO data provider addresses (voters). The previous list of trusted addresses is discarded."},{"location":"apis/smart-contracts/PriceSubmitter/#fn_submithash_8fc6f667","title":"<code>submitHash</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>function submitHash(\n    uint256 _epochId,\n    bytes32 _hash\n) external;\n</code></pre> <p>Submits a hash for the current epoch. Can only be called by FTSO data providers whitelisted through the <code>VoterWhitelisted</code> contract. Emits the <code>HashSubmitted</code> event.</p> Parameters Type Description <code>_epochId</code> <code>uint256</code> ID of the target epoch to which the hash is submitted. <code>_hash</code> <code>bytes32</code> A hash of the FTSO indices, prices, random number, and voter address."},{"location":"apis/smart-contracts/PriceSubmitter/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#fn_updatecontractaddresses_b00c0b76","title":"<code>updateContractAddresses</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function updateContractAddresses(\n    bytes32[] _contractNameHashes,\n    address[] _contractAddresses\n) external;\n</code></pre> <p>External method called from <code>AddressUpdater</code> only.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#fn_voterwhitelistbitmap_7ac420ad","title":"<code>voterWhitelistBitmap</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>function voterWhitelistBitmap(\n    address _voter\n) external view returns (\n    uint256);\n</code></pre> <p>Returns a bitmap of all FTSOs for which a data provider is allowed to submit prices or hashes.</p> Parameters Type Description <code>_voter</code> <code>address</code> Address of the voter. Returns Type Description [0] <code>uint256</code> If a data provider is allowed to vote for a given FTSO index, the corresponding bit in the result is 1."},{"location":"apis/smart-contracts/PriceSubmitter/#fn_voterwhitelisted_9d986f91","title":"<code>voterWhitelisted</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>function voterWhitelisted(\n    address _voter,\n    uint256 _ftsoIndex\n) external;\n</code></pre> <p>Called from the <code>VoterWhitelister</code> contract when a new voter has been whitelisted.</p> <p>Only the <code>VoterWhitelister</code> contract can call this method.</p> Parameters Type Description <code>_voter</code> <code>address</code> Voter address that has been added to the whitelist. <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO to which the voter has registered. Each FTSO has its own whitelist."},{"location":"apis/smart-contracts/PriceSubmitter/#fn_votersremovedfromwhitelist_76794efb","title":"<code>votersRemovedFromWhitelist</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>function votersRemovedFromWhitelist(\n    address[] _removedVoters,\n    uint256 _ftsoIndex\n) external;\n</code></pre> <p>Called from the <code>VoterWhitelister</code> contract when one or more voters have been removed.</p> <p>Only the <code>VoterWhitelister</code> contract can call this method.</p> Parameters Type Description <code>_removedVoters</code> <code>address[]</code> <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO to which the voters were registered. Each FTSO has its own whitelist."},{"location":"apis/smart-contracts/PriceSubmitter/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/PriceSubmitter/#md_onlyaddressupdater","title":"<code>onlyAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>modifier onlyAddressUpdater()\n</code></pre> <p>Only the <code>AdressUpdater</code> contract can call this method. Its address is set at construction time but it can also update itself.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#md_onlyftsomanager","title":"<code>onlyFtsoManager</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>modifier onlyFtsoManager()\n</code></pre> <p>Only the <code>ftsoManager</code> can call this method.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#md_onlygovernance","title":"<code>onlyGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/PriceSubmitter/#md_onlyimmediategovernance","title":"<code>onlyImmediateGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyImmediateGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/PriceSubmitter/#md_onlywhitelister","title":"<code>onlyWhitelister</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>modifier onlyWhitelister()\n</code></pre> <p>Only the <code>voterWhitelister</code> can call this method.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/PriceSubmitter/#va_minimal_random","title":"<code>MINIMAL_RANDOM</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>    uint256 MINIMAL_RANDOM\n</code></pre> <p>Minimal random value accepted along price submissions. Submitted random values below this threshold will revert.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#va_random_epoch_cyclic_buffer_size","title":"<code>RANDOM_EPOCH_CYCLIC_BUFFER_SIZE</code>","text":"<p>Defined in <code>PriceSubmitter</code> (Docs, Source).</p> <pre><code>    uint256 RANDOM_EPOCH_CYCLIC_BUFFER_SIZE\n</code></pre> <p>Number of past random numbers remembered.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#va_governancesettings","title":"<code>governanceSettings</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    contract IGovernanceSettings governanceSettings\n</code></pre> <p>Governance Settings.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#va_productionmode","title":"<code>productionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    bool productionMode\n</code></pre> <p>When true, <code>governance</code> is enabled and cannot be disabled. See <code>switchToProductionMode</code>.</p>"},{"location":"apis/smart-contracts/PriceSubmitter/#va_timelockedcalls","title":"<code>timelockedCalls</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    mapping(bytes4 =&gt; struct GovernedBase.TimelockedCall) timelockedCalls\n</code></pre> <p>List of pending timelocked <code>governance</code> calls.</p>"},{"location":"apis/smart-contracts/RevertErrorTracking/","title":"RevertErrorTracking","text":""},{"location":"apis/smart-contracts/RevertErrorTracking/#ct_reverterrortracking","title":"<code>RevertErrorTracking</code>","text":"<p>Source</p> <p>Revert error tracking contract.</p> <p>A contract to track and store revert errors.</p>"},{"location":"apis/smart-contracts/RevertErrorTracking/#events","title":"Events","text":""},{"location":"apis/smart-contracts/RevertErrorTracking/#ev_contractreverterror","title":"<code>ContractRevertError</code>","text":"<p>Defined in <code>RevertErrorTracking</code> (Docs, Source).</p> <pre><code>event ContractRevertError(\n    address theContract,\n    uint256 atBlock,\n    string theMessage\n)\n</code></pre> <p>Emitted when a contract reverts.</p> Parameters Type Description <code>theContract</code> <code>address</code> The culprit's address. <code>atBlock</code> <code>uint256</code> Block number where the error happened. <code>theMessage</code> <code>string</code> Reason for the revert, as reported by the contract."},{"location":"apis/smart-contracts/RevertErrorTracking/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/RevertErrorTracking/#fn_showlastrevertederror_2b3c41a4","title":"<code>showLastRevertedError</code>","text":"<p>Defined in <code>RevertErrorTracking</code> (Docs, Source).</p> <pre><code>function showLastRevertedError(\n) external view returns (\n    uint256[] _lastErrorBlock,\n    uint256[] _numErrors,\n    string[] _errorString,\n    address[] _erroringContract,\n    uint256 _totalRevertedErrors);\n</code></pre> <p>Returns latest error information. All arrays will contain only one entry.</p> Returns Type Description <code>_lastErrorBlock</code> <code>uint256[]</code> Array of block numbers where the errors occurred. <code>_numErrors</code> <code>uint256[]</code> Array of number of times same error with same contract address has been reverted. <code>_errorString</code> <code>string[]</code> Array of revert error messages. <code>_erroringContract</code> <code>address[]</code> Array of addresses of the reverting contracts. <code>_totalRevertedErrors</code> <code>uint256</code> Total number of revert errors across all contracts."},{"location":"apis/smart-contracts/RevertErrorTracking/#fn_showrevertederrors_6ea0aa31","title":"<code>showRevertedErrors</code>","text":"<p>Defined in <code>RevertErrorTracking</code> (Docs, Source).</p> <pre><code>function showRevertedErrors(\n    uint256 startIndex,\n    uint256 numErrorTypesToShow\n) public view returns (\n    uint256[] _lastErrorBlock,\n    uint256[] _numErrors,\n    string[] _errorString,\n    address[] _erroringContract,\n    uint256 _totalRevertedErrors);\n</code></pre> <p>Returns latest errors.</p> Parameters Type Description <code>startIndex</code> <code>uint256</code> Starting index in the error list array. <code>numErrorTypesToShow</code> <code>uint256</code> Number of errors to show. The total amount can be found in <code>errorData</code>. Returns Type Description <code>_lastErrorBlock</code> <code>uint256[]</code> Array of block numbers where the errors occurred. <code>_numErrors</code> <code>uint256[]</code> Array of number of times same error with same contract address has been reverted. <code>_errorString</code> <code>string[]</code> Array of revert error messages. <code>_erroringContract</code> <code>address[]</code> Array of addresses of the reverting contracts. <code>_totalRevertedErrors</code> <code>uint256</code> Total number of revert errors across all contracts."},{"location":"apis/smart-contracts/RevertErrorTracking/#structures","title":"Structures","text":""},{"location":"apis/smart-contracts/RevertErrorTracking/#st_lasterrordata","title":"<code>LastErrorData</code>","text":"<p>Defined in <code>RevertErrorTracking</code> (Docs, Source).</p> <pre><code>struct LastErrorData {\n  uint192 totalRevertedErrors;\n  uint64 lastErrorTypeIndex;\n}\n</code></pre>"},{"location":"apis/smart-contracts/RevertErrorTracking/#st_revertederror","title":"<code>RevertedError</code>","text":"<p>Defined in <code>RevertErrorTracking</code> (Docs, Source).</p> <pre><code>struct RevertedError {\n  uint192 lastErrorBlock;\n  uint64 numErrors;\n  address fromContract;\n  uint64 errorTypeIndex;\n  string errorMessage;\n}\n</code></pre>"},{"location":"apis/smart-contracts/RevertErrorTracking/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/RevertErrorTracking/#va_errordata","title":"<code>errorData</code>","text":"<p>Defined in <code>RevertErrorTracking</code> (Docs, Source).</p> <pre><code>    struct RevertErrorTracking.LastErrorData errorData\n</code></pre> <p>Most recent error information.</p>"},{"location":"apis/smart-contracts/VPContract/","title":"VPContract","text":""},{"location":"apis/smart-contracts/VPContract/#ct_vpcontract","title":"<code>VPContract</code>","text":"<p>Source | Inherits from IIVPContract, Delegatable</p> <p>Helper contract handling all the vote power and delegation functionality for an associated <code>VPToken</code>.</p>"},{"location":"apis/smart-contracts/VPContract/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/VPContract/#fn_batchvotepowerofat_49e3c7e5","title":"<code>batchVotePowerOfAt</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function batchVotePowerOfAt(\n    address[] _owners,\n    uint256 _blockNumber\n) external view returns (\n    uint256[] _votePowers);\n</code></pre> <p>Get the vote power of a set of addresses at a given block number.</p> Parameters Type Description <code>_owners</code> <code>address[]</code> The list of addresses being queried. <code>_blockNumber</code> <code>uint256</code> The block number being queried. Returns Type Description <code>_votePowers</code> <code>uint256[]</code> Vote power of each address at <code>_blockNumber</code>, including any delegation received."},{"location":"apis/smart-contracts/VPContract/#fn_cleanupblocknumber_deea13e7","title":"<code>cleanupBlockNumber</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function cleanupBlockNumber(\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current cleanup block number set with <code>setCleanupBlockNumber</code>.</p> Returns Type Description [0] <code>uint256</code> The currently set cleanup block number."},{"location":"apis/smart-contracts/VPContract/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>constructor(\n    contract IVPToken _ownerToken,\n    bool _isReplacement\n) public;\n</code></pre> <p>Construct <code>VPContract</code> for given <code>VPToken</code>.</p>"},{"location":"apis/smart-contracts/VPContract/#fn_delegate_6230001a","title":"<code>delegate</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function delegate(\n    address _from,\n    address _to,\n    uint256 _balance,\n    uint256 _bips\n) external;\n</code></pre> <p><code>Delegate</code> <code>_bips</code> percentage of voting power from a delegator address to a delegatee address.</p> Parameters Type Description <code>_from</code> <code>address</code> The address of the delegator. <code>_to</code> <code>address</code> The address of the delegatee. <code>_balance</code> <code>uint256</code> The delegator's current balance <code>_bips</code> <code>uint256</code> The percentage of voting power to be delegated expressed in basis points (1/100 of one percent). Not cumulative: every call resets the delegation value (and a value of 0 revokes delegation)."},{"location":"apis/smart-contracts/VPContract/#fn_delegateexplicit_404d9e82","title":"<code>delegateExplicit</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function delegateExplicit(\n    address _from,\n    address _to,\n    uint256 _balance,\n    uint256 _amount\n) external;\n</code></pre> <p>Explicitly <code>delegate</code> <code>_amount</code> tokens of voting power from a delegator address to a delegatee address.</p> Parameters Type Description <code>_from</code> <code>address</code> The address of the delegator. <code>_to</code> <code>address</code> The address of the delegatee. <code>_balance</code> <code>uint256</code> The delegator's current balance. <code>_amount</code> <code>uint256</code> An explicit vote power amount to be delegated. Not cumulative: every call resets the delegation value (and a value of 0 undelegates <code>_to</code>)."},{"location":"apis/smart-contracts/VPContract/#fn_delegatesof_7de5b8ed","title":"<code>delegatesOf</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function delegatesOf(\n    address _owner\n) external view returns (\n    address[] _delegateAddresses,\n    uint256[] _bips,\n    uint256 _count,\n    uint256 _delegationMode);\n</code></pre> <p>Get the percentages and addresses being delegated to by a vote power delegator.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address of the delegator being queried. Returns Type Description <code>_delegateAddresses</code> <code>address[]</code> Array of delegatee addresses. <code>_bips</code> <code>uint256[]</code> Array of delegation percents specified in basis points (1/100 or 1 percent), for each delegatee. <code>_count</code> <code>uint256</code> The number of returned delegatees. <code>_delegationMode</code> <code>uint256</code> The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2). See <code>Delegatable</code>.DelegationMode."},{"location":"apis/smart-contracts/VPContract/#fn_delegatesofat_ed475a79","title":"<code>delegatesOfAt</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function delegatesOfAt(\n    address _owner,\n    uint256 _blockNumber\n) public view returns (\n    address[] _delegateAddresses,\n    uint256[] _bips,\n    uint256 _count,\n    uint256 _delegationMode);\n</code></pre> <p>Get the percentages and addresses being delegated to by a vote power delegator, at a given block.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address of the delegator being queried. <code>_blockNumber</code> <code>uint256</code> The block number being queried. Returns Type Description <code>_delegateAddresses</code> <code>address[]</code> Array of delegatee addresses. <code>_bips</code> <code>uint256[]</code> Array of delegation percents specified in basis points (1/100 or 1 percent), for each delegatee. <code>_count</code> <code>uint256</code> The number of returned delegatees. <code>_delegationMode</code> <code>uint256</code> The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2). See <code>Delegatable</code>.DelegationMode."},{"location":"apis/smart-contracts/VPContract/#fn_delegationmodeof_f6837767","title":"<code>delegationModeOf</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function delegationModeOf(\n    address _who\n) external view returns (\n    uint256);\n</code></pre> <p>Get the delegation mode of an address. This mode determines whether vote power is allocated by percentage or by explicit value and cannot be changed once set with <code>delegate</code> or <code>delegateExplicit</code>.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. Returns Type Description [0] <code>uint256</code> Delegation mode (NOTSET=0, PERCENTAGE=1, AMOUNT=2). See <code>Delegatable</code>.DelegationMode."},{"location":"apis/smart-contracts/VPContract/#fn_explicitdelegationhistorycleanup_cabc4528","title":"<code>explicitDelegationHistoryCleanup</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>function explicitDelegationHistoryCleanup(\n    address _from,\n    address _to,\n    uint256 _count\n) external returns (\n    uint256);\n</code></pre> <p>Delete explicit delegation checkpoints that expired (i.e. are before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_from</code> <code>address</code> Delegator address. <code>_to</code> <code>address</code> Delegatee address. <code>_count</code> <code>uint256</code> Maximum number of checkpoints to delete. Returns Type Description [0] <code>uint256</code> Number of checkpoints deleted."},{"location":"apis/smart-contracts/VPContract/#fn_isreplacement_aa94d3f2","title":"<code>isReplacement</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function isReplacement(\n) external view returns (\n    bool);\n</code></pre> <p>Return true if this <code>IIVPContract</code> is configured to be used as a replacement for other contract. It means that vote powers are not necessarily correct at the initialization, therefore every method that reads vote power must check whether it is initialized for that address and block.</p>"},{"location":"apis/smart-contracts/VPContract/#fn_ownertoken_65371883","title":"<code>ownerToken</code>","text":"<p>Defined in <code>IIVPContract</code> (Docs, Source).</p> <pre><code>function ownerToken(\n) external view returns (\n    contract IVPToken);\n</code></pre> <p>The <code>VPToken</code> (or some other contract) that owns this <code>VPContract</code>. All state changing methods may be called only from this address. This is because original <code>msg.sender</code> is typically sent in a parameter and we must make sure that it cannot be faked by directly calling <code>IIVPContract</code> methods. Owner token is also used in case of replacement to recover vote powers from balances.</p>"},{"location":"apis/smart-contracts/VPContract/#fn_percentagedelegationhistorycleanup_7f57d58f","title":"<code>percentageDelegationHistoryCleanup</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>function percentageDelegationHistoryCleanup(\n    address _owner,\n    uint256 _count\n) external returns (\n    uint256);\n</code></pre> <p>Delete percentage delegation checkpoints that expired (i.e. are before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_owner</code> <code>address</code> Balance owner account address. <code>_count</code> <code>uint256</code> Maximum number of checkpoints to delete. Returns Type Description [0] <code>uint256</code> Number of deleted checkpoints."},{"location":"apis/smart-contracts/VPContract/#fn_revocationcleanup_8c0b6b40","title":"<code>revocationCleanup</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>function revocationCleanup(\n    address _from,\n    address _to,\n    uint256 _blockNumber\n) external returns (\n    uint256);\n</code></pre> <p>Delete revocation entry that expired (i.e. is before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_from</code> <code>address</code> Delegator address. <code>_to</code> <code>address</code> Delegatee address. <code>_blockNumber</code> <code>uint256</code> Block number for which total supply value was cached. Returns Type Description [0] <code>uint256</code> Number of revocation entries deleted (always 0 or 1)."},{"location":"apis/smart-contracts/VPContract/#fn_revokedelegationat_c7c62fab","title":"<code>revokeDelegationAt</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function revokeDelegationAt(\n    address _from,\n    address _to,\n    uint256 _balance,\n    uint256 _blockNumber\n) external;\n</code></pre> <p><code>Revoke</code> all vote power delegation from a delegator address to a delegatee address at a given block. Only affects the reads via <code>votePowerOfAtCached</code> in the block <code>_blockNumber</code>. This method should be used only to prevent rogue <code>delegate</code> voting in the current voting block. To stop delegating use <code>delegate</code> or <code>delegateExplicit</code> with value of 0, or <code>undelegateAll</code>/ <code>undelegateAllExplicit</code>.</p> Parameters Type Description <code>_from</code> <code>address</code> The address of the delegator. <code>_to</code> <code>address</code> Address of the delegatee. <code>_balance</code> <code>uint256</code> The delegator's current balance. <code>_blockNumber</code> <code>uint256</code> The block number at which to revoke delegation. Must be in the past."},{"location":"apis/smart-contracts/VPContract/#fn_setcleanercontract_f6a494af","title":"<code>setCleanerContract</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function setCleanerContract(\n    address _cleanerContract\n) external;\n</code></pre> <p>Set the contract that is allowed to call history cleaning methods.</p> Parameters Type Description <code>_cleanerContract</code> <code>address</code> Address of the cleanup contract. Usually this will be an instance of <code>CleanupBlockNumberManager</code>."},{"location":"apis/smart-contracts/VPContract/#fn_setcleanupblocknumber_13de97f5","title":"<code>setCleanupBlockNumber</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function setCleanupBlockNumber(\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Set the cleanup block number. Historic data for the blocks before <code>cleanupBlockNumber</code> can be erased. History before that block should never be used since it can be inconsistent. In particular, cleanup block number must be lower than the current vote power block.</p> <p>The method can be called only by the owner token.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The new cleanup block number."},{"location":"apis/smart-contracts/VPContract/#fn_undelegateall_05109ecf","title":"<code>undelegateAll</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function undelegateAll(\n    address _from,\n    uint256 _balance\n) external;\n</code></pre> <p>Undelegate all voting power for a delegator address. Can only be used with percentage delegation. Does not reset delegation mode back to <code>NOTSET</code>.</p> Parameters Type Description <code>_from</code> <code>address</code> The address of the delegator. <code>_balance</code> <code>uint256</code> The delegator's current balance."},{"location":"apis/smart-contracts/VPContract/#fn_undelegateallexplicit_0f8b8af7","title":"<code>undelegateAllExplicit</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function undelegateAllExplicit(\n    address _from,\n    address[] _delegateAddresses\n) external returns (\n    uint256);\n</code></pre> <p>Undelegate all explicit vote power by amount for a delegator address. Can only be used with explicit delegation. Does not reset delegation mode back to <code>NOTSET</code>.</p> Parameters Type Description <code>_from</code> <code>address</code> The address of the delegator. <code>_delegateAddresses</code> <code>address[]</code> Explicit delegation does not store delegatees' addresses, so the caller must supply them. Returns Type Description [0] <code>uint256</code> The amount still delegated (in case the list of delegates was incomplete)."},{"location":"apis/smart-contracts/VPContract/#fn_undelegatedvotepowerof_4a03d556","title":"<code>undelegatedVotePowerOf</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function undelegatedVotePowerOf(\n    address _owner,\n    uint256 _balance\n) external view returns (\n    uint256);\n</code></pre> <p>Compute the current undelegated vote power of an address.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address being queried. <code>_balance</code> <code>uint256</code> Current balance of that address. Returns Type Description [0] <code>uint256</code> The unallocated vote power of <code>_owner</code>, this is, the amount of vote power currently not being delegated to other addresses."},{"location":"apis/smart-contracts/VPContract/#fn_undelegatedvotepowerofat_31503927","title":"<code>undelegatedVotePowerOfAt</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function undelegatedVotePowerOfAt(\n    address _owner,\n    uint256 _balance,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Compute the undelegated vote power of an address at a given block.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address being queried. <code>_balance</code> <code>uint256</code> <code>_blockNumber</code> <code>uint256</code> The block number being queried. Returns Type Description [0] <code>uint256</code> The unallocated vote power of <code>_owner</code>, this is, the amount of vote power that was not being delegated to other addresses at that block number."},{"location":"apis/smart-contracts/VPContract/#fn_updateattokentransfer_eadb4362","title":"<code>updateAtTokenTransfer</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function updateAtTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _fromBalance,\n    uint256 _toBalance,\n    uint256 _amount\n) external;\n</code></pre> <p>Update vote powers when tokens are transferred. Also update delegated vote powers for percentage delegation and check for enough funds for explicit delegations.</p> Parameters Type Description <code>_from</code> <code>address</code> Source account of the transfer. <code>_to</code> <code>address</code> Destination account of the transfer. <code>_fromBalance</code> <code>uint256</code> Balance of the source account before the transfer. <code>_toBalance</code> <code>uint256</code> Balance of the destination account before the transfer. <code>_amount</code> <code>uint256</code> Amount that has been transferred."},{"location":"apis/smart-contracts/VPContract/#fn_votepowercachecleanup_891339a8","title":"<code>votePowerCacheCleanup</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>function votePowerCacheCleanup(\n    address _owner,\n    uint256 _blockNumber\n) external returns (\n    uint256);\n</code></pre> <p>Delete vote power cache entry that expired (i.e. is before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_owner</code> <code>address</code> Vote power owner account address. <code>_blockNumber</code> <code>uint256</code> Block number for which total supply value was cached. Returns Type Description [0] <code>uint256</code> Number of deleted cache entries (always 0 or 1)."},{"location":"apis/smart-contracts/VPContract/#fn_votepowerfromto_9dc6b9f2","title":"<code>votePowerFromTo</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function votePowerFromTo(\n    address _from,\n    address _to,\n    uint256 _balance\n) external view returns (\n    uint256);\n</code></pre> <p>Get current delegated vote power from a delegator to a delegatee.</p> Parameters Type Description <code>_from</code> <code>address</code> Address of the delegator. <code>_to</code> <code>address</code> Address of the delegatee. <code>_balance</code> <code>uint256</code> The delegator's current balance. Returns Type Description [0] <code>uint256</code> The delegated vote power."},{"location":"apis/smart-contracts/VPContract/#fn_votepowerfromtoat_833aca92","title":"<code>votePowerFromToAt</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function votePowerFromToAt(\n    address _from,\n    address _to,\n    uint256 _balance,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get delegated the vote power from a delegator to a delegatee at a given block number.</p> Parameters Type Description <code>_from</code> <code>address</code> Address of the delegator. <code>_to</code> <code>address</code> Address of the delegatee. <code>_balance</code> <code>uint256</code> The delegator's current balance. <code>_blockNumber</code> <code>uint256</code> The block number being queried. Returns Type Description [0] <code>uint256</code> The delegated vote power."},{"location":"apis/smart-contracts/VPContract/#fn_votepowerhistorycleanup_1a05274c","title":"<code>votePowerHistoryCleanup</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>function votePowerHistoryCleanup(\n    address _owner,\n    uint256 _count\n) external returns (\n    uint256);\n</code></pre> <p>Delete vote power checkpoints that expired (i.e. are before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_owner</code> <code>address</code> Vote power owner account address. <code>_count</code> <code>uint256</code> Maximum number of checkpoints to delete. Returns Type Description [0] <code>uint256</code> Number of deleted checkpoints."},{"location":"apis/smart-contracts/VPContract/#fn_votepowerof_142d1018","title":"<code>votePowerOf</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function votePowerOf(\n    address _who\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current vote power of an address.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. Returns Type Description [0] <code>uint256</code> Current vote power of <code>_who</code>, including any delegation received."},{"location":"apis/smart-contracts/VPContract/#fn_votepowerofat_92bfe6d8","title":"<code>votePowerOfAt</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function votePowerOfAt(\n    address _who,\n    uint256 _blockNumber\n) public view returns (\n    uint256);\n</code></pre> <p>Get the vote power of an address at a given block number</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. <code>_blockNumber</code> <code>uint256</code> The block number being queried. Returns Type Description [0] <code>uint256</code> Vote power of <code>_who</code> at <code>_blockNumber</code>, including any delegation received."},{"location":"apis/smart-contracts/VPContract/#fn_votepowerofatcached_e587497e","title":"<code>votePowerOfAtCached</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function votePowerOfAtCached(\n    address _who,\n    uint256 _blockNumber\n) external returns (\n    uint256);\n</code></pre> <p>Get the vote power of an address at a given block number. Reads/updates cache and upholds revocations.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. <code>_blockNumber</code> <code>uint256</code> The block number being queried. Returns Type Description [0] <code>uint256</code> Vote power of <code>_who</code> at <code>_blockNumber</code>, including any delegation received."},{"location":"apis/smart-contracts/VPContract/#fn_votepowerofatignoringrevocation_04bb4e43","title":"<code>votePowerOfAtIgnoringRevocation</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>function votePowerOfAtIgnoringRevocation(\n    address _who,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the vote power of an address at a given block number, ignoring revocation information and cache.</p> Parameters Type Description <code>_who</code> <code>address</code> The address being queried. <code>_blockNumber</code> <code>uint256</code> The block number being queried. Returns Type Description [0] <code>uint256</code> Vote power of <code>_who</code> at <code>_blockNumber</code>, including any delegation received. Result doesn't change if vote power is revoked."},{"location":"apis/smart-contracts/VPContract/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/VPContract/#md_notbeforecleanupblock","title":"<code>notBeforeCleanupBlock</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>modifier notBeforeCleanupBlock(    uint256 _blockNumber)\n</code></pre> <p>Reading from history is not allowed before <code>cleanupBlockNumber</code>, since data before that might have been deleted and is thus unreliable.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The block number being checked for validity."},{"location":"apis/smart-contracts/VPContract/#md_onlycleaner","title":"<code>onlyCleaner</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>modifier onlyCleaner()\n</code></pre> <p>History cleaning methods can be called only from <code>cleanerContract</code>.</p>"},{"location":"apis/smart-contracts/VPContract/#md_onlyexplicit","title":"<code>onlyExplicit</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>modifier onlyExplicit(    address sender)\n</code></pre> <p>If a <code>delegate</code> cannot be added by explicit amount, revert.</p>"},{"location":"apis/smart-contracts/VPContract/#md_onlyownertoken","title":"<code>onlyOwnerToken</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>modifier onlyOwnerToken()\n</code></pre> <p>All external methods in <code>VPContract</code> can only be executed by the owner token.</p>"},{"location":"apis/smart-contracts/VPContract/#md_onlypercent","title":"<code>onlyPercent</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>modifier onlyPercent(    address sender)\n</code></pre> <p>If a <code>delegate</code> cannot be added by percentage, revert.</p>"},{"location":"apis/smart-contracts/VPContract/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/VPContract/#va_cleanercontract","title":"<code>cleanerContract</code>","text":"<p>Defined in <code>Delegatable</code> (Docs, Source).</p> <pre><code>    address cleanerContract\n</code></pre> <p>Address of the contract that is allowed to call methods for history cleaning.</p>"},{"location":"apis/smart-contracts/VPContract/#va_isreplacement","title":"<code>isReplacement</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>    bool isReplacement\n</code></pre> <p>Return true if this <code>IIVPContract</code> is configured to be used as a replacement for other contract. It means that vote powers are not necessarily correct at the initialization, therefore every method that reads vote power must check whether it is initialized for that address and block.</p>"},{"location":"apis/smart-contracts/VPContract/#va_ownertoken","title":"<code>ownerToken</code>","text":"<p>Defined in <code>VPContract</code> (Docs, Source).</p> <pre><code>    contract IVPToken ownerToken\n</code></pre> <p>The <code>VPToken</code> (or some other contract) that owns this <code>VPContract</code>. All state changing methods may be called only from this address. This is because original <code>msg.sender</code> is typically sent in a parameter and we must make sure that it cannot be faked by directly calling <code>IIVPContract</code> methods. Owner token is also used in case of replacement to recover vote powers from balances.</p>"},{"location":"apis/smart-contracts/VPToken/","title":"VPToken","text":""},{"location":"apis/smart-contracts/VPToken/#ct_vptoken","title":"<code>VPToken</code>","text":"<p>Source | Inherits from IIVPToken, ERC20, CheckPointable, Governed</p> <p>Vote power token.</p> <p>An ERC20 token that enables the holder to <code>delegate</code> a voting power equal to their balance, with history tracking by block height. Actual vote power and delegation functionality is implemented in an associated <code>VPContract</code>.</p>"},{"location":"apis/smart-contracts/VPToken/#events","title":"Events","text":""},{"location":"apis/smart-contracts/VPToken/#ev_approval","title":"<code>Approval</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>event Approval(\n    address owner,\n    address spender,\n    uint256 value\n)\n</code></pre> <p>Emitted when the <code>allowance</code> of a <code>spender</code> for an <code>owner</code> is set by a call to <code>approve</code>. <code>value</code> is the new <code>allowance</code>.</p>"},{"location":"apis/smart-contracts/VPToken/#ev_createdtotalsupplycache","title":"<code>CreatedTotalSupplyCache</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>event CreatedTotalSupplyCache(\n    uint256 _blockNumber\n)\n</code></pre> <p>Emitted when a total supply cache entry is created. Allows history cleaners to track total supply cache cleanup opportunities off-chain.</p>"},{"location":"apis/smart-contracts/VPToken/#ev_governancecalltimelocked","title":"<code>GovernanceCallTimelocked</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernanceCallTimelocked(\n    bytes4 selector,\n    uint256 allowedAfterTimestamp,\n    bytes encodedCall\n)\n</code></pre> <p>Emitted when a new <code>governance</code> call has been recorded and is now waiting for the time lock to expire.</p>"},{"location":"apis/smart-contracts/VPToken/#ev_governanceinitialised","title":"<code>GovernanceInitialised</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernanceInitialised(\n    address initialGovernance\n)\n</code></pre> <p>Emitted when the <code>governance</code> address is initialized. This address will be used until production mode is entered (see <code>GovernedProductionModeEntered</code>). At that point the <code>governance</code> address is taken from <code>GovernanceSettings</code>.</p>"},{"location":"apis/smart-contracts/VPToken/#ev_governedproductionmodeentered","title":"<code>GovernedProductionModeEntered</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernedProductionModeEntered(\n    address governanceSettings\n)\n</code></pre> <p>Emitted when <code>governance</code> is enabled and the <code>governance</code> address cannot be changed anymore (only through a network fork).</p>"},{"location":"apis/smart-contracts/VPToken/#ev_timelockedgovernancecallcanceled","title":"<code>TimelockedGovernanceCallCanceled</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event TimelockedGovernanceCallCanceled(\n    bytes4 selector,\n    uint256 timestamp\n)\n</code></pre> <p>Emitted when a timelocked <code>governance</code> call is canceled before execution.</p>"},{"location":"apis/smart-contracts/VPToken/#ev_timelockedgovernancecallexecuted","title":"<code>TimelockedGovernanceCallExecuted</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event TimelockedGovernanceCallExecuted(\n    bytes4 selector,\n    uint256 timestamp\n)\n</code></pre> <p>Emitted when a timelocked <code>governance</code> call is executed.</p>"},{"location":"apis/smart-contracts/VPToken/#ev_transfer","title":"<code>Transfer</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>event Transfer(\n    address from,\n    address to,\n    uint256 value\n)\n</code></pre> <p>Emitted when <code>value</code> tokens are moved from one account (<code>from</code>) to another (<code>to</code>).</p> <p>Note that <code>value</code> may be zero.</p>"},{"location":"apis/smart-contracts/VPToken/#ev_votepowercontractchanged","title":"<code>VotePowerContractChanged</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>event VotePowerContractChanged(\n    uint256 _contractType,\n    address _oldContractAddress,\n    address _newContractAddress\n)\n</code></pre> <p>Emitted when one of the vote power contracts is changed.</p> <p>It is used to track the history of <code>VPToken</code> -&gt; <code>VPContract</code> / <code>GovernanceVotePower</code> associations (e.g. by external cleaners).</p> Parameters Type Description <code>_contractType</code> <code>uint256</code> 0 = Read <code>VPContract</code>, 1 = Write <code>VPContract</code>, 2 = Governance vote power. <code>_oldContractAddress</code> <code>address</code> Contract address before change. <code>_newContractAddress</code> <code>address</code> Contract address after change."},{"location":"apis/smart-contracts/VPToken/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/VPToken/#fn_allowance_dd62ed3e","title":"<code>allowance</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function allowance(\n    address owner,\n    address spender\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the remaining number of tokens that <code>spender</code> will be allowed to spend on behalf of <code>owner</code> through <code>transferFrom</code>. This is zero by default.</p> <p>This value changes when <code>approve</code> or <code>transferFrom</code> are called.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_approve_095ea7b3","title":"<code>approve</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function approve(\n    address spender,\n    uint256 amount\n) external returns (\n    bool);\n</code></pre> <p>Sets <code>amount</code> as the <code>allowance</code> of <code>spender</code> over the caller's tokens.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>IMPORTANT: Beware that changing an <code>allowance</code> with this method brings the risk that someone may use both the old and the new <code>allowance</code> by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's <code>allowance</code> to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</p> <p>Emits an <code>Approval</code> event.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_balancehistorycleanup_f0e292c9","title":"<code>balanceHistoryCleanup</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>function balanceHistoryCleanup(\n    address _owner,\n    uint256 _count\n) external returns (\n    uint256);\n</code></pre> <p>Delete balance checkpoints that expired (i.e. are before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_owner</code> <code>address</code> balance owner account address <code>_count</code> <code>uint256</code> maximum number of checkpoints to delete Returns Type Description [0] <code>uint256</code> the number of checkpoints deleted"},{"location":"apis/smart-contracts/VPToken/#fn_balanceof_70a08231","title":"<code>balanceOf</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function balanceOf(\n    address account\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the amount of tokens owned by <code>account</code>.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_balanceofat_4ee2cd7e","title":"<code>balanceOfAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function balanceOfAt(\n    address _owner,\n    uint256 _blockNumber\n) public view returns (\n    uint256);\n</code></pre> <p>Queries the token balance of <code>_owner</code> at a specific <code>_blockNumber</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address from which the balance will be retrieved. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code>"},{"location":"apis/smart-contracts/VPToken/#fn_batchdelegate_dc4fcda7","title":"<code>batchDelegate</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function batchDelegate(\n    address[] _delegatees,\n    uint256[] _bips\n) external;\n</code></pre> <p>Undelegate all percentage delegations from the sender and then <code>delegate</code> corresponding   <code>_bips</code> percentage of voting power from the sender to each member of the <code>_delegatees</code> array.</p> Parameters Type Description <code>_delegatees</code> <code>address[]</code> The addresses of the new recipients. <code>_bips</code> <code>uint256[]</code> The percentages of voting power to be delegated expressed in basis points (1/100 of one percent).   The sum of all <code>_bips</code> values must be at most 10000 (100%)."},{"location":"apis/smart-contracts/VPToken/#fn_batchvotepowerofat_49e3c7e5","title":"<code>batchVotePowerOfAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function batchVotePowerOfAt(\n    address[] _owners,\n    uint256 _blockNumber\n) external view returns (\n    uint256[]);\n</code></pre> <p>Return the vote power for several addresses.</p> Parameters Type Description <code>_owners</code> <code>address[]</code> The list of addresses to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256[]</code> Array of vote power for each queried address."},{"location":"apis/smart-contracts/VPToken/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/VPToken/#fn_cleanupblocknumber_deea13e7","title":"<code>cleanupBlockNumber</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function cleanupBlockNumber(\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current cleanup block number set with <code>setCleanupBlockNumber</code>.</p> Returns Type Description [0] <code>uint256</code> The currently set cleanup block number."},{"location":"apis/smart-contracts/VPToken/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance,\n    string _name,\n    string _symbol\n) public;\n</code></pre>"},{"location":"apis/smart-contracts/VPToken/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>Governed</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance\n) public;\n</code></pre> Parameters Type Description <code>_governance</code> <code>address</code> Governance contract. Must not be zero."},{"location":"apis/smart-contracts/VPToken/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>ERC20</code> (Source).</p> <pre><code>constructor(\n    string name_,\n    string symbol_\n) public;\n</code></pre> <p>Sets the values for <code>name</code> and <code>symbol</code>, initializes <code>decimals</code> with a default value of 18.</p> <p>To select a different value for <code>decimals</code>, use _setupDecimals.</p> <p>All three of these values are immutable: they can only be set once during construction.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_decimals_313ce567","title":"<code>decimals</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function decimals(\n) public view returns (\n    uint8);\n</code></pre> <p>Returns the number of <code>decimals</code> used to get its user representation. For example, if <code>decimals</code> equals 2, a balance of 505 tokens should be displayed to a user as 5.05 (505 / 10<sup>2</sup>).</p> <p>Tokens usually opt for a value of 18, imitating the relationship between Ether and wei. This is the default value returned by this function, unless it's overridden.</p> <p>NOTE: This information is only used for display purposes: it in no way affects any of the arithmetic of the contract, including <code>balanceOf</code> and <code>transfer</code>.</p> <p>Should be compatible with ERC20 method.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_delegate_026e402b","title":"<code>delegate</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function delegate(\n    address _to,\n    uint256 _bips\n) external;\n</code></pre> <p>Delegate voting power to account <code>_to</code> from <code>msg.sender</code>, by percentage.</p> Parameters Type Description <code>_to</code> <code>address</code> The address of the recipient. <code>_bips</code> <code>uint256</code> The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).   Not cumulative: every call resets the delegation value (and a value of 0 revokes all previous delegations)."},{"location":"apis/smart-contracts/VPToken/#fn_delegateexplicit_d06dc3ad","title":"<code>delegateExplicit</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function delegateExplicit(\n    address _to,\n    uint256 _amount\n) external;\n</code></pre> <p>Explicitly <code>delegate</code> <code>_amount</code> voting power to account <code>_to</code> from <code>msg.sender</code>. Compare with <code>delegate</code> which delegates by percentage.</p> Parameters Type Description <code>_to</code> <code>address</code> The address of the recipient. <code>_amount</code> <code>uint256</code> An explicit vote power amount to be delegated.   Not cumulative: every call resets the delegation value (and a value of 0 revokes all previous delegations)."},{"location":"apis/smart-contracts/VPToken/#fn_delegatesof_7de5b8ed","title":"<code>delegatesOf</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function delegatesOf(\n    address _owner\n) external view returns (\n    address[] _delegateAddresses,\n    uint256[] _bips,\n    uint256 _count,\n    uint256 _delegationMode);\n</code></pre> <p>Get the list of addresses to which <code>_who</code> is delegating, and their percentages.</p> Parameters Type Description <code>_owner</code> <code>address</code> Returns Type Description <code>_delegateAddresses</code> <code>address[]</code> Positional array of addresses being delegated to. <code>_bips</code> <code>uint256[]</code> Positional array of delegation percents specified in basis points (1/100 of 1 percent).    Each one matches the address in the same position in the <code>_delegateAddresses</code> array. <code>_count</code> <code>uint256</code> The number of delegates. <code>_delegationMode</code> <code>uint256</code> Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)."},{"location":"apis/smart-contracts/VPToken/#fn_delegatesofat_ed475a79","title":"<code>delegatesOfAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function delegatesOfAt(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    address[] _delegateAddresses,\n    uint256[] _bips,\n    uint256 _count,\n    uint256 _delegationMode);\n</code></pre> <p>Get the list of addresses to which <code>_who</code> is delegating, and their percentages, at the given block.</p> Parameters Type Description <code>_owner</code> <code>address</code> <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description <code>_delegateAddresses</code> <code>address[]</code> Positional array of addresses being delegated to. <code>_bips</code> <code>uint256[]</code> Positional array of delegation percents specified in basis points (1/100 of 1 percent).    Each one matches the address in the same position in the <code>_delegateAddresses</code> array. <code>_count</code> <code>uint256</code> The number of delegates. <code>_delegationMode</code> <code>uint256</code> Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)."},{"location":"apis/smart-contracts/VPToken/#fn_delegationmodeof_f6837767","title":"<code>delegationModeOf</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function delegationModeOf(\n    address _who\n) external view returns (\n    uint256);\n</code></pre> <p>Get the delegation mode for account '_who'. This mode determines whether vote power is allocated by percentage or by explicit amount. Once the delegation mode is set, it can never be changed, even if all delegations are removed.</p> Parameters Type Description <code>_who</code> <code>address</code> The address to get delegation mode. Returns Type Description [0] <code>uint256</code> Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)."},{"location":"apis/smart-contracts/VPToken/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/VPToken/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_governancevotepower_8c2b8ae1","title":"<code>governanceVotePower</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function governanceVotePower(\n) external view returns (\n    contract IGovernanceVotePower);\n</code></pre> <p>When set, allows token owners to participate in <code>governance</code> voting and <code>delegate</code> <code>governance</code> vote power.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_name_06fdde03","title":"<code>name</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function name(\n) public view returns (\n    string);\n</code></pre> <p>Returns the <code>name</code> of the token.</p> <p>Should be compatible with ERC20 method.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_readvotepowercontract_9b3baa0e","title":"<code>readVotePowerContract</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function readVotePowerContract(\n) external view returns (\n    contract IVPContractEvents);\n</code></pre> <p>Returns <code>VPContract</code> event interface used for read-only operations (view methods). The only non-view method that might be called on it is <code>revokeDelegationAt</code>.</p> <p><code>readVotePowerContract</code> is almost always equal to <code>writeVotePowerContract</code> except during an upgrade from one <code>VPContract</code> to a new version (which should happen rarely or never and will be announced beforehand).</p> <p>Do not call any methods on <code>VPContract</code> directly. State changing methods are forbidden from direct calls. All methods are exposed via <code>VPToken</code>. This is the reason that this method returns <code>IVPContractEvents</code>. Use it only for listening to events and revoking.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_revokedelegationat_bbd6fbf8","title":"<code>revokeDelegationAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function revokeDelegationAt(\n    address _who,\n    uint256 _blockNumber\n) public;\n</code></pre> <p>Revoke all delegation from sender to <code>_who</code> at given block. Only affects the reads via <code>votePowerOfAtCached</code> in the block <code>_blockNumber</code>. Block <code>_blockNumber</code> must be in the past. This method should be used only to prevent rogue <code>delegate</code> voting in the current voting block. To stop delegating use <code>delegate</code> / <code>delegateExplicit</code> with value of 0 or <code>undelegateAll</code> / <code>undelegateAllExplicit</code>.</p> Parameters Type Description <code>_who</code> <code>address</code> Address of the delegatee. <code>_blockNumber</code> <code>uint256</code> The block number at which to revoke delegation.."},{"location":"apis/smart-contracts/VPToken/#fn_setcleanercontract_f6a494af","title":"<code>setCleanerContract</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function setCleanerContract(\n    address _cleanerContract\n) external;\n</code></pre> <p>Set the contract that is allowed to call history cleaning methods.</p> Parameters Type Description <code>_cleanerContract</code> <code>address</code> Address of the cleanup contract. Usually this will be an instance of <code>CleanupBlockNumberManager</code>."},{"location":"apis/smart-contracts/VPToken/#fn_setcleanupblocknumber_13de97f5","title":"<code>setCleanupBlockNumber</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function setCleanupBlockNumber(\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Set the cleanup block number. Historic data for the blocks before <code>cleanupBlockNumber</code> can be erased. History before that block should never be used since it can be inconsistent. In particular, cleanup block number must be lower than the current vote power block.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The new cleanup block number."},{"location":"apis/smart-contracts/VPToken/#fn_setcleanupblocknumbermanager_7f4fcaa9","title":"<code>setCleanupBlockNumberManager</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function setCleanupBlockNumberManager(\n    address _cleanupBlockNumberManager\n) external;\n</code></pre> <p>Set the contract that is allowed to set <code>cleanupBlockNumber</code>. Usually this will be an instance of <code>CleanupBlockNumberManager</code>.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_setgovernancevotepower_9ca2231a","title":"<code>setGovernanceVotePower</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function setGovernanceVotePower(\n    contract IIGovernanceVotePower _governanceVotePower\n) external;\n</code></pre> <p>Sets new <code>governance</code> vote power contract that allows token owners to participate in <code>governance</code> voting and <code>delegate</code> <code>governance</code> vote power.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_setreadvpcontract_31d12a16","title":"<code>setReadVpContract</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function setReadVpContract(\n    contract IIVPContract _vpContract\n) external;\n</code></pre> <p>Call from <code>governance</code> to set read VpContract on token, e.g. vpToken.<code>setReadVpContract</code>(new <code>VPContract</code>(vpToken)).</p> <p>Read <code>VPContract</code> must be set before any of the <code>VPToken</code> delegation or vote power reading methods are called, otherwise they will revert.</p> <p>NOTE: If <code>readVpContract</code> differs from <code>writeVpContract</code> all reads will be \"frozen\" and will not reflect changes (not even revokes; they may or may not reflect balance transfers).</p> Parameters Type Description <code>_vpContract</code> <code>contract IIVPContract</code> Read vote power contract to be used by this token."},{"location":"apis/smart-contracts/VPToken/#fn_setwritevpcontract_755d10a4","title":"<code>setWriteVpContract</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function setWriteVpContract(\n    contract IIVPContract _vpContract\n) external;\n</code></pre> <p>Call from <code>governance</code> to set write VpContract on token, e.g. vpToken.<code>setWriteVpContract</code>(new <code>VPContract</code>(vpToken)).</p> <p>Write <code>VPContract</code> must be set before any of the <code>VPToken</code> delegation modifying methods are called, otherwise they will revert.</p> Parameters Type Description <code>_vpContract</code> <code>contract IIVPContract</code> Write vote power contract to be used by this token."},{"location":"apis/smart-contracts/VPToken/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_symbol_95d89b41","title":"<code>symbol</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function symbol(\n) public view returns (\n    string);\n</code></pre> <p>Returns the <code>symbol</code> of the token, usually a shorter version of the <code>name</code>.</p> <p>Should be compatible with ERC20 method.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_totalsupply_18160ddd","title":"<code>totalSupply</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function totalSupply(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the amount of tokens in existence.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_totalsupplyat_981b24d0","title":"<code>totalSupplyAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function totalSupplyAt(\n    uint256 _blockNumber\n) public view returns (\n    uint256);\n</code></pre> <p>Total amount of tokens at a specific <code>_blockNumber</code>.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The block number when the _totalSupply is queried Returns Type Description [0] <code>uint256</code>"},{"location":"apis/smart-contracts/VPToken/#fn_totalsupplycachecleanup_43ea370b","title":"<code>totalSupplyCacheCleanup</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>function totalSupplyCacheCleanup(\n    uint256 _blockNumber\n) external returns (\n    uint256);\n</code></pre> <p>Delete total supply cache entry that expired (i.e. is before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> the block number for which total supply value was cached Returns Type Description [0] <code>uint256</code> the number of cache entries deleted (always 0 or 1)"},{"location":"apis/smart-contracts/VPToken/#fn_totalsupplyhistorycleanup_f62f8f3a","title":"<code>totalSupplyHistoryCleanup</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>function totalSupplyHistoryCleanup(\n    uint256 _count\n) external returns (\n    uint256);\n</code></pre> <p>Delete total supply checkpoints that expired (i.e. are before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_count</code> <code>uint256</code> maximum number of checkpoints to delete Returns Type Description [0] <code>uint256</code> the number of checkpoints deleted"},{"location":"apis/smart-contracts/VPToken/#fn_totalvotepower_f5f3d4f7","title":"<code>totalVotePower</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function totalVotePower(\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current total vote power.</p> Returns Type Description [0] <code>uint256</code> The current total vote power (sum of all accounts' vote power)."},{"location":"apis/smart-contracts/VPToken/#fn_totalvotepowerat_3e5aa26a","title":"<code>totalVotePowerAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function totalVotePowerAt(\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the total vote power at block <code>_blockNumber</code>.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The total vote power at the queried block (sum of all accounts' vote powers)."},{"location":"apis/smart-contracts/VPToken/#fn_totalvotepoweratcached_caeb942b","title":"<code>totalVotePowerAtCached</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function totalVotePowerAtCached(\n    uint256 _blockNumber\n) public returns (\n    uint256);\n</code></pre> <p>Get the total vote power at block <code>_blockNumber</code> using cache.   It tries to read the cached value and if it is not found, reads the actual value and stores it in the cache.   Can only be used if <code>_blockNumber</code> is in the past, otherwise reverts.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The total vote power at the queried block (sum of all accounts' vote powers)."},{"location":"apis/smart-contracts/VPToken/#fn_transfer_a9059cbb","title":"<code>transfer</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function transfer(\n    address recipient,\n    uint256 amount\n) external returns (\n    bool);\n</code></pre> <p>Moves <code>amount</code> tokens from the caller's account to <code>recipient</code>.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>Emits a <code>Transfer</code> event.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_transferfrom_23b872dd","title":"<code>transferFrom</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n) external returns (\n    bool);\n</code></pre> <p>Moves <code>amount</code> tokens from <code>sender</code> to <code>recipient</code> using the <code>allowance</code> mechanism. <code>amount</code> is then deducted from the caller's <code>allowance</code>.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>Emits a <code>Transfer</code> event.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_undelegateall_b302f393","title":"<code>undelegateAll</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function undelegateAll(\n) external;\n</code></pre> <p>Undelegate all voting power of <code>msg.sender</code>. This effectively revokes all previous delegations. Can only be used with percentage delegation. Does not reset delegation mode back to NOT SET.</p>"},{"location":"apis/smart-contracts/VPToken/#fn_undelegateallexplicit_5d6d11eb","title":"<code>undelegateAllExplicit</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function undelegateAllExplicit(\n    address[] _delegateAddresses\n) external returns (\n    uint256 _remainingDelegation);\n</code></pre> <p>Undelegate all explicit vote power by amount of <code>msg.sender</code>. Can only be used with explicit delegation. Does not reset delegation mode back to NOT SET.</p> Parameters Type Description <code>_delegateAddresses</code> <code>address[]</code> Explicit delegation does not store delegatees' addresses,   so the caller must supply them. Returns Type Description <code>_remainingDelegation</code> <code>uint256</code> The amount still delegated (in case the list of delegates was incomplete)."},{"location":"apis/smart-contracts/VPToken/#fn_undelegatedvotepowerof_d6aa0b77","title":"<code>undelegatedVotePowerOf</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function undelegatedVotePowerOf(\n    address _owner\n) external view returns (\n    uint256);\n</code></pre> <p>Compute the current undelegated vote power of the <code>_owner</code> account.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. Returns Type Description [0] <code>uint256</code> The unallocated vote power of <code>_owner</code>."},{"location":"apis/smart-contracts/VPToken/#fn_undelegatedvotepowerofat_83035a82","title":"<code>undelegatedVotePowerOfAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function undelegatedVotePowerOfAt(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the undelegated vote power of the <code>_owner</code> account at a given block number.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The unallocated vote power of <code>_owner</code>."},{"location":"apis/smart-contracts/VPToken/#fn_votepowerfromto_be0ca747","title":"<code>votePowerFromTo</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function votePowerFromTo(\n    address _from,\n    address _to\n) external view returns (\n    uint256);\n</code></pre> <p>Get current delegated vote power from delegator <code>_from</code> to delegatee <code>_to</code>.</p> Parameters Type Description <code>_from</code> <code>address</code> Address of delegator. <code>_to</code> <code>address</code> Address of delegatee. Returns Type Description [0] <code>uint256</code> votePower The delegated vote power."},{"location":"apis/smart-contracts/VPToken/#fn_votepowerfromtoat_e64767aa","title":"<code>votePowerFromToAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function votePowerFromToAt(\n    address _from,\n    address _to,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get delegated vote power from delegator <code>_from</code> to delegatee <code>_to</code> at <code>_blockNumber</code>.</p> Parameters Type Description <code>_from</code> <code>address</code> Address of delegator. <code>_to</code> <code>address</code> Address of delegatee. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The delegated vote power."},{"location":"apis/smart-contracts/VPToken/#fn_votepowerof_142d1018","title":"<code>votePowerOf</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function votePowerOf(\n    address _owner\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current vote power of <code>_owner</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. Returns Type Description [0] <code>uint256</code> Current vote power of <code>_owner</code>."},{"location":"apis/smart-contracts/VPToken/#fn_votepowerofat_92bfe6d8","title":"<code>votePowerOfAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function votePowerOfAt(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the vote power of <code>_owner</code> at block <code>_blockNumber</code></p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> Vote power of <code>_owner</code> at block number <code>_blockNumber</code>."},{"location":"apis/smart-contracts/VPToken/#fn_votepowerofatcached_e587497e","title":"<code>votePowerOfAtCached</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function votePowerOfAtCached(\n    address _owner,\n    uint256 _blockNumber\n) public returns (\n    uint256);\n</code></pre> <p>Get the vote power of <code>_owner</code> at block <code>_blockNumber</code> using cache.   It tries to read the cached value and if it is not found, reads the actual value and stores it in the cache.   Can only be used if <code>_blockNumber</code> is in the past, otherwise reverts.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> Vote power of <code>_owner</code> at <code>_blockNumber</code>."},{"location":"apis/smart-contracts/VPToken/#fn_votepowerofatignoringrevocation_04bb4e43","title":"<code>votePowerOfAtIgnoringRevocation</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function votePowerOfAtIgnoringRevocation(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the vote power of <code>_owner</code> at block <code>_blockNumber</code>, ignoring revocation information (and cache).</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> Vote power of <code>_owner</code> at block number <code>_blockNumber</code>. Result doesn't change if vote power is revoked."},{"location":"apis/smart-contracts/VPToken/#fn_writevotepowercontract_1fec092a","title":"<code>writeVotePowerContract</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function writeVotePowerContract(\n) external view returns (\n    contract IVPContractEvents);\n</code></pre> <p>Returns <code>VPContract</code> event interface used for state-changing operations (non-view methods). The only non-view method that might be called on it is <code>revokeDelegationAt</code>.</p> <p><code>writeVotePowerContract</code> is almost always equal to <code>readVotePowerContract</code>, except during upgrade from one <code>VPContract</code> to a new version (which should happen rarely or never and will be announced beforehand). In the case of an upgrade, <code>writeVotePowerContract</code> is replaced first to establish delegations. After some period (e.g., after a reward epoch ends), <code>readVotePowerContract</code> is set equal to it.</p> <p>Do not call any methods on <code>VPContract</code> directly. State changing methods are forbidden from direct calls. All are exposed via <code>VPToken</code>. This is the reason that this method returns <code>IVPContractEvents</code> Use it only for listening to events, delegating, and revoking.</p>"},{"location":"apis/smart-contracts/VPToken/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/VPToken/#va_cleanercontract","title":"<code>cleanerContract</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>    address cleanerContract\n</code></pre> <p>Address of the contract that is allowed to call methods for history cleaning.</p>"},{"location":"apis/smart-contracts/VPToken/#va_cleanupblocknumbermanager","title":"<code>cleanupBlockNumberManager</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>    address cleanupBlockNumberManager\n</code></pre> <p>The contract that is allowed to set <code>cleanupBlockNumber</code>. Usually this will be an instance of <code>CleanupBlockNumberManager</code>.</p>"},{"location":"apis/smart-contracts/VPToken/#va_governancesettings","title":"<code>governanceSettings</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    contract IGovernanceSettings governanceSettings\n</code></pre> <p>Governance Settings.</p>"},{"location":"apis/smart-contracts/VPToken/#va_productionmode","title":"<code>productionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    bool productionMode\n</code></pre> <p>When true, <code>governance</code> is enabled and cannot be disabled. See <code>switchToProductionMode</code>.</p>"},{"location":"apis/smart-contracts/VPToken/#va_timelockedcalls","title":"<code>timelockedCalls</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    mapping(bytes4 =&gt; struct GovernedBase.TimelockedCall) timelockedCalls\n</code></pre> <p>List of pending timelocked <code>governance</code> calls.</p>"},{"location":"apis/smart-contracts/VPToken/#va_vpcontractinitialized","title":"<code>vpContractInitialized</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>    bool vpContractInitialized\n</code></pre> <p>When true, the argument to <code>setWriteVpContract</code> must be a vpContract with <code>isReplacement</code> set to <code>true</code>. To be used for creating the correct <code>VPContract</code>.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/","title":"VoterWhitelister","text":""},{"location":"apis/smart-contracts/VoterWhitelister/#ct_voterwhitelister","title":"<code>VoterWhitelister</code>","text":"<p>Source | Inherits from IIVoterWhitelister, Governed, AddressUpdatable</p> <p>Manager of the FTSO whitelist.</p> <p>Only addresses registered in this contract can submit data to the FTSO system.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/VoterWhitelister/#fn_addftso_345705a4","title":"<code>addFtso</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>function addFtso(\n    uint256 _ftsoIndex\n) external;\n</code></pre> <p>Create an empty whitelist with default size for a new FTSO.</p> <p>Only <code>ftsoManager</code> can call this method.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Index of the new FTSO."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_chillvoter_2b4faebb","title":"<code>chillVoter</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>function chillVoter(\n    address _voter,\n    uint256 _noOfRewardEpochs,\n    uint256[] _ftsoIndices\n) external returns (\n    bool[] _removed,\n    uint256 _untilRewardEpoch);\n</code></pre> <p>Used to chill a data provider, this is, remove it from the whitelist for a specified number of reward epochs.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_voter</code> <code>address</code> Data provider being chilled. <code>_noOfRewardEpochs</code> <code>uint256</code> Number of epochs to chill the provider for. <code>_ftsoIndices</code> <code>uint256[]</code> Array of indices of the FTSOs that will not allow this provider to submit data."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_chilleduntilrewardepoch_46538074","title":"<code>chilledUntilRewardEpoch</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function chilledUntilRewardEpoch(\n    address _voter\n) external view returns (\n    uint256);\n</code></pre> <p>In case of providing bad prices (e.g. collusion), the voter can be chilled for a few reward epochs. A voter can whitelist again from a returned reward epoch onwards.</p> Parameters Type Description <code>_voter</code> <code>address</code> Address of the queried data provider. Returns Type Description [0] <code>uint256</code> uint256 ID of the epoch where the data provider can start submitting prices again."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance,\n    address _addressUpdater,\n    contract IIPriceSubmitter _priceSubmitter,\n    uint256 _defaultMaxVotersForFtso,\n    contract IVoterWhitelister _oldVoterWhitelister\n) public;\n</code></pre>"},{"location":"apis/smart-contracts/VoterWhitelister/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>Governed</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance\n) public;\n</code></pre> Parameters Type Description <code>_governance</code> <code>address</code> Governance contract. Must not be zero."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_copywhitelist_8e15c883","title":"<code>copyWhitelist</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>function copyWhitelist(\n    uint256 _ftsoIndex\n) external;\n</code></pre> <p>Copy whitelist data from <code>oldVoterWhitelister</code> for a specific FTSO. Can only be called by <code>governance</code>.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO whose whitelist is to be copied."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_defaultmaxvotersforftso_47ed51b1","title":"<code>defaultMaxVotersForFtso</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function defaultMaxVotersForFtso(\n) external view returns (\n    uint256);\n</code></pre> <p>Maximum number of voters in the whitelist for a new FTSO.</p> Returns Type Description [0] <code>uint256</code> uint256 Default maximum allowed voters."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_getaddressupdater_5267a15d","title":"<code>getAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function getAddressUpdater(\n) public view returns (\n    address _addressUpdater);\n</code></pre> <p>Returns the configured address updater.</p> Returns Type Description <code>_addressUpdater</code> <code>address</code> The <code>AddresUpdater</code> contract that can update our contract address list, as a response to a governance call."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_getftsowhitelistedpriceproviders_09fcb400","title":"<code>getFtsoWhitelistedPriceProviders</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>function getFtsoWhitelistedPriceProviders(\n    uint256 _ftsoIndex\n) public view returns (\n    address[]);\n</code></pre> <p>Gets whitelisted price providers for the FTSO at a given index.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Queried index. Returns Type Description [0] <code>address[]</code> Array of addresses of the whitelisted data providers."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_getftsowhitelistedpriceprovidersbysymbol_aa89dfd4","title":"<code>getFtsoWhitelistedPriceProvidersBySymbol</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>function getFtsoWhitelistedPriceProvidersBySymbol(\n    string _symbol\n) external view returns (\n    address[]);\n</code></pre> <p>Gets whitelisted price providers for the FTSO with a specified symbol.</p> Parameters Type Description <code>_symbol</code> <code>string</code> Queried symbol. Returns Type Description [0] <code>address[]</code> Array of addresses of the whitelisted data providers."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#fn_maxvotersforftso_98dccfc2","title":"<code>maxVotersForFtso</code>","text":"<p>Defined in <code>IVoterWhitelister</code> (Docs, Source).</p> <pre><code>function maxVotersForFtso(\n    uint256 _ftsoIndex\n) external view returns (\n    uint256);\n</code></pre> <p>Maximum number of voters in the whitelist for a specific FTSO. Adjustable separately for each index.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO. Returns Type Description [0] <code>uint256</code> uint256 Maximum allowed voters."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_removeftso_d8736171","title":"<code>removeFtso</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>function removeFtso(\n    uint256 _ftsoIndex\n) external;\n</code></pre> <p>Clear whitelist for a removed FTSO.</p> <p>Only <code>ftsoManager</code> can call this method.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Index of the removed FTSO."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_removetrustedaddressfromwhitelist_9dc950ab","title":"<code>removeTrustedAddressFromWhitelist</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>function removeTrustedAddressFromWhitelist(\n    address _trustedAddress,\n    uint256 _ftsoIndex\n) external;\n</code></pre> <p>Remove a trusted address from whitelist.</p> Parameters Type Description <code>_trustedAddress</code> <code>address</code> Address to remove. <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO being modified."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_requestfullvoterwhitelisting_b06cbaf7","title":"<code>requestFullVoterWhitelisting</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>function requestFullVoterWhitelisting(\n    address _voter\n) external returns (\n    uint256[] _supportedIndices,\n    bool[] _success);\n</code></pre> <p>Requests whitelisting an account to act as a data provider for all active FTSOs. May be called by any address, including the voter itself.</p> Parameters Type Description <code>_voter</code> <code>address</code> Address of the voter to be whitelisted. Returns Type Description <code>_supportedIndices</code> <code>uint256[]</code> Array of currently supported FTSO indices. <code>_success</code> <code>bool[]</code> Array of success flags by FTSO index."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_requestwhitelistingvoter_3de2cb1c","title":"<code>requestWhitelistingVoter</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>function requestWhitelistingVoter(\n    address _voter,\n    uint256 _ftsoIndex\n) external;\n</code></pre> <p>Requests whitelisting an account to act as a data provider for a specific FTSO. Reverts if the vote power of the account is too low. May be called by any address, including the voter itself.</p> Parameters Type Description <code>_voter</code> <code>address</code> Address of the voter to be whitelisted. <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_setdefaultmaxvotersforftso_2ee96140","title":"<code>setDefaultMaxVotersForFtso</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>function setDefaultMaxVotersForFtso(\n    uint256 _defaultMaxVotersForFtso\n) external;\n</code></pre> <p>Set the maximum number of voters in the whitelist for a new FTSOs.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_defaultMaxVotersForFtso</code> <code>uint256</code> New maximum default value."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_setmaxvotersforftso_7ecfcfa3","title":"<code>setMaxVotersForFtso</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>function setMaxVotersForFtso(\n    uint256 _ftsoIndex,\n    uint256 _newMaxVoters\n) external;\n</code></pre> <p>Set the maximum number of voters in the whitelist for a specific FTSO. Can remove voters with the least votepower from the whitelist.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_ftsoIndex</code> <code>uint256</code> Index of the FTSO to modify. <code>_newMaxVoters</code> <code>uint256</code> New size of the whitelist."},{"location":"apis/smart-contracts/VoterWhitelister/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#fn_turnoffcopymode_3a65d7b6","title":"<code>turnOffCopyMode</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>function turnOffCopyMode(\n) external;\n</code></pre> <p>Turn off copy mode. Can only be called by <code>governance</code>.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#fn_updatecontractaddresses_b00c0b76","title":"<code>updateContractAddresses</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>function updateContractAddresses(\n    bytes32[] _contractNameHashes,\n    address[] _contractAddresses\n) external;\n</code></pre> <p>External method called from <code>AddressUpdater</code> only.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#modifiers","title":"Modifiers","text":""},{"location":"apis/smart-contracts/VoterWhitelister/#md_notincopymode","title":"<code>notInCopyMode</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>modifier notInCopyMode()\n</code></pre> <p>Only callable when not in copy mode.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#md_onlyaddressupdater","title":"<code>onlyAddressUpdater</code>","text":"<p>Defined in <code>AddressUpdatable</code> (Docs, Source).</p> <pre><code>modifier onlyAddressUpdater()\n</code></pre> <p>Only the <code>AdressUpdater</code> contract can call this method. Its address is set at construction time but it can also update itself.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#md_onlyftsomanager","title":"<code>onlyFtsoManager</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>modifier onlyFtsoManager()\n</code></pre> <p>Only the <code>ftsoManager</code> can call this method.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#md_onlygovernance","title":"<code>onlyGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/VoterWhitelister/#md_onlyimmediategovernance","title":"<code>onlyImmediateGovernance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>modifier onlyImmediateGovernance()\n</code></pre>"},{"location":"apis/smart-contracts/VoterWhitelister/#md_voternotchilled","title":"<code>voterNotChilled</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>modifier voterNotChilled(    address _voter)\n</code></pre> <p>Only data providers that have not been chilled can perform this action.</p> Parameters Type Description <code>_voter</code> <code>address</code> Address of the data provider performing the action."},{"location":"apis/smart-contracts/VoterWhitelister/#variables","title":"Variables","text":""},{"location":"apis/smart-contracts/VoterWhitelister/#va_chilleduntilrewardepoch","title":"<code>chilledUntilRewardEpoch</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>    mapping(address =&gt; uint256) chilledUntilRewardEpoch\n</code></pre> <p>In case of providing bad prices (e.g. collusion), the voter can be chilled for a few reward epochs. A voter can whitelist again from a returned reward epoch onwards.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#va_copymode","title":"<code>copyMode</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>    bool copyMode\n</code></pre>"},{"location":"apis/smart-contracts/VoterWhitelister/#va_defaultmaxvotersforftso","title":"<code>defaultMaxVotersForFtso</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>    uint256 defaultMaxVotersForFtso\n</code></pre> <p>Maximum number of voters in the whitelist for a new FTSO.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#va_ftsomanager","title":"<code>ftsoManager</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>    contract IFtsoManager ftsoManager\n</code></pre> <p>Address of the <code>FtsoManager</code> contract.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#va_ftsoregistry","title":"<code>ftsoRegistry</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>    contract IFtsoRegistry ftsoRegistry\n</code></pre> <p>Address of the <code>FtsoRegistry</code> contract.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#va_governancesettings","title":"<code>governanceSettings</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    contract IGovernanceSettings governanceSettings\n</code></pre> <p>Governance Settings.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#va_maxvotersforftso","title":"<code>maxVotersForFtso</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>    mapping(uint256 =&gt; uint256) maxVotersForFtso\n</code></pre> <p>Maximum number of voters in the whitelist for a specific FTSO. Adjustable separately for each index.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#va_oldvoterwhitelister","title":"<code>oldVoterWhitelister</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>    contract IVoterWhitelister oldVoterWhitelister\n</code></pre> <p>Previous <code>VoterWhitelister</code> contract, set at construction time. Necessary to allow copying the previous whitelist onto a new contract.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#va_pricesubmitter","title":"<code>priceSubmitter</code>","text":"<p>Defined in <code>VoterWhitelister</code> (Docs, Source).</p> <pre><code>    contract IIPriceSubmitter priceSubmitter\n</code></pre> <p>Address of the <code>PriceSubmitter</code> contract set at construction time.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#va_productionmode","title":"<code>productionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    bool productionMode\n</code></pre> <p>When true, <code>governance</code> is enabled and cannot be disabled. See <code>switchToProductionMode</code>.</p>"},{"location":"apis/smart-contracts/VoterWhitelister/#va_timelockedcalls","title":"<code>timelockedCalls</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>    mapping(bytes4 =&gt; struct GovernedBase.TimelockedCall) timelockedCalls\n</code></pre> <p>List of pending timelocked <code>governance</code> calls.</p>"},{"location":"apis/smart-contracts/WNat/","title":"WNat","text":""},{"location":"apis/smart-contracts/WNat/#ct_wnat","title":"<code>WNat</code>","text":"<p>Source | Inherits from VPToken, IWNat</p> <p>Wrapped native token.</p> <p>This contract converts native tokens into <code>WNAT</code> (wrapped native) tokens and vice versa. <code>WNAT</code> tokens are a one-to-one ERC20 representation of native tokens, which are minted and burned as needed by this contract.</p> <p>The wrapped versions of the native <code>FLR</code> and <code>SGB</code> tokens are called <code>WFLR</code> and <code>WSGB</code> respectively.</p> <p>Besides the standard ERC20 operations, this contract supports FTSO delegation and governance vote delegation.</p> <p>Code attribution: WETH9.</p>"},{"location":"apis/smart-contracts/WNat/#events","title":"Events","text":""},{"location":"apis/smart-contracts/WNat/#ev_approval","title":"<code>Approval</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>event Approval(\n    address owner,\n    address spender,\n    uint256 value\n)\n</code></pre> <p>Emitted when the <code>allowance</code> of a <code>spender</code> for an <code>owner</code> is set by a call to <code>approve</code>. <code>value</code> is the new <code>allowance</code>.</p>"},{"location":"apis/smart-contracts/WNat/#ev_createdtotalsupplycache","title":"<code>CreatedTotalSupplyCache</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>event CreatedTotalSupplyCache(\n    uint256 _blockNumber\n)\n</code></pre> <p>Emitted when a total supply cache entry is created. Allows history cleaners to track total supply cache cleanup opportunities off-chain.</p>"},{"location":"apis/smart-contracts/WNat/#ev_deposit","title":"<code>Deposit</code>","text":"<p>Defined in <code>WNat</code> (Docs, Source).</p> <pre><code>event Deposit(\n    address dst,\n    uint256 amount\n)\n</code></pre> <p>Emitted when tokens have been wrapped.</p> Parameters Type Description <code>dst</code> <code>address</code> The account that received the wrapped tokens. <code>amount</code> <code>uint256</code> The amount that was wrapped."},{"location":"apis/smart-contracts/WNat/#ev_governancecalltimelocked","title":"<code>GovernanceCallTimelocked</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernanceCallTimelocked(\n    bytes4 selector,\n    uint256 allowedAfterTimestamp,\n    bytes encodedCall\n)\n</code></pre> <p>Emitted when a new <code>governance</code> call has been recorded and is now waiting for the time lock to expire.</p>"},{"location":"apis/smart-contracts/WNat/#ev_governanceinitialised","title":"<code>GovernanceInitialised</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernanceInitialised(\n    address initialGovernance\n)\n</code></pre> <p>Emitted when the <code>governance</code> address is initialized. This address will be used until production mode is entered (see <code>GovernedProductionModeEntered</code>). At that point the <code>governance</code> address is taken from <code>GovernanceSettings</code>.</p>"},{"location":"apis/smart-contracts/WNat/#ev_governedproductionmodeentered","title":"<code>GovernedProductionModeEntered</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event GovernedProductionModeEntered(\n    address governanceSettings\n)\n</code></pre> <p>Emitted when <code>governance</code> is enabled and the <code>governance</code> address cannot be changed anymore (only through a network fork).</p>"},{"location":"apis/smart-contracts/WNat/#ev_timelockedgovernancecallcanceled","title":"<code>TimelockedGovernanceCallCanceled</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event TimelockedGovernanceCallCanceled(\n    bytes4 selector,\n    uint256 timestamp\n)\n</code></pre> <p>Emitted when a timelocked <code>governance</code> call is canceled before execution.</p>"},{"location":"apis/smart-contracts/WNat/#ev_timelockedgovernancecallexecuted","title":"<code>TimelockedGovernanceCallExecuted</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>event TimelockedGovernanceCallExecuted(\n    bytes4 selector,\n    uint256 timestamp\n)\n</code></pre> <p>Emitted when a timelocked <code>governance</code> call is executed.</p>"},{"location":"apis/smart-contracts/WNat/#ev_transfer","title":"<code>Transfer</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>event Transfer(\n    address from,\n    address to,\n    uint256 value\n)\n</code></pre> <p>Emitted when <code>value</code> tokens are moved from one account (<code>from</code>) to another (<code>to</code>).</p> <p>Note that <code>value</code> may be zero.</p>"},{"location":"apis/smart-contracts/WNat/#ev_votepowercontractchanged","title":"<code>VotePowerContractChanged</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>event VotePowerContractChanged(\n    uint256 _contractType,\n    address _oldContractAddress,\n    address _newContractAddress\n)\n</code></pre> <p>Emitted when one of the vote power contracts is changed.</p> <p>It is used to track the history of <code>VPToken</code> -&gt; <code>VPContract</code> / <code>GovernanceVotePower</code> associations (e.g. by external cleaners).</p> Parameters Type Description <code>_contractType</code> <code>uint256</code> 0 = Read <code>VPContract</code>, 1 = Write <code>VPContract</code>, 2 = Governance vote power. <code>_oldContractAddress</code> <code>address</code> Contract address before change. <code>_newContractAddress</code> <code>address</code> Contract address after change."},{"location":"apis/smart-contracts/WNat/#ev_withdrawal","title":"<code>Withdrawal</code>","text":"<p>Defined in <code>WNat</code> (Docs, Source).</p> <pre><code>event Withdrawal(\n    address src,\n    uint256 amount\n)\n</code></pre> <p>Emitted when tokens have been unwrapped.</p> Parameters Type Description <code>src</code> <code>address</code> The account that received the unwrapped tokens. <code>amount</code> <code>uint256</code> The amount that was unwrapped."},{"location":"apis/smart-contracts/WNat/#functions","title":"Functions","text":""},{"location":"apis/smart-contracts/WNat/#fn_allowance_dd62ed3e","title":"<code>allowance</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function allowance(\n    address owner,\n    address spender\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the remaining number of tokens that <code>spender</code> will be allowed to spend on behalf of <code>owner</code> through <code>transferFrom</code>. This is zero by default.</p> <p>This value changes when <code>approve</code> or <code>transferFrom</code> are called.</p>"},{"location":"apis/smart-contracts/WNat/#fn_approve_095ea7b3","title":"<code>approve</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function approve(\n    address spender,\n    uint256 amount\n) external returns (\n    bool);\n</code></pre> <p>Sets <code>amount</code> as the <code>allowance</code> of <code>spender</code> over the caller's tokens.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>IMPORTANT: Beware that changing an <code>allowance</code> with this method brings the risk that someone may use both the old and the new <code>allowance</code> by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's <code>allowance</code> to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</p> <p>Emits an <code>Approval</code> event.</p>"},{"location":"apis/smart-contracts/WNat/#fn_balancehistorycleanup_f0e292c9","title":"<code>balanceHistoryCleanup</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>function balanceHistoryCleanup(\n    address _owner,\n    uint256 _count\n) external returns (\n    uint256);\n</code></pre> <p>Delete balance checkpoints that expired (i.e. are before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_owner</code> <code>address</code> balance owner account address <code>_count</code> <code>uint256</code> maximum number of checkpoints to delete Returns Type Description [0] <code>uint256</code> the number of checkpoints deleted"},{"location":"apis/smart-contracts/WNat/#fn_balanceof_70a08231","title":"<code>balanceOf</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function balanceOf(\n    address account\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the amount of tokens owned by <code>account</code>.</p>"},{"location":"apis/smart-contracts/WNat/#fn_balanceofat_4ee2cd7e","title":"<code>balanceOfAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function balanceOfAt(\n    address _owner,\n    uint256 _blockNumber\n) public view returns (\n    uint256);\n</code></pre> <p>Queries the token balance of <code>_owner</code> at a specific <code>_blockNumber</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address from which the balance will be retrieved. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code>"},{"location":"apis/smart-contracts/WNat/#fn_batchdelegate_dc4fcda7","title":"<code>batchDelegate</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function batchDelegate(\n    address[] _delegatees,\n    uint256[] _bips\n) external;\n</code></pre> <p>Undelegate all percentage delegations from the sender and then <code>delegate</code> corresponding   <code>_bips</code> percentage of voting power from the sender to each member of the <code>_delegatees</code> array.</p> Parameters Type Description <code>_delegatees</code> <code>address[]</code> The addresses of the new recipients. <code>_bips</code> <code>uint256[]</code> The percentages of voting power to be delegated expressed in basis points (1/100 of one percent).   The sum of all <code>_bips</code> values must be at most 10000 (100%)."},{"location":"apis/smart-contracts/WNat/#fn_batchvotepowerofat_49e3c7e5","title":"<code>batchVotePowerOfAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function batchVotePowerOfAt(\n    address[] _owners,\n    uint256 _blockNumber\n) external view returns (\n    uint256[]);\n</code></pre> <p>Return the vote power for several addresses.</p> Parameters Type Description <code>_owners</code> <code>address[]</code> The list of addresses to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256[]</code> Array of vote power for each queried address."},{"location":"apis/smart-contracts/WNat/#fn_cancelgovernancecall_67fc4029","title":"<code>cancelGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function cancelGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Cancel a timelocked <code>governance</code> call before it has been executed.</p> <p>Only <code>governance</code> can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector."},{"location":"apis/smart-contracts/WNat/#fn_cleanupblocknumber_deea13e7","title":"<code>cleanupBlockNumber</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function cleanupBlockNumber(\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current cleanup block number set with <code>setCleanupBlockNumber</code>.</p> Returns Type Description [0] <code>uint256</code> The currently set cleanup block number."},{"location":"apis/smart-contracts/WNat/#fn_constructor_undefined","title":"<code>constructor</code>","text":"<p>Defined in <code>WNat</code> (Docs, Source).</p> <pre><code>constructor(\n    address _governance,\n    string _name,\n    string _symbol\n) public;\n</code></pre> <p>Construct an ERC20 token.</p>"},{"location":"apis/smart-contracts/WNat/#fn_decimals_313ce567","title":"<code>decimals</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function decimals(\n) public view returns (\n    uint8);\n</code></pre> <p>Returns the number of <code>decimals</code> used to get its user representation. For example, if <code>decimals</code> equals 2, a balance of 505 tokens should be displayed to a user as 5.05 (505 / 10<sup>2</sup>).</p> <p>Tokens usually opt for a value of 18, imitating the relationship between Ether and wei. This is the default value returned by this function, unless it's overridden.</p> <p>NOTE: This information is only used for display purposes: it in no way affects any of the arithmetic of the contract, including <code>balanceOf</code> and <code>transfer</code>.</p> <p>Should be compatible with ERC20 method.</p>"},{"location":"apis/smart-contracts/WNat/#fn_delegate_026e402b","title":"<code>delegate</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function delegate(\n    address _to,\n    uint256 _bips\n) external;\n</code></pre> <p>Delegate voting power to account <code>_to</code> from <code>msg.sender</code>, by percentage.</p> Parameters Type Description <code>_to</code> <code>address</code> The address of the recipient. <code>_bips</code> <code>uint256</code> The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).   Not cumulative: every call resets the delegation value (and a value of 0 revokes all previous delegations)."},{"location":"apis/smart-contracts/WNat/#fn_delegateexplicit_d06dc3ad","title":"<code>delegateExplicit</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function delegateExplicit(\n    address _to,\n    uint256 _amount\n) external;\n</code></pre> <p>Explicitly <code>delegate</code> <code>_amount</code> voting power to account <code>_to</code> from <code>msg.sender</code>. Compare with <code>delegate</code> which delegates by percentage.</p> Parameters Type Description <code>_to</code> <code>address</code> The address of the recipient. <code>_amount</code> <code>uint256</code> An explicit vote power amount to be delegated.   Not cumulative: every call resets the delegation value (and a value of 0 revokes all previous delegations)."},{"location":"apis/smart-contracts/WNat/#fn_delegatesof_7de5b8ed","title":"<code>delegatesOf</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function delegatesOf(\n    address _owner\n) external view returns (\n    address[] _delegateAddresses,\n    uint256[] _bips,\n    uint256 _count,\n    uint256 _delegationMode);\n</code></pre> <p>Get the list of addresses to which <code>_who</code> is delegating, and their percentages.</p> Parameters Type Description <code>_owner</code> <code>address</code> Returns Type Description <code>_delegateAddresses</code> <code>address[]</code> Positional array of addresses being delegated to. <code>_bips</code> <code>uint256[]</code> Positional array of delegation percents specified in basis points (1/100 of 1 percent).    Each one matches the address in the same position in the <code>_delegateAddresses</code> array. <code>_count</code> <code>uint256</code> The number of delegates. <code>_delegationMode</code> <code>uint256</code> Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)."},{"location":"apis/smart-contracts/WNat/#fn_delegatesofat_ed475a79","title":"<code>delegatesOfAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function delegatesOfAt(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    address[] _delegateAddresses,\n    uint256[] _bips,\n    uint256 _count,\n    uint256 _delegationMode);\n</code></pre> <p>Get the list of addresses to which <code>_who</code> is delegating, and their percentages, at the given block.</p> Parameters Type Description <code>_owner</code> <code>address</code> <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description <code>_delegateAddresses</code> <code>address[]</code> Positional array of addresses being delegated to. <code>_bips</code> <code>uint256[]</code> Positional array of delegation percents specified in basis points (1/100 of 1 percent).    Each one matches the address in the same position in the <code>_delegateAddresses</code> array. <code>_count</code> <code>uint256</code> The number of delegates. <code>_delegationMode</code> <code>uint256</code> Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)."},{"location":"apis/smart-contracts/WNat/#fn_delegationmodeof_f6837767","title":"<code>delegationModeOf</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function delegationModeOf(\n    address _who\n) external view returns (\n    uint256);\n</code></pre> <p>Get the delegation mode for account '_who'. This mode determines whether vote power is allocated by percentage or by explicit amount. Once the delegation mode is set, it can never be changed, even if all delegations are removed.</p> Parameters Type Description <code>_who</code> <code>address</code> The address to get delegation mode. Returns Type Description [0] <code>uint256</code> Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)."},{"location":"apis/smart-contracts/WNat/#fn_deposit_d0e30db0","title":"<code>deposit</code>","text":"<p>Defined in <code>WNat</code> (Docs, Source).</p> <pre><code>function deposit(\n) public payable;\n</code></pre> <p>Deposits native tokens and mints the same amount of <code>WNAT</code> tokens, which are added to the <code>msg.sender</code>'s balance. This operation is commonly known as \"wrapping\".</p> <p>Emits a <code>Deposit</code> event.</p>"},{"location":"apis/smart-contracts/WNat/#fn_depositto_b760faf9","title":"<code>depositTo</code>","text":"<p>Defined in <code>WNat</code> (Docs, Source).</p> <pre><code>function depositTo(\n    address _recipient\n) external payable;\n</code></pre> <p>Deposits native tokens and mints the same amount of <code>WNAT</code> tokens, which are added to <code>_recipient</code>'s balance. This operation is commonly known as \"wrapping\".</p> <p>This is equivalent to using <code>deposit</code> followed by <code>transfer</code>.</p> <p>Emits a <code>Deposit</code> event.</p> Parameters Type Description <code>_recipient</code> <code>address</code> The address to receive the minted <code>WNAT</code>."},{"location":"apis/smart-contracts/WNat/#fn_executegovernancecall_5ff27079","title":"<code>executeGovernanceCall</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function executeGovernanceCall(\n    bytes4 _selector\n) external;\n</code></pre> <p>Execute the timelocked <code>governance</code> calls once the timelock period expires.</p> <p>Only executor can call this method.</p> Parameters Type Description <code>_selector</code> <code>bytes4</code> The method selector (only one timelocked call per method is stored)."},{"location":"apis/smart-contracts/WNat/#fn_governance_5aa6e675","title":"<code>governance</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function governance(\n) public view returns (\n    address);\n</code></pre> <p>Returns the current effective <code>governance</code> address.</p>"},{"location":"apis/smart-contracts/WNat/#fn_governancevotepower_8c2b8ae1","title":"<code>governanceVotePower</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function governanceVotePower(\n) external view returns (\n    contract IGovernanceVotePower);\n</code></pre> <p>When set, allows token owners to participate in <code>governance</code> voting and <code>delegate</code> <code>governance</code> vote power.</p>"},{"location":"apis/smart-contracts/WNat/#fn_name_06fdde03","title":"<code>name</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function name(\n) public view returns (\n    string);\n</code></pre> <p>Returns the <code>name</code> of the token.</p> <p>Should be compatible with ERC20 method.</p>"},{"location":"apis/smart-contracts/WNat/#fn_readvotepowercontract_9b3baa0e","title":"<code>readVotePowerContract</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function readVotePowerContract(\n) external view returns (\n    contract IVPContractEvents);\n</code></pre> <p>Returns <code>VPContract</code> event interface used for read-only operations (view methods). The only non-view method that might be called on it is <code>revokeDelegationAt</code>.</p> <p><code>readVotePowerContract</code> is almost always equal to <code>writeVotePowerContract</code> except during an upgrade from one <code>VPContract</code> to a new version (which should happen rarely or never and will be announced beforehand).</p> <p>Do not call any methods on <code>VPContract</code> directly. State changing methods are forbidden from direct calls. All methods are exposed via <code>VPToken</code>. This is the reason that this method returns <code>IVPContractEvents</code>. Use it only for listening to events and revoking.</p>"},{"location":"apis/smart-contracts/WNat/#fn_receive_undefined","title":"<code>receive</code>","text":"<p>Defined in <code>WNat</code> (Docs, Source).</p> <pre><code>receive(\n) external payable;\n</code></pre> <p>A proxy for the <code>deposit</code> method.</p>"},{"location":"apis/smart-contracts/WNat/#fn_revokedelegationat_bbd6fbf8","title":"<code>revokeDelegationAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function revokeDelegationAt(\n    address _who,\n    uint256 _blockNumber\n) public;\n</code></pre> <p>Revoke all delegation from sender to <code>_who</code> at given block. Only affects the reads via <code>votePowerOfAtCached</code> in the block <code>_blockNumber</code>. Block <code>_blockNumber</code> must be in the past. This method should be used only to prevent rogue <code>delegate</code> voting in the current voting block. To stop delegating use <code>delegate</code> / <code>delegateExplicit</code> with value of 0 or <code>undelegateAll</code> / <code>undelegateAllExplicit</code>.</p> Parameters Type Description <code>_who</code> <code>address</code> Address of the delegatee. <code>_blockNumber</code> <code>uint256</code> The block number at which to revoke delegation.."},{"location":"apis/smart-contracts/WNat/#fn_setcleanercontract_f6a494af","title":"<code>setCleanerContract</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function setCleanerContract(\n    address _cleanerContract\n) external;\n</code></pre> <p>Set the contract that is allowed to call history cleaning methods.</p> Parameters Type Description <code>_cleanerContract</code> <code>address</code> Address of the cleanup contract. Usually this will be an instance of <code>CleanupBlockNumberManager</code>."},{"location":"apis/smart-contracts/WNat/#fn_setcleanupblocknumber_13de97f5","title":"<code>setCleanupBlockNumber</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function setCleanupBlockNumber(\n    uint256 _blockNumber\n) external;\n</code></pre> <p>Set the cleanup block number. Historic data for the blocks before <code>cleanupBlockNumber</code> can be erased. History before that block should never be used since it can be inconsistent. In particular, cleanup block number must be lower than the current vote power block.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The new cleanup block number."},{"location":"apis/smart-contracts/WNat/#fn_setcleanupblocknumbermanager_7f4fcaa9","title":"<code>setCleanupBlockNumberManager</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function setCleanupBlockNumberManager(\n    address _cleanupBlockNumberManager\n) external;\n</code></pre> <p>Set the contract that is allowed to set <code>cleanupBlockNumber</code>. Usually this will be an instance of <code>CleanupBlockNumberManager</code>.</p>"},{"location":"apis/smart-contracts/WNat/#fn_setgovernancevotepower_9ca2231a","title":"<code>setGovernanceVotePower</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function setGovernanceVotePower(\n    contract IIGovernanceVotePower _governanceVotePower\n) external;\n</code></pre> <p>Sets new <code>governance</code> vote power contract that allows token owners to participate in <code>governance</code> voting and <code>delegate</code> <code>governance</code> vote power.</p>"},{"location":"apis/smart-contracts/WNat/#fn_setreadvpcontract_31d12a16","title":"<code>setReadVpContract</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function setReadVpContract(\n    contract IIVPContract _vpContract\n) external;\n</code></pre> <p>Call from <code>governance</code> to set read VpContract on token, e.g. vpToken.<code>setReadVpContract</code>(new <code>VPContract</code>(vpToken)).</p> <p>Read <code>VPContract</code> must be set before any of the <code>VPToken</code> delegation or vote power reading methods are called, otherwise they will revert.</p> <p>NOTE: If <code>readVpContract</code> differs from <code>writeVpContract</code> all reads will be \"frozen\" and will not reflect changes (not even revokes; they may or may not reflect balance transfers).</p> Parameters Type Description <code>_vpContract</code> <code>contract IIVPContract</code> Read vote power contract to be used by this token."},{"location":"apis/smart-contracts/WNat/#fn_setwritevpcontract_755d10a4","title":"<code>setWriteVpContract</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function setWriteVpContract(\n    contract IIVPContract _vpContract\n) external;\n</code></pre> <p>Call from <code>governance</code> to set write VpContract on token, e.g. vpToken.<code>setWriteVpContract</code>(new <code>VPContract</code>(vpToken)).</p> <p>Write <code>VPContract</code> must be set before any of the <code>VPToken</code> delegation modifying methods are called, otherwise they will revert.</p> Parameters Type Description <code>_vpContract</code> <code>contract IIVPContract</code> Write vote power contract to be used by this token."},{"location":"apis/smart-contracts/WNat/#fn_switchtoproductionmode_f5a98383","title":"<code>switchToProductionMode</code>","text":"<p>Defined in <code>GovernedBase</code> (Docs, Source).</p> <pre><code>function switchToProductionMode(\n) external;\n</code></pre> <p>Enter the production mode after all the initial <code>governance</code> settings have been set. This enables timelocks and the <code>governance</code> can be obtained afterward by calling <code>governanceSettings</code>.getGovernanceAddress(). Emits <code>GovernedProductionModeEntered</code>.</p>"},{"location":"apis/smart-contracts/WNat/#fn_symbol_95d89b41","title":"<code>symbol</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function symbol(\n) public view returns (\n    string);\n</code></pre> <p>Returns the <code>symbol</code> of the token, usually a shorter version of the <code>name</code>.</p> <p>Should be compatible with ERC20 method.</p>"},{"location":"apis/smart-contracts/WNat/#fn_totalsupply_18160ddd","title":"<code>totalSupply</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function totalSupply(\n) external view returns (\n    uint256);\n</code></pre> <p>Returns the amount of tokens in existence.</p>"},{"location":"apis/smart-contracts/WNat/#fn_totalsupplyat_981b24d0","title":"<code>totalSupplyAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function totalSupplyAt(\n    uint256 _blockNumber\n) public view returns (\n    uint256);\n</code></pre> <p>Total amount of tokens at a specific <code>_blockNumber</code>.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The block number when the _totalSupply is queried Returns Type Description [0] <code>uint256</code>"},{"location":"apis/smart-contracts/WNat/#fn_totalsupplycachecleanup_43ea370b","title":"<code>totalSupplyCacheCleanup</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>function totalSupplyCacheCleanup(\n    uint256 _blockNumber\n) external returns (\n    uint256);\n</code></pre> <p>Delete total supply cache entry that expired (i.e. is before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> the block number for which total supply value was cached Returns Type Description [0] <code>uint256</code> the number of cache entries deleted (always 0 or 1)"},{"location":"apis/smart-contracts/WNat/#fn_totalsupplyhistorycleanup_f62f8f3a","title":"<code>totalSupplyHistoryCleanup</code>","text":"<p>Defined in <code>CheckPointable</code> (Docs, Source).</p> <pre><code>function totalSupplyHistoryCleanup(\n    uint256 _count\n) external returns (\n    uint256);\n</code></pre> <p>Delete total supply checkpoints that expired (i.e. are before <code>cleanupBlockNumber</code>). Method can only be called from the <code>cleanerContract</code> (which may be a proxy to external cleaners).</p> Parameters Type Description <code>_count</code> <code>uint256</code> maximum number of checkpoints to delete Returns Type Description [0] <code>uint256</code> the number of checkpoints deleted"},{"location":"apis/smart-contracts/WNat/#fn_totalvotepower_f5f3d4f7","title":"<code>totalVotePower</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function totalVotePower(\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current total vote power.</p> Returns Type Description [0] <code>uint256</code> The current total vote power (sum of all accounts' vote power)."},{"location":"apis/smart-contracts/WNat/#fn_totalvotepowerat_3e5aa26a","title":"<code>totalVotePowerAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function totalVotePowerAt(\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the total vote power at block <code>_blockNumber</code>.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The total vote power at the queried block (sum of all accounts' vote powers)."},{"location":"apis/smart-contracts/WNat/#fn_totalvotepoweratcached_caeb942b","title":"<code>totalVotePowerAtCached</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function totalVotePowerAtCached(\n    uint256 _blockNumber\n) public returns (\n    uint256);\n</code></pre> <p>Get the total vote power at block <code>_blockNumber</code> using cache.   It tries to read the cached value and if it is not found, reads the actual value and stores it in the cache.   Can only be used if <code>_blockNumber</code> is in the past, otherwise reverts.</p> Parameters Type Description <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The total vote power at the queried block (sum of all accounts' vote powers)."},{"location":"apis/smart-contracts/WNat/#fn_transfer_a9059cbb","title":"<code>transfer</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function transfer(\n    address recipient,\n    uint256 amount\n) external returns (\n    bool);\n</code></pre> <p>Moves <code>amount</code> tokens from the caller's account to <code>recipient</code>.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>Emits a <code>Transfer</code> event.</p>"},{"location":"apis/smart-contracts/WNat/#fn_transferfrom_23b872dd","title":"<code>transferFrom</code>","text":"<p>Defined in <code>IERC20</code> (Source).</p> <pre><code>function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n) external returns (\n    bool);\n</code></pre> <p>Moves <code>amount</code> tokens from <code>sender</code> to <code>recipient</code> using the <code>allowance</code> mechanism. <code>amount</code> is then deducted from the caller's <code>allowance</code>.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>Emits a <code>Transfer</code> event.</p>"},{"location":"apis/smart-contracts/WNat/#fn_undelegateall_b302f393","title":"<code>undelegateAll</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function undelegateAll(\n) external;\n</code></pre> <p>Undelegate all voting power of <code>msg.sender</code>. This effectively revokes all previous delegations. Can only be used with percentage delegation. Does not reset delegation mode back to NOT SET.</p>"},{"location":"apis/smart-contracts/WNat/#fn_undelegateallexplicit_5d6d11eb","title":"<code>undelegateAllExplicit</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function undelegateAllExplicit(\n    address[] _delegateAddresses\n) external returns (\n    uint256 _remainingDelegation);\n</code></pre> <p>Undelegate all explicit vote power by amount of <code>msg.sender</code>. Can only be used with explicit delegation. Does not reset delegation mode back to NOT SET.</p> Parameters Type Description <code>_delegateAddresses</code> <code>address[]</code> Explicit delegation does not store delegatees' addresses,   so the caller must supply them. Returns Type Description <code>_remainingDelegation</code> <code>uint256</code> The amount still delegated (in case the list of delegates was incomplete)."},{"location":"apis/smart-contracts/WNat/#fn_undelegatedvotepowerof_d6aa0b77","title":"<code>undelegatedVotePowerOf</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function undelegatedVotePowerOf(\n    address _owner\n) external view returns (\n    uint256);\n</code></pre> <p>Compute the current undelegated vote power of the <code>_owner</code> account.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. Returns Type Description [0] <code>uint256</code> The unallocated vote power of <code>_owner</code>."},{"location":"apis/smart-contracts/WNat/#fn_undelegatedvotepowerofat_83035a82","title":"<code>undelegatedVotePowerOfAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function undelegatedVotePowerOfAt(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the undelegated vote power of the <code>_owner</code> account at a given block number.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The unallocated vote power of <code>_owner</code>."},{"location":"apis/smart-contracts/WNat/#fn_votepowerfromto_be0ca747","title":"<code>votePowerFromTo</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function votePowerFromTo(\n    address _from,\n    address _to\n) external view returns (\n    uint256);\n</code></pre> <p>Get current delegated vote power from delegator <code>_from</code> to delegatee <code>_to</code>.</p> Parameters Type Description <code>_from</code> <code>address</code> Address of delegator. <code>_to</code> <code>address</code> Address of delegatee. Returns Type Description [0] <code>uint256</code> votePower The delegated vote power."},{"location":"apis/smart-contracts/WNat/#fn_votepowerfromtoat_e64767aa","title":"<code>votePowerFromToAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function votePowerFromToAt(\n    address _from,\n    address _to,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get delegated vote power from delegator <code>_from</code> to delegatee <code>_to</code> at <code>_blockNumber</code>.</p> Parameters Type Description <code>_from</code> <code>address</code> Address of delegator. <code>_to</code> <code>address</code> Address of delegatee. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> The delegated vote power."},{"location":"apis/smart-contracts/WNat/#fn_votepowerof_142d1018","title":"<code>votePowerOf</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function votePowerOf(\n    address _owner\n) external view returns (\n    uint256);\n</code></pre> <p>Get the current vote power of <code>_owner</code>.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. Returns Type Description [0] <code>uint256</code> Current vote power of <code>_owner</code>."},{"location":"apis/smart-contracts/WNat/#fn_votepowerofat_92bfe6d8","title":"<code>votePowerOfAt</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function votePowerOfAt(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the vote power of <code>_owner</code> at block <code>_blockNumber</code></p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> Vote power of <code>_owner</code> at block number <code>_blockNumber</code>."},{"location":"apis/smart-contracts/WNat/#fn_votepowerofatcached_e587497e","title":"<code>votePowerOfAtCached</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function votePowerOfAtCached(\n    address _owner,\n    uint256 _blockNumber\n) public returns (\n    uint256);\n</code></pre> <p>Get the vote power of <code>_owner</code> at block <code>_blockNumber</code> using cache.   It tries to read the cached value and if it is not found, reads the actual value and stores it in the cache.   Can only be used if <code>_blockNumber</code> is in the past, otherwise reverts.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> Vote power of <code>_owner</code> at <code>_blockNumber</code>."},{"location":"apis/smart-contracts/WNat/#fn_votepowerofatignoringrevocation_04bb4e43","title":"<code>votePowerOfAtIgnoringRevocation</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function votePowerOfAtIgnoringRevocation(\n    address _owner,\n    uint256 _blockNumber\n) external view returns (\n    uint256);\n</code></pre> <p>Get the vote power of <code>_owner</code> at block <code>_blockNumber</code>, ignoring revocation information (and cache).</p> Parameters Type Description <code>_owner</code> <code>address</code> The address to query. <code>_blockNumber</code> <code>uint256</code> The block number to query. Returns Type Description [0] <code>uint256</code> Vote power of <code>_owner</code> at block number <code>_blockNumber</code>. Result doesn't change if vote power is revoked."},{"location":"apis/smart-contracts/WNat/#fn_withdraw_2e1a7d4d","title":"<code>withdraw</code>","text":"<p>Defined in <code>WNat</code> (Docs, Source).</p> <pre><code>function withdraw(\n    uint256 _amount\n) external;\n</code></pre> <p>Burns <code>_amount</code> of <code>WNAT</code> tokens from <code>msg.sender</code>'s <code>WNAT</code> balance and transfers the same amount of native tokens to <code>msg.sender</code>. This operation is commonly known as \"unwrapping\".</p> <p>Reverts if <code>_amount</code> is higher than <code>msg.sender</code>'s <code>WNAT</code> balance.</p> <p>Emits a <code>Withdrawal</code> event.</p> Parameters Type Description <code>_amount</code> <code>uint256</code> The amount to withdraw."},{"location":"apis/smart-contracts/WNat/#fn_withdrawfrom_9470b0bd","title":"<code>withdrawFrom</code>","text":"<p>Defined in <code>WNat</code> (Docs, Source).</p> <pre><code>function withdrawFrom(\n    address _owner,\n    uint256 _amount\n) external;\n</code></pre> <p>Burns <code>_amount</code> of <code>WNAT</code> tokens from <code>_owner</code>'s <code>WNAT</code> balance and transfers the same amount of native tokens to <code>msg.sender</code>. This operation is commonly known as \"unwrapping\".</p> <p><code>msg.sender</code> must have been authorized to <code>withdraw</code> from <code>_owner</code>'s account through ERC-20's <code>approve</code> mechanism.</p> <p>Reverts if <code>_amount</code> is higher than <code>_owners</code>'s <code>WNAT</code> balance or than <code>msg.sender</code>'s <code>allowance</code> over <code>_owner</code>'s tokens.</p> <p>Emits a <code>Withdrawal</code> event.</p> Parameters Type Description <code>_owner</code> <code>address</code> The address containing the tokens to withdraw. <code>_amount</code> <code>uint256</code> The amount to withdraw."},{"location":"apis/smart-contracts/WNat/#fn_writevotepowercontract_1fec092a","title":"<code>writeVotePowerContract</code>","text":"<p>Defined in <code>VPToken</code> (Docs, Source).</p> <pre><code>function writeVotePowerContract(\n) external view returns (\n    contract IVPContractEvents);\n</code></pre> <p>Returns <code>VPContract</code> event interface used for state-changing operations (non-view methods). The only non-view method that might be called on it is <code>revokeDelegationAt</code>.</p> <p><code>writeVotePowerContract</code> is almost always equal to <code>readVotePowerContract</code>, except during upgrade from one <code>VPContract</code> to a new version (which should happen rarely or never and will be announced beforehand). In the case of an upgrade, <code>writeVotePowerContract</code> is replaced first to establish delegations. After some period (e.g., after a reward epoch ends), <code>readVotePowerContract</code> is set equal to it.</p> <p>Do not call any methods on <code>VPContract</code> directly. State changing methods are forbidden from direct calls. All are exposed via <code>VPToken</code>. This is the reason that this method returns <code>IVPContractEvents</code> Use it only for listening to events, delegating, and revoking.</p>"},{"location":"dev/","title":"Developer Docs","text":"<p>Quick links</p> <ul> <li>Network Configuration</li> <li>Flare Contracts Addresses</li> <li>How to run a node</li> </ul> <p>All Flare networks are a fork of the Avalanche project, which runs the Ethereum Virtual Machine. Therefore, all Ethereum contracts and tools work on Flare, Songbird and Coston.</p> <p>All Flare networks are layer-1 networks, and run independently of both Avalanche and Ethereum.</p> <p>You can interact with the Flare networks using wallets, block explorers and the most common blockchain development environments.</p> <p>As an example, all Flare networks support NFTs and many have already been created on Songbird. The block explorer also supports displaying NFTs.</p> <p>Once you have set up your development environment, you can start with the Accessing the Network tutorials.</p>"},{"location":"dev/#open-source-repositories","title":"Open-Source Repositories","text":"<p>These are Flare's main source repositories, both on GitHub and GitLab.</p> <ul> <li>Validator node</li> <li>Smart contracts</li> </ul>"},{"location":"dev/#topics","title":"Topics","text":"<ul> <li>Getting Started</li> <li>Tutorials</li> <li>Reference Guides</li> <li>External Learning Resources</li> <li>Tools and Projects</li> </ul>"},{"location":"dev/external-resources/","title":"External Learning Resources","text":"<p>Curated list of resources you can use to extend your knowledge of the Flare network.</p>"},{"location":"dev/external-resources/#tutorials","title":"Tutorials","text":"<ul> <li>Filip Koprivec's Flare Tutorials on Medium</li> <li>Uttam Singh's Using the Flare Time Series Oracle with Foundry</li> <li>Etherspot Prime on Flare</li> </ul>"},{"location":"dev/external-resources/#videos","title":"Videos","text":"<ul> <li>Tim Rowley's Explainer Videos on YouTube</li> <li>FTSO (Flare Time Series Oracle) | Learn how to Query Prices on Flare</li> <li>Introduction to Etherspot's TransactionKit on Flare</li> </ul>"},{"location":"dev/tools/","title":"Tooling","text":"<p>The following tools already support the Flare network.</p>"},{"location":"dev/tools/#api-providers","title":"API Providers","text":"<p>These companies provide API services like RPC endpoints, for example. Unlike Flare's public RPC endpoints, paid services are typically not rate-limited.</p> <ul> <li>Flare API Portal</li> <li>Ankr</li> <li>NOWNodes</li> </ul>"},{"location":"dev/tools/#identity-and-account-abstraction","title":"Identity and Account Abstraction","text":"<ul> <li>web3auth</li> </ul>"},{"location":"dev/tools/#indexing-and-querying","title":"Indexing and Querying","text":"<p>Blockchains typically store the history of all transactions but not the latest, consolidated state of individual accounts. The companies below provide fast access to this information</p> <ul> <li>Ankr</li> <li>Covalent</li> <li>SubQuery</li> <li>Subsquid</li> </ul>"},{"location":"dev/tools/#monitoring-tools","title":"Monitoring Tools","text":"<p>These tools report information about Flare networks:</p> <ul> <li>Flare Builders</li> <li>FlareMetrics</li> <li>Validators, presented by Towo Labs</li> <li>SolidiFi</li> </ul>"},{"location":"dev/tools/#storage","title":"Storage","text":"<p>Storing large amounts of data on-chain is typically very expensive. These are some decentralized storage alternatives.</p> <ul> <li>Filecoin</li> <li>IPFS</li> <li>Crust Network</li> <li>Pinata</li> <li>Lighthouse</li> <li>Arweave</li> </ul>"},{"location":"dev/tools/#wallets","title":"Wallets","text":"<p>Please see the Wallet user guides for a list of wallets currently supporting the Flare network.</p>"},{"location":"dev/getting-started/","title":"Getting Started","text":"<p>The following guides provide information to quickly start developing on the Flare networks.</p>"},{"location":"dev/getting-started/#guides","title":"Guides","text":"<ul> <li>Setting Up Your Environment</li> <li>Retrieving Contract Addresses</li> </ul>"},{"location":"dev/getting-started/contract-addresses/","title":"Retrieving Contract Addresses","text":"<p>Warning</p> <p>Developers should never rely on contract addresses gathered from off-chain sources like direct messages, social media, or even websites, as these addresses could easily lead to malicious contracts.</p> <p>For this reason, this documentation does not provide any contract address except for the single entry point described below. The only secure way to retrieve contract addresses is from the blockchain itself.</p> <p>As a convenience, though, Flare's smart contract repository contains the latest deployment address for all Flare's smart contracts. These addresses can be used to speed up development, but should not be used in production.</p> <p>To emphasize: Applications are strongly encouraged to retrieve any contract address they need directly from the blockchain and not have addresses hard-coded into the source code, except for the single entry point given in this page.</p>"},{"location":"dev/getting-started/contract-addresses/#retrieval-from-blockchain","title":"Retrieval from Blockchain","text":"<p>All of Flare's smart contract addresses can be retrieved from the <code>FlareContractRegistry</code> contract. This is the only contract address given in this documentation.</p> <code>FlareContractRegistry</code> <pre><code>0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019</code></pre> <p>This contract is available at the same address in all Flare networks: Flare, Songbird, Coston and Coston2.</p> <p>Copy the above address into the Block Explorer to see the available contract's methods.</p> <p>You can retrieve the current address on the blockchain of any Flare smart contract from its name by using these methods, for example:</p> <pre><code>function getContractAddressByName(\n    string calldata _name\n) external view returns (\n    address);\n\n\nfunction getContractAddressesByName(\n    string[] calldata _names\n) external view returns (\n    address[] memory);\n</code></pre> <p>The name search is case-sensitive, so you should use the proper capitalization. For example:</p> <ul> <li><code>WNat</code></li> <li><code>FtsoRewardManager</code></li> <li><code>PriceSubmitter</code></li> </ul> <p>Applications can also retrieve all smart contract names and addresses at once using:</p> <pre><code>function getAllContracts(\n) external view returns(\n    string[] memory _names,\n    address[] memory _addresses);\n</code></pre> <p>Retrieve current list</p>"},{"location":"dev/getting-started/contract-addresses/#retrieval-from-source-code","title":"Retrieval from Source Code","text":"<p>The Flare Smart Contracts repository contains an autogenerated JSON file listing the latest deployed addresses of all Flare contracts on each network.</p> <p>You can find this file in the <code>deployment/deploys</code> folder, and parse it to retrieve the addresses of any Flare contract.</p> <p>Warning</p> <p>As stated at the beginning, applications should NOT have Flare contract addresses in their source code.</p> <p>Instead, applications are strongly encouraged to retrieve any contract address they need directly from the blockchain as described above.</p> Branch JSON file Flare <code>flare_network_deployed_code</code> flare.json Songbird <code>songbird_network_deployed_code</code> songbird.json Coston <code>coston_network_deployed_code</code> coston.json Coston2 <code>coston2_network_deployed_code</code> coston2.json"},{"location":"dev/getting-started/setup/","title":"Setting Up Your Environment","text":"<p>The following guides provide information to quickly set up a smart contract development environment.</p>"},{"location":"dev/getting-started/setup/#guides","title":"Guides","text":"<ul> <li>Using Remix</li> <li>Using Hardhat</li> <li>Using Truffle</li> <li>Using Foundry</li> </ul>"},{"location":"dev/getting-started/setup/foundry/","title":"Setting Up Your Environment Using Foundry","text":"<p>Foundry is a fast, portable and modular testing and deployment tool for developing EVM smart contracts. Tests are written in Solidity to keep the workflow consistent with smart contract development and testing before deployments. Foundry itself is written in Rust.</p> <p>This article, partially based on the Foundry documentation, shows how to set up Foundry and use it to build and deploy smart contracts on Flare.</p>"},{"location":"dev/getting-started/setup/foundry/#guide","title":"Guide","text":""},{"location":"dev/getting-started/setup/foundry/#1-set-up-the-environment","title":"1. Set up the Environment","text":"<p>Follow the instructions for your operating system in the Foundry's Installation guide.</p>"},{"location":"dev/getting-started/setup/foundry/#2-create-a-foundry-project","title":"2. Create a Foundry Project","text":"<p>Foundry can quick-start your development by providing a sample project:</p> <pre><code>forge init hello_foundry\n</code></pre> <p>This creates a new directory <code>hello_foundry</code> from the default template which should look something like this:</p> <p> </p> Foundry project structure."},{"location":"dev/getting-started/setup/foundry/#3-build-the-contract","title":"3. Build the Contract","text":"<p>To build the <code>Counter.sol</code> contract in the sample project run:</p> <pre><code>cd hello_foundry\nforge build\n</code></pre> <p>When done, it should print <code>Compiler run successful</code>.</p> <p>You will notice that two new directories have been created, <code>out</code> and <code>cache</code>:</p> <p> </p> Foundry project after build. <p>The <code>out</code> directory contains your contract artifact, such as the ABI, while the <code>cache</code> is used by forge to only recompile what is necessary.</p>"},{"location":"dev/getting-started/setup/foundry/#4-test-the-contract","title":"4. Test the Contract","text":"<p>In the <code>test</code> folder you should find a ready-made test file that verifies the contract works as expected.</p> <p>To run tests with Foundry, you just need to run:</p> <pre><code>forge test\n</code></pre> <p>When finished, it should print something similar to <code>Test result: ok. 2 passed; 0 failed; finished in 24.43ms</code>.</p> <p>Info</p> <p>Learn more about Advanced Testing using Foundry.</p>"},{"location":"dev/getting-started/setup/foundry/#5-deploy-the-contract","title":"5. Deploy the Contract","text":"<p>Forge can deploy only one contract at a time to a given network. To do so, you must provide the URL of the RPC node to access the network, and the private key of the account that will deploy the contract.</p> <p>The URL can be stored in an environment variable named <code>FOUNDRY_ETH_RPC_URL)</code> so you do not need to supply it every time.</p> <p>Warning</p> <p>You are going to deploy the contract on the Coston 2 network. Make sure you have enough <code>C2FLR</code> in the account that will deploy the contract to pay the gas fees!</p> <p>You can add <code>C2FLR</code> to any account using the Coston 2 Faucet.</p> <p>The general Foundry command to deploy a contract is:</p> <pre><code>forge create --rpc-url &lt;your_rpc_url&gt; \\\n  --private-key &lt;your_private_key&gt; \\\n  &lt;contract_file&gt;:&lt;contract_name&gt;\n</code></pre> <p>Since Solidity files may contain multiple contracts, the <code>:&lt;contract_name&gt;</code> parameter specifies which contract to deploy from the <code>&lt;contract_file&gt;</code> source file. Learn more about Deploying and Verifying Smart Contracts using Foundry.</p> <p>To deploy the sample <code>Counter</code> contract to Flare's Coston 2 Network, run:</p> <pre><code>forge create --rpc-url https://coston2-api.flare.network/ext/bc/C/rpc \\\n  --private-key d8936f6eae35c73a14ea7c1aabb8d068e16889a7f516c8abc482ba4e1489f4cd \\\n  src/Counter.sol:Counter\n</code></pre> <p>Using the private key for your account.</p> <p>Execution should look similar to this:</p> <p> </p> Foundry project deployment. <p>You can check the status of the contract by copy and pasting the <code>Deployed to:</code> address into the Coston 2 Block Explorer.</p> <p>Info</p> <p>Learn more about Deploying and Verifying Smart Contracts using Foundry!</p>"},{"location":"dev/getting-started/setup/hardhat/","title":"Setting Up Your Environment Using Hardhat","text":"<p>Hardhat is an environment developers use to test, compile, deploy and debug dapps based on any blockchain compatible Ethereum's EVM. Hardhat is a flexible and extensible task runner that helps you manage and automate the recurring tasks inherent to developing smart contracts and dapps.</p> <p>This article, partially based on the Hardhat documentation shows you how to set up Hardhat and use it to build, test and deploy smart contracts on Flare.</p>"},{"location":"dev/getting-started/setup/hardhat/#guide","title":"Guide","text":""},{"location":"dev/getting-started/setup/hardhat/#1-set-up-the-environment","title":"1. Set up the Environment","text":"<p>Warning</p> <p>If you are using Windows, Hardhat strongly recommends to use WSL 2.</p> <p>Install the following dependencies:</p> <ul> <li>NodeJSv16+ LTS and npm Package Installer.</li> </ul> <p>Tip</p> <p>Check the Official Guide by Hardhat if you have issues installing this package.</p> <p>Once the above dependencies are installed, create an npm empty project by running the following commands in a terminal:</p> <pre><code>mkdir flare-tutorial\ncd flare-tutorial\nnpm init\n</code></pre> <p>Press Enter on each of the prompts.</p> <p>Finally, add Hardhat and a few dependencies to the project, since you will use them in this tutorial.</p> <pre><code>npm install --save-dev \\\n  hardhat \\\n  dotenv\n</code></pre>"},{"location":"dev/getting-started/setup/hardhat/#2-create-a-hardhat-project","title":"2. Create a Hardhat Project","text":"<p>Hardhat can quick-start your development by providing a sample project. Just run:</p> <pre><code>npx hardhat init\n</code></pre> <p>You should see the following prompt:</p> <p> </p> Hardhat project creation prompt. <p>Choose the <code>Create a JavaScript project</code> with the Up and Down keys, and Press Enter. Then press Y for rest of the prompts.</p> <p>When done, it should print <code>Project created</code>.</p> <p>Tip</p> <p>If you use the Windows command prompt, Hardhat might warn you that you need to install some dependencies manually. Do it using the command that the Hardhat setup guide provides.</p> <p>If you take a look in the <code>contracts</code> folder, you should find a sample source file called <code>Lock.sol</code>. It is a Solidity smart contract implementing a digital lock, where users can only withdraw funds after a given period of time:</p> <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\n\ncontract Lock {\n    uint public unlockTime;\n    address payable public owner;\n\n    event Withdrawal(uint amount, uint when);\n\n    constructor(uint _unlockTime) payable {\n        require(\n            block.timestamp &lt; _unlockTime,\n            \"Unlock time should be in the future\"\n        );\n\n        unlockTime = _unlockTime;\n        owner = payable(msg.sender);\n    }\n\n    function withdraw() public {\n        // Uncomment this line, and the import of \"hardhat/console.sol\", to print a log in your terminal\n        // console.log(\"Unlock time is %o and block timestamp is %o\", unlockTime, block.timestamp);\n\n        require(block.timestamp &gt;= unlockTime, \"You can't withdraw yet\");\n        require(msg.sender == owner, \"You aren't the owner\");\n\n        emit Withdrawal(address(this).balance, block.timestamp);\n\n        owner.transfer(address(this).balance);\n    }\n}\n</code></pre>"},{"location":"dev/getting-started/setup/hardhat/#3-compile-the-contracts","title":"3. Compile the Contracts","text":"<p>To compile the sample project, run:</p> <pre><code>npx hardhat compile\n</code></pre> <p>Upon successful compilation it will print <code>Compiled 1 Solidity file successfully</code>.</p>"},{"location":"dev/getting-started/setup/hardhat/#4-configure-the-project","title":"4. Configure the Project","text":"<p>In order to be deployed on any of the Flare networks, the project needs to be configured. Edit the <code>hardhat.config.js</code> file and replace its contents with the following:</p> <pre><code>require('dotenv').config();\nrequire(\"@nomicfoundation/hardhat-toolbox\");\n\nmodule.exports = {\n  solidity: \"0.8.17\",\n  networks: {\n    hardhat: {\n    },\n    coston: {\n      url: \"https://coston-api.flare.network/ext/bc/C/rpc\",\n      accounts: [process.env.PRIVATE_KEY],\n      chainId: 16\n    },\n    songbird: {\n      url: \"https://songbird-api.flare.network/ext/bc/C/rpc\",\n      accounts: [process.env.PRIVATE_KEY],\n      chainId: 19\n    },\n    coston2: {\n      url: \"https://coston2-api.flare.network/ext/bc/C/rpc\",\n      accounts: [process.env.PRIVATE_KEY],\n      chainId: 114,\n    },\n    flare: {\n      url: \"https://flare-api.flare.network/ext/bc/C/rpc\",\n      accounts: [process.env.PRIVATE_KEY],\n      chainId: 14,\n    }\n  },\n};\n</code></pre> <p>Then, create a file called <code>.env</code> at the root of you project (where the <code>hardhat.config.js</code> file resides) to store the private key for the account to use for testing. <code>.env</code> files are useful to store local information which should not be committed into the source repository. In this tutorial, you need to store your test account's private key in this format:</p> <pre><code>PRIVATE_KEY=\"0000000000000000000000000000000000000000000000000000000000000000\"\n</code></pre> <p>Warning</p> <p>Make sure you never upload your <code>.env</code> file to a remote repository.</p> <p>For this reason, the <code>.gitignore</code> file that Hardhat created for you already ignores <code>.env</code> files.</p>"},{"location":"dev/getting-started/setup/hardhat/#5-test-the-contract","title":"5. Test the Contract","text":"<p>In the <code>test</code> folder you should find a ready-made test file that verifies the contract works as expected.</p> <p>To run tests with Hardhat, you just need to run:</p> <pre><code>npx hardhat test\n</code></pre> <p>You should get:</p> <p> </p> Lock contract test results."},{"location":"dev/getting-started/setup/hardhat/#6-deploy-the-contract","title":"6. Deploy the Contract","text":"<p>Finally, you will deploy the contract to Flare's test network, Coston2, using a Hardhat script from the <code>scripts</code> folder.</p> <p>Run this command at the root of the project:</p> <pre><code>npx hardhat run scripts/deploy.js --network coston2\n</code></pre> <p>You should get an output similar to:</p> <pre><code>Lock with 1 ETH and unlock timestamp 1705592309 deployed to 0xdC7781FA9fA7e2d0313cd0229a5080B4e30663a5\n</code></pre> <p>The last part is the address where the contract has been deployed. You can check the status of the contract by copying and pasting this address in the Block Explorer</p>"},{"location":"dev/getting-started/setup/remix/","title":"Setting Up Your Environment Using Remix","text":"<p>The Remix IDE is a powerful, open-source tool that helps you write Solidity smart contracts straight from the browser, without requiring any download, account creation, or login.</p> <p>This article shows you how to deploy a Hello World contract to the Flare blockchain using the Remix IDE and the MetaMask wallet.</p>"},{"location":"dev/getting-started/setup/remix/#guide","title":"Guide","text":""},{"location":"dev/getting-started/setup/remix/#1-create-a-new-file","title":"1. Create a New File","text":"<ul> <li>Visit the Remix IDE and click the New File button.</li> <li>Name it <code>HelloWorld.sol</code>.</li> <li>Drag and drop it to the contracts folder.</li> </ul> New file in the Remix IDE."},{"location":"dev/getting-started/setup/remix/#2-write-your-contract","title":"2. Write Your Contract","text":"<p>Copy and paste the smart contract code provided below into the newly created <code>HelloWorld.sol</code> file.</p> <pre><code>// SPDX-License-Identifier: MIT\n\n// Specifies the version of Solidity, using semantic versioning.\npragma solidity 0.8.17;\n\n// Defines a contract named `HelloWorld`\ncontract HelloWorld {\n\n   // Declares a state variable `message` of type `string`.\n   string public message;\n\n   // Constructors are used to initialize the contract's data.\n   constructor(string memory initMessage) {\n      // Accepts a string argument `initMessage`.\n      message = initMessage;\n   }\n\n   // A public function that accepts a string argument.\n   function update(string memory newMessage) public {\n      message = newMessage;\n   }\n}\n</code></pre>"},{"location":"dev/getting-started/setup/remix/#3-compile-your-contract","title":"3. Compile Your Contract","text":"<ul> <li>Go to the Solidity Compiler tab (on the left), and select compiler version <code>0.8.17</code>.</li> <li>Now, click the Compile HelloWorld.sol button.</li> </ul> <p>After successful compilation, it will show a Green tick mark on the Compiler tab button.</p> <p> </p> Compilation successful."},{"location":"dev/getting-started/setup/remix/#4-deploying-on-flare-testnet","title":"4. Deploying on Flare Testnet","text":"<p>You will now deploy the smart contract on the Coston2 network, Flare's test network.</p> <p>When a smart contract is deployed on Flare's main network, it not only costs money (such as gas fees), but it also becomes immutable and cannot be modified. Therefore, deploying your smart contracts first on the test network is highly recommended.</p> <p>Tip</p> <p>Before jumping onto Remix Deployment:</p> <ul> <li>Make sure that you have added and selected the Coston2 test network to your MetaMask Wallet.   The MetaMask Wallet guide shows how to do it.   Use the values for Coston2 that you will find in the Network Configurations page.</li> <li>Ensure that you have enough Coston2 native tokens <code>$C2FLR</code> to pay for gas.   Visit the Coston2 Faucet to request some <code>$C2FLR</code>.</li> </ul> <ul> <li>Go to the Deploy &amp; Run Transactions tab (the last one) and select Injected Provider - Metamask from the ENVIRONMENT dropdown.   Accept the connection request received in MetaMask if necessary.</li> </ul> <p> </p> Environment selection on Remix. <ul> <li>Click the Deploy button and confirm the CONTRACT DEPLOYMENT transaction in MetaMask.</li> </ul> <p> </p> Contract deployment transaction. <p>Note</p> <p>The process to deploy your contract on the Flare main network is the same as above. You only have to select Flare Network on MetaMask and use <code>$FLR</code> tokens.</p>"},{"location":"dev/getting-started/setup/remix/#5-interact-with-the-contract","title":"5. Interact with the Contract","text":"<p>You can now interact with the contract to verify that it is working as intended.</p> <ul> <li>In the Deployed Contracts section at the bottom of the left column, expand the <code>HELLOWORLD</code> contract to see its methods and data:<ul> <li><code>update</code> method.</li> <li><code>message</code> public variable.</li> </ul> </li> <li>Type a message in the box next to the update button and click the button.</li> <li>Confirm the deployment transaction in MetaMask.</li> <li>Check that the contract has been updated by clicking the message button and verifying you get back the message you typed before.</li> </ul> <p> </p> Interact with the contract"},{"location":"dev/getting-started/setup/truffle/","title":"Setting Up Your Environment Using Truffle","text":"<p>Truffle is a blockchain development environment, which you can use to create and test smart contracts by leveraging the Ethereum Virtual Machine (EVM), aiming to make life as a developer easier.</p> <p>This article shows you how to set up Truffle and use it to build and deploy a smart contract on the Flare network.</p>"},{"location":"dev/getting-started/setup/truffle/#guide","title":"Guide","text":""},{"location":"dev/getting-started/setup/truffle/#1-set-up-the-environment","title":"1. Set up the Environment","text":"<p>Install the following dependencies:</p> <ul> <li>NodeJSv12+ LTS and npm/Yarn Package Installer.</li> </ul> <p>Once the above dependencies are installed, install Truffle:</p> <pre><code>npm install -g truffle\n</code></pre> <p>To verify that Truffle is installed properly, type <code>truffle version</code> into the terminal.</p>"},{"location":"dev/getting-started/setup/truffle/#2-create-a-truffle-project","title":"2. Create a Truffle Project","text":"<p>In this article you will use one of Truffle's boilerplate projects which you can find on the Truffle Boxes page. MetaCoin box is an example of a completed coin-like contract.</p> <p>Create a new directory for this Truffle project by running:</p> <pre><code>mkdir flare-truffle-tutorial\ncd flare-truffle-tutorial\n</code></pre> <p>Then install the <code>MetaCoin</code> box:</p> <pre><code>truffle unbox metacoin\n</code></pre> <p>Once this operation is complete, you should have a project structure with the following items:</p> <p> </p> Truffle Project structure. <p>Finally, install the following dependencies which will be needed to deploy contracts:</p> <pre><code>npm i @truffle/hdwallet-provider dotenv\n</code></pre>"},{"location":"dev/getting-started/setup/truffle/#3-compile-the-contract","title":"3. Compile the Contract","text":"<p>In the <code>contracts</code> folder you should find two sample source files called <code>MetaCoin.sol</code> and <code>ConvertLib.sol</code>.</p> <p>To compile them, simply run:</p> <pre><code>truffle compile\n</code></pre> <p>Upon successful compilation, you should see the following output:</p> <p> </p> Truffle compilation output."},{"location":"dev/getting-started/setup/truffle/#4-test-the-contract","title":"4. Test the Contract","text":"<p>In the <code>test</code> folder you should find examples for testing your smart contracts in both JavaScript and Solidity that verify the contracts work as expected.</p> <p>To run tests:</p> <pre><code>truffle test\n</code></pre> <p>When successful, the output should look like this:</p> <p> </p> Truffle test output."},{"location":"dev/getting-started/setup/truffle/#5-configure-the-project","title":"5. Configure the Project","text":"<p>In order to be deployed on any of the Flare networks, the project needs to be configured. Edit the <code>truffle-config.js</code> file and replace its contents with the following:</p> <pre><code>const HDWalletProvider = require('@truffle/hdwallet-provider');\nrequire('dotenv').config();\nconst fs = require('fs');\n\nmodule.exports = {\n\n  networks: {\n    development: {\n      host: \"127.0.0.1\",     // Localhost (default: none)\n      port: 8545,            // Standard Ethereum port (default: none)\n      network_id: \"*\",       // Any network (default: none)\n    },\n    flare: {\n      provider: () =&gt; new HDWalletProvider(process.env.PRIVATE_KEY, `https://flare-api.flare.network/ext/bc/C/rpc`),\n      network_id: 14,\n      timeoutBlocks: 200,\n      skipDryRun: true\n    },\n    coston2: {\n      provider: () =&gt; new HDWalletProvider(process.env.PRIVATE_KEY, `https://coston2-api.flare.network/ext/bc/C/rpc`),\n      network_id: 114,\n      timeoutBlocks: 200,\n      skipDryRun: true\n    },\n\n  },\n\n  // Set default mocha options here, use special reporters etc.\n  mocha: {\n    // timeout: 100000\n  },\n\n  // Configure your compilers\n  compilers: {\n    solc: {\n      version: \"0.8.13\",      // Fetch exact version from solc-bin\n    }\n  }\n};\n</code></pre> <p>Then, create a file called <code>.env</code> at the root of you project (where the <code>truffle-config.js</code> file resides) to store the private key for the account to use for testing.</p> <pre><code>PRIVATE_KEY=\"d8936f6eae35c73a14ea7c1aabb8d068e16889a7f516c8abc482ba4e1489f4cd\"\n</code></pre> <p><code>.env</code> files are useful to store local information which should not be committed into the source repository.</p> <p>Warning</p> <p>Make sure you never upload your <code>.env</code> file to a remote repository.</p> <p>For this reason, the <code>.gitignore</code> file that Truffle created for you already ignores <code>.env</code> files.</p>"},{"location":"dev/getting-started/setup/truffle/#6-deploy-the-contract","title":"6. Deploy the Contract","text":"<p>Warning</p> <p>You are going to deploy the contract on the Coston 2 network. Make sure you have enough <code>C2FLR</code> in the account that will deploy the contract to pay the gas fees!</p> <p>You can add <code>C2FLR</code> to any account using the Coston 2 Faucet.</p> <p>Run this command in the root folder of the project:</p> <pre><code>truffle migrate --network coston2\n</code></pre> <p>You should get an output similar to:</p> <p> </p> Truffle deployment output. <p>You can check the status of the contract by copy and pasting the <code>contract address:</code> in the Block Explorer.</p>"},{"location":"dev/reference/","title":"Reference Guides","text":"<p>The following guides provide in-depth information about the Flare networks and the different smart contracts APIs.</p>"},{"location":"dev/reference/#guides","title":"Guides","text":"<ul> <li>Automatic Claiming</li> <li>Block Explorers and Indexers</li> <li>FTSO</li> <li>Network Configuration</li> <li>Personal Delegation Accounts</li> <li>The FlareDrop</li> <li>Wallets</li> </ul>"},{"location":"dev/reference/automatic-claiming/","title":"Automatic Claiming","text":"<p>Users who do not want to claim rewards themselves can enlist executors to claim on their behalf. Executors can then initiate the claiming process, and rewards are sent directly to the user's account.</p>"},{"location":"dev/reference/automatic-claiming/#introduction","title":"Introduction","text":"<p>Building an executor requires two parts:</p> <ul> <li>An executor bot that periodically claims on behalf of the users.</li> <li>An app that allows users to select the executor, such as the Flare Portal, which is free to use.</li> </ul> <p>This page contains the following information:</p> <ul> <li>The Required Contracts section briefly lists the smart contracts related to executor operation.</li> <li>The User Operations section shows how to perform the operations required in a user-facing application, such as setting an executor.</li> <li>The Executor Operations section shows how to perform the operations required by an executor bot, such as registering as an executor.</li> <li>The User and Executor Reports section shows how to access information useful for performing user and executor functions.</li> </ul>"},{"location":"dev/reference/automatic-claiming/#required-contracts","title":"Required Contracts","text":"<p>Setting up automatic claiming requires interacting with these contracts:</p> <ul> <li><code>ClaimSetupManager</code> (CSM).</li> <li><code>FTSORewardManager</code> (FTSO).</li> </ul> <p>To find the addresses of these contracts, see the Contract Addresses page.</p>"},{"location":"dev/reference/automatic-claiming/#user-operations","title":"User Operations","text":"<p>This section shows how to perform operations required to enable autoclaiming. The main step is to set the executor that will perform the claiming for the user who has accrued rewards. Then other operations are explained, such as changing the executor and disabling automatic claiming.</p>"},{"location":"dev/reference/automatic-claiming/#setting-claim-executors","title":"Setting Claim Executors","text":"<p>There are two ways to set up automatic claiming: Manual and Registered.</p>"},{"location":"dev/reference/automatic-claiming/#manual-claiming","title":"Manual Claiming","text":"<p>With Manual Claiming, rewards are claimed on-chain, but any agreement between users and executors happens off-chain. Fees are not paid automatically.</p> <p>To set one or more executors to claim rewards for a user:</p> <ol> <li> <p>Set a specific executor by calling <code>CSM.setClaimExecutors()</code> and providing the executor's address.</p> <p>This method must be called from the user's account, since they are the only ones that can authorize claiming on their behalf.</p> <p>This function removes all previously set executors and replaces them with the new set.</p> </li> </ol>"},{"location":"dev/reference/automatic-claiming/#registered-claiming","title":"Registered Claiming","text":"<p>With Registered Claiming, a purpose-built <code>ClaimSetupManager</code> contract handles the on-chain agreement between users and executors, greatly simplifying the process.</p> <p>To set one or more registered executors to claim rewards for a user:</p> <ol> <li> <p>Get a list of executors and their fees by calling <code>CSM.getRegisteredExecutors()</code>.</p> <p>To find the fee of a specific executor, call <code>CSM.getExecutorCurrentFeeValue()</code>. This fee is deducted from the user\u2019s reward after each claim and sent to the executor.</p> <p>You can show this information to the user and let them select which executor to use.</p> </li> <li> <p>Set the selected executors by calling <code>CSM.setClaimExecutors()</code> as shown for Manual Claiming.</p> <p>However, when setting registered executors, the call must include a value equal to the executor\u2019s fee (in FLR), which is sent to the executor as an enrollment fee. If more than one executor is set, the value must equal the sum of all the executor's fees.</p> </li> </ol>"},{"location":"dev/reference/automatic-claiming/#changing-registered-executors","title":"Changing Registered Executors","text":"<p>To change registered executors, call <code>CSM.setClaimExecutors()</code> with the new list of executors. This new list overwrites the current list.</p>"},{"location":"dev/reference/automatic-claiming/#disabling-automatic-claiming","title":"Disabling Automatic Claiming","text":"<p>To disable automatic claiming, remove all executors by sending an empty array of executors with <code>CSM.setClaimExecutors()</code>.</p>"},{"location":"dev/reference/automatic-claiming/#executor-operations","title":"Executor Operations","text":"<p>This section shows how to perform operations required in an executor-facing application, for example, becoming an executor. While the main step for manual executors is only claiming rewards, the main steps for registered executors are registering, setting a fee, and claiming rewards. Other operations like changing the fee, unregistering as an executor, and learning which addresses to claim for are also explained.</p>"},{"location":"dev/reference/automatic-claiming/#becoming-an-executor","title":"Becoming an Executor","text":"<p>There are two ways to become an executor: Manual and Registered.</p>"},{"location":"dev/reference/automatic-claiming/#manual-executor","title":"Manual Executor","text":"<p>Setting an executor manually means doing so off-chain. Therefore, there is no operation required for executors, besides communicating to the users the address of the executor they need to use.</p>"},{"location":"dev/reference/automatic-claiming/#registered-executor","title":"Registered Executor","text":"<p>The <code>ClaimSetupManager</code> contract contains a list of self-registered executors that users can use to discover executors and their service fees, avoiding the need for off-chain operations as in manual claiming.</p> <p>To automatically receive fees for claiming, an executor address must register, set the fee for claiming rewards, and pay the registration fee.</p> <p>Register an executor by calling <code>CSM.registerExecutor(uint256 feeValue)</code>, where <code>feeValue</code> is the fee in wei that the executor requires to perform this service. The fee value must be at least <code>CSM.minFeeValueWei</code>, currently 0.1 FLR, and no greater than <code>CSM.maxFeeValueWei</code>, currently 100 FLR. This transaction must include a registration fee equal to <code>CSM.registerExecutorFeeValueWei</code>, currently 1000 FLR, which is burned.</p>"},{"location":"dev/reference/automatic-claiming/#claiming-rewards","title":"Claiming Rewards","text":""},{"location":"dev/reference/automatic-claiming/#how-to-claim","title":"How to Claim","text":"<p>Executors can now only claim FTSO delegation rewards on behalf of users. As other rewards become available, they will also be claimable by executors without any user intervention.</p> <p>Manual and registered executors use the same function, the only difference being that unregistered executors do not receive a fee automatically.</p> <p>To claim FTSO rewards for all of a user's unclaimed epochs, call <code>FtsoRewardManager.autoClaim()</code>.</p> <ul> <li>This method can be used to claim for multiple users, since <code>rewardOwners</code> is an array.</li> <li> <p>The <code>rewardEpoch</code> is the most current one that the executor wants to claim for, typically the one before the current epoch.</p> <p>If a user has more unclaimed epochs from the past, the function claims for all of them.</p> </li> </ul> <p>The claimed amount gets the executor fee subtracted and is automatically wrapped, so it is sent to the user as <code>$WFLR</code>.</p>"},{"location":"dev/reference/automatic-claiming/#what-to-expect-in-fees","title":"What to Expect in Fees","text":"<p>The executor gets paid a fee for each user for which he claims the FTSO delegation reward. However, he only gets paid one fee per user regardless of whether he claims for one or more epochs. The fee is paid in native <code>$FLR</code> tokens.</p> <p>If the claimed reward for a user is lower than the executor fee, the transaction is reverted. To see which users have enough rewards to complete and which would revert, call <code>FtsoRewardManager.autoClaim()</code> with a specific user address.</p>"},{"location":"dev/reference/automatic-claiming/#changing-the-fee","title":"Changing the Fee","text":"<p>Registered executors can change the fee they charge for the successful execution of claims. To change the fee, call <code>CSM.updateExecutorFeeValue()</code>. The new fee value will be in effect after <code>CSM.feeValueUpdateOffset</code> reward epochs have elapsed (currently 3 epochs), where the first epoch is the one that is currently active. This function returns the reward epoch number when the setting will become effective.</p>"},{"location":"dev/reference/automatic-claiming/#unregistering-an-executor","title":"Unregistering an Executor","text":"<p>Registered executors can unregister by calling <code>CSM.unregisterExecutor()</code> and they will be removed from the list of executors. To help the users adjust to the change, executors will retain the current fee and continue claiming for the next 3 reward epochs (<code>feeValueUpdateOffset</code>). An executor's best practice is to notify users when unregistering.</p>"},{"location":"dev/reference/automatic-claiming/#updating-the-user-list","title":"Updating the User List","text":"<p>Executors should keep a list of users to claim for, there is no mechanism to retrieve this list from the chain. There are two ways to keep this list updated:</p> <ul> <li>Listen to the <code>CSM.ClaimExecutorsChanged</code> event which is emitted every time a user sets its executors.   This method is suitable for registered executors which might be selected at any time.</li> <li>If the executor is only interested in a closed list of users, e.g., the ones that enlisted on an application, it can call <code>CSM.isClaimExecutor(address user, address executor)</code> for each user to verify the executor's address is properly configured.</li> </ul>"},{"location":"dev/reference/automatic-claiming/#user-and-executor-reports","title":"User and Executor Reports","text":"<p>This section shows how to access information that can help you perform both user and executor functions.</p>"},{"location":"dev/reference/automatic-claiming/#executor-fees","title":"Executor Fees","text":"<p>Get the current fee for each executor on the Registered Executors list by calling <code>CSM.getExecutorCurrentFeeValue(address executor)</code>. For upcoming fee changes, call <code>CSM.getExecutorScheduledFeeValueChanges(address executor)</code>.</p>"},{"location":"dev/reference/automatic-claiming/#executors-by-user","title":"Executors by User","text":"<p>A user can set more than one executor. To see a list of current executors for a user, call <code>CSM.claimExecutors(address user)</code>, which returns an array of executor addresses. It is a best practice for users to check this report periodically (at least every 90 days) to make sure their selected executors have not unregistered without notice.</p>"},{"location":"dev/reference/automatic-claiming/#executor-status","title":"Executor Status","text":"<p>To check if an executor is registered, call <code>CSM.getExecutorInfo(address executor)</code>. It returns whether an executor is registered and its fee.</p>"},{"location":"dev/reference/explorers-and-indexers/","title":"Block Explorers and Indexers","text":"<p>Flare provides a block explorer for each of the networks in its ecosystem. All explorers are a fork of Blockscout, adapted to the Flare networks (Blockscout Docs).</p> <p>API documentation for each network's explorer:</p> <ul> <li>Flare</li> <li>Songbird</li> <li>Coston</li> <li>Coston2</li> </ul> <p>API access to the Coston Explorer is enabled for noncommercial use only.</p>"},{"location":"dev/reference/explorers-and-indexers/#related-user-guides","title":"Related User Guides","text":"<ul> <li>Block Explorers</li> </ul>"},{"location":"dev/reference/ftso/","title":"FTSO","text":"<p>The Flare Time Series Oracle (FTSO) is a smart contract that utilizes the Flare network to provide continuous estimations for various data types. This process is completely decentralized, meaning that no single party has control over it, and is highly secure, making it very difficult to disrupt.</p> <p>This page serves as a guide to understanding and using the FTSO in different applications.</p>"},{"location":"dev/reference/ftso/#system-architecture","title":"System Architecture","text":"<p>The FTSO system is composed of multiple smart contracts running on the Flare Network.</p> <p>Using prices as an example, the following diagram shows the flow of data, queries, and rewards through the FTSO system:</p> <p> </p> FTSO component smart contracts. <p>The following list describes the most relevant contracts and their purposes:</p> <ul> <li> <p>FTSO: Each data type is handled by its own FTSO contract, including calculation of the filtered feed.</p> <p>To retrieve information about a data type, access this contract.</p> <p>Note</p> <p>If an FTSO contract is redeployed (for example, to fix a bug), its address will change and apps using it will need to be updated. The FTSO Registry contract below tracks this change for you.</p> <p>You can retrieve the addresses of all FTSO contracts using the <code>getAllFtsos</code> method in the FTSO Registry.</p> </li> <li> <p>FTSO Registry: Aggregates the output of each individual FTSO contract and provides a convenient one-stop API to retrieve all data.</p> </li> <li> <p>Price Submitter: This contract is used by the FTSO data providers to submit their data. Although the contract is called <code>PriceSubmitter</code>, data is not limited to prices.</p> </li> <li> <p>Reward Manager: Use this contract to claim your rewards, whether you are a data provider or a delegator.</p> </li> <li> <p>Wrapped Native (WNat): This contract is not exclusively related to the FTSO system, but it is required to wrap and unwrap native tokens into the <code>$WFLR</code> and <code>$WSGB</code> that delegation requires.</p> </li> </ul> <p>Note</p> <p>The Contract Addresses page explains how to securely retrieve each contract's address.</p>"},{"location":"dev/reference/ftso/#manual-delegation-and-claiming","title":"Manual Delegation and Claiming","text":"<p>The following graphic shows the delegation process. You can call methods in several different smart contracts to manually delegate vote power and claim rewards.</p> <p> </p> FTSO delegation process summary."},{"location":"dev/reference/ftso/#data-submission-process","title":"Data-Submission Process","text":"<p>Data submission uses a commit-and-reveal scheme to prevent providers from viewing each other's submissions until a round is over. To speed up the process, both phases are actually overlapped so:</p> <ul> <li> <p>All Commit phases happen continuously in so-called 3-minute Price Epochs.</p> </li> <li> <p>Reveal phases happen during the first half (first 90 seconds) of the following Commit phase.</p> </li> <li> <p>The published price information is therefore updated every 3 minutes.</p> </li> </ul> <p>Only a hash of the data is submitted during the Commit phase. Next, in the Reveal phase the actual data is sent. If its hash does not match the previous commitment, the data is discarded.</p> <p>The submission API is slightly different for the Flare and Songbird networks:</p> FlareSongbird <p>FTSO data providers submit data through the PriceSubmitter contract.</p> <ul> <li> <p>Commit: A single hash is needed for each submission.</p> <pre><code>function submitHash(\n    uint256 _epochId,\n    bytes32 _hash\n) external;\n</code></pre> </li> <li> <p>Reveal: After all data is submitted, a single random number must be submitted.</p> <pre><code>function revealPrices(\n    uint256 _epochId,\n    uint256[] memory _ftsoIndices,\n    uint256[] memory _prices,\n    uint256 _random\n) external;\n</code></pre> </li> </ul> <p>FTSO data providers submit data through the PriceSubmitter contract.</p> <ul> <li> <p>Commit: A separate hash is needed for each submission.</p> <pre><code>function submitPriceHashes(\n    uint256 _epochId,\n    uint256[] memory _ftsoIndices,\n    bytes32[] memory _hashes\n) external;\n</code></pre> </li> <li> <p>Reveal: Along with each data submission, a random number must be submitted too.</p> <pre><code>function revealPrices(\n    uint256 _epochId,\n    uint256[] memory _ftsoIndices,\n    uint256[] memory _prices,\n    uint256[] memory _randoms\n) external;\n</code></pre> </li> </ul>"},{"location":"dev/reference/ftso/#retrieving-data","title":"Retrieving Data","text":"<p>Data produced by the FTSO is publicly available on the Flare and Songbird networks.</p> <p>All data can be retrieved either through the <code>FtsoRegistry</code> contract or directly through one of the <code>Ftso</code> contracts. In any case, using the <code>getCurrentPriceWithDecimals</code> method is recommended. The following examples show how to use this method to retrieve price data.</p> Retrieve by pair indexRetrieve by pair symbolRetrieve directly <p>From the <code>FtsoRegistry</code> contract:</p> <pre><code>function getCurrentPriceWithDecimals(\n    uint256 _ftsoIndex\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals\n);\n</code></pre> <p>Where <code>_ftsoIndex</code> is one of the allowed indices returned by <code>getSupportedIndices</code>, for example.</p> <p>From the <code>FtsoRegistry</code> contract:</p> <pre><code>function getCurrentPriceWithDecimals(\n    string memory _symbol\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals\n);\n</code></pre> <p>Where <code>_symbol</code> is one of the allowed symbols returned by <code>getSupportedSymbols</code>, for example.</p> <p>First you need to obtain the address of the <code>Ftso</code> contract managing the price pair you are interested in. You can use <code>getSupportedIndicesSymbolsAndFtsos</code> from the <code>FtsoRegistry</code>, for example.</p> <p>Then call <code>getCurrentPriceWithDecimals</code> on the FTSO directly:</p> <pre><code>function getCurrentPriceWithDecimals(\n) external view returns (\n    uint256 _price,\n    uint256 _timestamp,\n    uint256 _assetPriceUsdDecimals\n);\n</code></pre> <p>Note</p> <p>Individual FTSO contracts might be updated periodically, which will change their addresses. Instead of caching these addresses, use the <code>FtsoRegistry</code>.</p> <p><code>GetCurrentPriceWithDecimals</code> returns the requested price (the outcome of the previous 3-minute price epoch) in <code>$USD</code> shifting the comma by the amount of decimal places returned in <code>_assetPriceUsdDecimals</code>. That is, the actual price is <code>_price</code> * 10 <sup>-<code>_assetPriceUsdDecimals</code></sup>.</p> <p>For example, a return value of <code>2603</code> with <code>_assetPriceUsdDecimals</code> of <code>5</code> means a price of <code>0.02603 USD</code> (There are only 5 significant decimal places).</p> <p>A standard Unix timestamp of the last price update is also returned.</p>"},{"location":"dev/reference/ftso/#related-tutorials","title":"Related Tutorials","text":"<ul> <li>FTSO</li> </ul>"},{"location":"dev/reference/network-config/","title":"Network Configuration","text":""},{"location":"dev/reference/network-config/#flare-networks","title":"Flare Networks","text":"<p>These are the values required to configure the different Flare networks:</p> FlareSongbirdCostonCoston2 Flare Chain ID 14 Asset Ticker <code>FLR</code> RPC endpoint <code>https://flare-api.flare.network/ext/bc/C/rpc</code> Rosetta API <code>https://flare-rosetta-api.flare.network/</code> Block Explorer https://flare-explorer.flare.network Bootstraping nodes <ul><li><code>https://flare.flare.network</code></li><li><code>https://flare-bootstrap-1.staking.production.figment.io</code></li><li><code>https://flare.senseinode.com</code></li></ul> Sample query <p>You can check that you are accessing the RPC endpoint correctly with this sample query:</p> <pre><code>curl -s -m 10 --request POST 'https://flare-api.flare.network/ext/bc/C/rpc' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\n            \"jsonrpc\":\"2.0\",\n            \"method\":\"eth_blockNumber\",\n            \"params\":[],\n            \"id\":1\n    }'\n</code></pre> <p>It should return the current chain height in a message similar to:</p> <pre><code>{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":\"0x103384\"}\n</code></pre> Songbird Chain ID 19 Asset Ticker <code>SGB</code> RPC endpoint <code>https://songbird-api.flare.network/ext/bc/C/rpc</code> Block Explorer https://songbird-explorer.flare.network Bootstraping nodes <code>https://songbird.flare.network</code> Sample query <p>You can check that you are accessing the RPC endpoint correctly with this sample query:</p> <pre><code>curl -s -m 10 --request POST 'https://songbird-api.flare.network/ext/bc/C/rpc' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\n            \"jsonrpc\":\"2.0\",\n            \"method\":\"eth_blockNumber\",\n            \"params\":[],\n            \"id\":1\n    }'\n</code></pre> <p>It should return the current chain height in a message similar to:</p> <pre><code>{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":\"0x103384\"}\n</code></pre> Coston Chain ID 16 Asset Ticker <code>CFLR</code> RPC endpoint <code>https://coston-api.flare.network/ext/bc/C/rpc</code> Block Explorer https://coston-explorer.flare.network Bootstraping nodes <code>https://coston.flare.network</code> Test Faucet https://faucet.towolabs.com Sample query <p>You can check that you are accessing the RPC endpoint correctly with this sample query:</p> <pre><code>curl -s -m 10 --request POST 'https://coston-api.flare.network/ext/bc/C/rpc' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\n            \"jsonrpc\":\"2.0\",\n            \"method\":\"eth_blockNumber\",\n            \"params\":[],\n            \"id\":1\n    }'\n</code></pre> <p>It should return the current chain height in a message similar to:</p> <pre><code>{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":\"0x103384\"}\n</code></pre> Coston2 Chain ID 114 Asset Ticker <code>C2FLR</code> RPC endpoint <code>https://coston2-api.flare.network/ext/bc/C/rpc</code> Block Explorer https://coston2-explorer.flare.network Bootstraping nodes <code>https://coston2.flare.network</code> Test Faucet https://coston2-faucet.towolabs.com Sample query <p>You can check that you are accessing the RPC endpoint correctly with this sample query:</p> <pre><code>curl -s -m 10 --request POST 'https://coston2-api.flare.network/ext/bc/C/rpc' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\n            \"jsonrpc\":\"2.0\",\n            \"method\":\"eth_blockNumber\",\n            \"params\":[],\n            \"id\":1\n    }'\n</code></pre> <p>It should return the current chain height in a message similar to:</p> <pre><code>{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":\"0x103384\"}\n</code></pre> <p>All public RPC endpoints are experimental and rate-limited to avoid spamming attacks. For a production-grade option check out Flare's API Portal</p>"},{"location":"dev/reference/network-config/#connected-networks","title":"Connected Networks","text":"<p>Along with the endpoints listed above to interact with its own networks, Flare offers public RPC nodes for a series of other blockchain networks, to bootstrap development of connected services like attestation providers.</p> <p>All public RPC endpoints are experimental and rate-limited to avoid spamming attacks. For a production-grade option check out Flare's API Portal</p> BitcoinBNB-BSCLitecoinDogecoinXRPLAlgorandEthereum RPC endpoint <code>https://bitcoin-api.flare.network</code> Sample query <pre><code>curl -s -X POST -m 10 -H \"Content-type: application/json\" \\\n-d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\\n-u public:d681co1pe2l3wcj9adrm2orlk0j5r5gr3wghgxt58tvge594co0k1ciljxq9glei \\\nhttps://bitcoin-api.flare.network | jq\n</code></pre> RPC endpoint <code>https://bnb-bsc-api.flare.network/</code> Sample query <pre><code>curl -s -X POST -m 10 -H \"Content-Type: application/json\" \\\n-d '{\"jsonrpc\": \"2.0\", \"id\":67, \"method\":\"eth_blockNumber\", \"params\":[]}' \\\nhttps://bnb-bsc-api.flare.network | jq\n</code></pre> RPC endpoint <code>https://litecoin-api.flare.network</code> Sample query <pre><code>curl -s -X POST -m 10 -H \"Content-type: application/json\" \\\n-d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\\n-u public:ntvzi4i1yne499t7vcdjqhhp92m3jvm0bb6dkpr406gkndvuns9sg6th3jd393uc \\\nhttps://litecoin-api.flare.network | jq\n</code></pre> RPC endpoint <code>https://dogecoin-api.flare.network</code> Sample query <pre><code>curl -s -X POST -m 10 -H \"Content-type: application/json\" \\\n-d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\\n-u public:6r1e5z3w9g6qruvkzkqvz8w67yqrq5js2cmyl2f1cncbp7gpp7tqixqskuub5v70 \\\nhttps://dogecoin-api.flare.network | jq\n</code></pre> RPC endpoint <code>https://xrpl-api.flare.network</code> Sample query <pre><code>curl -s -X POST -m 10 -H \"Content-type: application/json\" \\\n-d '{\"method\": \"server_info\", \"params\":[{\"api_version\": 1}]}' \\\nhttps://xrpl-api.flare.network | jq\n</code></pre> RPC endpoint <code>https://algorand-api.flare.network</code> Sample query <pre><code>curl -s -m 10 \\\n-H \"X-Algo-API-Token: zl748k3wddvld8cvn64utnslbf7otorkijp84se0f58pmuu0shgm27gttpcjpmuq\" \\\nhttps://algorand-api.flare.network/v2/status | jq\n</code></pre> RPC endpoint <code>https://ethereum-api.flare.network/</code> Sample query <pre><code>curl -s -X POST -m 10 -H \"Content-Type: application/json\" \\\n-d '{\"jsonrpc\": \"2.0\", \"id\":67, \"method\":\"eth_blockNumber\", \"params\":[]}' \\\nhttps://ethereum-api.flare.network | jq\n</code></pre>"},{"location":"dev/reference/personal-delegation-account/","title":"Personal Delegation Accounts","text":"<p>Personal Delegation Accounts (PDAs) temporarily store rewards, such as FTSO delegation rewards, that users do not want to claim to their main accounts as explained in the Concept page.</p> <p>This page explains how to manage PDA functionality in applications.</p>"},{"location":"dev/reference/personal-delegation-account/#required-contracts","title":"Required contracts","text":"<p>Working with the PDAs requires interacting with these contracts:</p> <ul> <li><code>ClaimSetupManager</code> (CSM).</li> <li><code>FTSORewardManager</code> (FTSO).</li> </ul> <p>To find the addresses of these contracts read the Contract Addresses page.</p>"},{"location":"dev/reference/personal-delegation-account/#enabling-a-pda","title":"Enabling a PDA","text":"<p><code>CSM.enableDelegationAccount()</code> returns the address of the PDA associated with the caller's address, creating the PDA in the process if it didn't exist. A single PDA can be associated with each address and it cannot be destroyed once created, only disabled (see below).</p> <p>There exist no private keys to the PDA account so it cannot sign any transactions. All interaction with the PDA happens through the CSM contract, and is usually triggered by the user's main account.</p> <p>Note that this means that a PDA cannot have its own PDA, since no calls to the CSM can be made from the PDA account.</p> <p>Once a PDA is created, certain functions like <code>FtsoRewardManager.autoClaim()</code> automatically send claimed rewards to the PDA account instead of the main account. See Delegation and Rewards below.</p>"},{"location":"dev/reference/personal-delegation-account/#disabling-a-pda","title":"Disabling a PDA","text":"<p>To disable the use of a PDA, call <code>CSM.disableDelegationAccount()</code>. Any <code>$WFLR</code> tokens that are on the PDA address are transferred back to the user's main account.</p> <p>When users disable their PDA, <code>FtsoRewardManager.autoClaim()</code> claims only the rewards for their main account and to their main account.</p> <p><code>CSM.disableDelegationAccount()</code> disables the PDA contract but does not destroy it: its address is still returned by <code>CSM.getDelegationAccountData()</code>, but the <code>enabled</code> boolean will be <code>false</code>.</p>"},{"location":"dev/reference/personal-delegation-account/#checking-pda-state","title":"Checking PDA State","text":"<p>To check if a user's PDA is enabled, call <code>CSM.getDelegationAccountData()</code>. It returns both the PDA address and its state:</p> Condition Address State PDA is enabled PDA address <code>true</code> PDA is disabled PDA address <code>false</code> PDA has never been created <code>0x000...000</code> <code>false</code> <p>Never rely solely on the returned address being non-zero to check if an account has a PDA.</p>"},{"location":"dev/reference/personal-delegation-account/#delegation-and-rewards","title":"Delegation and Rewards","text":"<p>A PDA is a regular account for which there are no private keys and which must be managed through the CSM contract instead.</p> <p>Conveniently, the method signatures to delegate on the CSM are the same as on the <code>WNat</code> contract where delegation is usually performed, for instance <code>CSM.batchDelegate()</code>. FTSO reward claiming, though, is still performed through the <code>FTSORewardManager</code>, for example using <code>claimReward(address recipient, ...)</code> where <code>recipient</code> allows sending to any address, including a PDA. For information on how to delegate and claim FTSO rewards, see Delegation and Rewards.</p> <p>In addition to the methods used for regular accounts, <code>FtsoRewardManager.autoClaim()</code> automatically claims for both the main account and the PDA, to the PDA or the main account depending on whether the PDA is enabled or not. If users disable their PDA, <code>autoClaim()</code> claims rewards for only their main account and to only their main account.</p> <p>Note</p> <p>The <code>autoClaim()</code> method is unrelated to Automatic Claiming performed by executors.</p>"},{"location":"dev/reference/personal-delegation-account/#governance-voting","title":"Governance Voting","text":"<p>Flare network users have a right to vote on proposals that can change the behavior of the network or add new features. The number of votes an address has is equal to the amount of wrapped Flare tokens (<code>$WFLR</code>) that the address holds.</p> <p>PDA addresses cannot vote directly, but their owners can transfer all their votes to another address (e.g., the owner's address) by calling <code>CSM.delegateGovernance(address recipient)</code>. The recipient of the votes can then vote with its own votes as well as with the votes received from other addresses.</p>"},{"location":"dev/reference/personal-delegation-account/#transferring-funds","title":"Transferring Funds","text":"<p>Because a PDA is a regular account, anyone can send funds to it. However, FLR tokens transferred to a PDA are automatically converted to <code>$WFLR</code>, making them convenient for delegation.</p> <p>Only the owner of the main account and its PDA can transfer funds from the PDA and only to its main account. To transfer tokens, the owner calls <code>CSM.withdraw()</code> and states the amount to withdraw.</p> <p>Since it has no private keys, any token other than <code>$FLR</code> or <code>$WFLR</code> transferred to the PDA cannot be moved out by conventional means. Instead, <code>CSM.transferExternalToken()</code> must be used to transfer them to another account. This is useful, for example, to recover airdropped tokens accidentally sent to the PDA.</p> <p>Note</p> <p><code>CSM.transferExternalToken()</code> only works on ERC-20 tokens or token contracts that support the <code>transfer</code> function.</p>"},{"location":"dev/reference/personal-delegation-account/#wallet-or-dapp-integration","title":"Wallet or Dapp Integration","text":"<p>To support personal delegation accounts, a wallet or dapp at a minimum should show its status, including:</p> <ul> <li>Checking the user's PDA address and whether it is enabled.</li> <li>Showing the amount of <code>$WFLR</code> on the user's PDA.</li> </ul> <p>Additional integration could support the following actions:</p> <ul> <li>Enabling and disabling the PDA.</li> <li>Allowing the delegation of funds from a PDA to FTSO price providers.</li> <li>Delegating votes for governance voting.</li> <li>Claiming rewards to the PDA.</li> <li>Withdrawing funds from users' PDAs to their main accounts.</li> <li>Withdrawing custom ERC-20 tokens to the users' main accounts.</li> </ul> <p>See the Flare Portal for an example of such integration.</p>"},{"location":"dev/reference/the-flaredrop/","title":"The FlareDrop","text":"<p>The FlareDrop, previously called the Delegation Incentive Pool in the FIP.01, is a distribution method for the 24.25B remaining <code>$FLR</code> tokens after the original airdrop.</p> <p>This page explains how to manage FlareDrop functionality in applications.</p>"},{"location":"dev/reference/the-flaredrop/#required-contracts","title":"Required Contracts","text":"<p>Working with the FlareDrop requires interacting with these contracts:</p> <ul> <li><code>DistributionToDelegators</code> (Dist).     Manages all claims.</li> <li><code>ClaimSetupManager</code> (CSM).     Needed to configure autoclaiming.</li> </ul> <p>To find their addresses, read the Contract Addresses page.</p>"},{"location":"dev/reference/the-flaredrop/#operations","title":"Operations","text":""},{"location":"dev/reference/the-flaredrop/#basic-claiming","title":"Basic Claiming","text":"<p>The <code>Dist.claim</code> method allows claiming the FlareDrop one account at a time.</p> <pre><code>function claim(\n    address _rewardOwner,\n    address _recipient,\n    uint256 _month,\n    bool _wrap\n) external returns(\n    uint256 _rewardAmount\n);\n</code></pre> <p>It transfers the FlareDrop rewards accrued by account <code>_rewardOwner</code> during the specified <code>_month</code> to the specified <code>_recipient</code>.</p> <p><code>_wrap</code> controls whether the reward is transferred in native <code>$FLR</code> tokens or wrapped in <code>$WFLR</code> tokens.</p> <p>You can use <code>Dist.getCurrentMonth()</code> to find out the current month (starting at 0), or <code>Dist.getClaimableMonths()</code> to get the interval of months which are currently available for claiming. Use <code>Dist.getClaimableAmount()</code> or <code>Dist.getClaimableAmountOf()</code> to find out if a given address has pending rewards on any given month.</p> <p><code>Dist.claim()</code> returns the amount of claimed rewards.</p> <p>Two modes of operation are supported: Self-claiming and claiming on behalf of another account.</p> <ul> <li> <p>Self-Claiming:</p> <p>When <code>msg.sender</code> matches <code>_rewardOwner</code>, the caller is claiming its own rewards. In this case <code>_recipient</code> can be any address.</p> </li> <li> <p>Claiming on behalf of another account:</p> <p>When <code>msg.sender</code> does not match <code>_rewardOwner</code>, the caller must be a claim executor, claiming on behalf of <code>_rewardOwner</code>.</p> <p>If <code>_msg.sender</code> is not in the authorized list of executors for <code>_rewardOwner</code>, the call will revert. Authorized executors must be set beforehand by <code>_rewardOwner</code> using <code>CSM.setClaimExecutors()</code>.</p> <p>The <code>_recipient</code> must either be <code>_rewardOwner</code>, its PDA, or any of the authorized recipients previously set by <code>_rewardOwner</code> using <code>CSM.setAllowedClaimRecipients()</code>. The call will revert otherwise.</p> </li> </ul>"},{"location":"dev/reference/the-flaredrop/#batched-claiming","title":"Batched Claiming","text":"<p>The <code>Dist.autoClaim()</code> method allows claiming the FlareDrop for an arbitrary amount of accounts in a single call, with convenient default values.</p> <pre><code>function autoClaim(\n    address[] calldata _rewardOwners,\n    uint256 _month\n) external;\n</code></pre> <p>It claims the rewards accrued by all the accounts in the <code>_rewardOwners</code> array during the specified <code>_month</code>.</p> <p>If an account does not have an enabled PDA, the rewards are sent to the same account.</p> <p>However, if an account does have an enabled PDA, the rewards are sent to the PDA account. Any rewards accrued by the PDA account are also claimed and sent to the PDA.</p> <p>Rewards claimed with this method are always wrapped.</p> <p>If the executor is a registered executor with a nonzero fee, the fee is automatically deducted from each claimed reward and sent to the executor account (unwrapped). If rewards are claimed for both an address and its PDA, the fee is deducted only once.</p> <p>The call reverts if:</p> <ul> <li><code>msg.sender</code> is not in the authorized list of executors for any of the <code>_rewardOwners</code>.</li> <li>The total claimed rewards for any of the <code>_rewardOwners</code> is not high enough to cover the executor's fee.</li> </ul>"},{"location":"dev/reference/wallets/","title":"Wallets","text":"<p>Information for wallet developers wanting to integrate with the Flare networks.</p> <p>First off, find all basic network information like Chain ID or public RPC endpoints in the Network Configuration page.</p> <p>This page then provides a few more pointers specific to wallet development.</p>"},{"location":"dev/reference/wallets/#block-explorers-and-indexers","title":"Block Explorers and Indexers","text":"<p>For all its networks, Flare offers public block explorers that double down as indexers. Learn about them in the Block Explorers section.</p>"},{"location":"dev/reference/wallets/#flares-personal-delegation-accounts","title":"Flare's Personal Delegation Accounts","text":"<p>See the Integration with a Personal Delegation Account page.</p>"},{"location":"dev/reference/wallets/#address-derivation-paths-for-hd-wallets","title":"Address Derivation Paths for HD Wallets","text":"<p>Address derivation and format validation on Flare are the same as on Ethereum. In particular, Flare uses the same coin type as Ethereum, this is, 60. The BIP-44 paths are therefore <code>m/44\u2019/60\u2019/x\u2019/0/0</code> (hardened) and <code>m/44\u2019/60\u2019/0\u2019/0/x</code>.</p> <p>The same path is used on both the C-chain and the P-chain.</p>"},{"location":"dev/tutorials/","title":"Tutorials","text":"<p>The Flare developer tutorials are divided into the following topics.</p>"},{"location":"dev/tutorials/#topics","title":"Topics","text":"<ul> <li>Accessing the Network</li> <li>FTSO</li> </ul>"},{"location":"dev/tutorials/ftso/","title":"FTSO Tutorials","text":"<p>These code samples and explanations show how to use the FTSO system.</p>"},{"location":"dev/tutorials/ftso/#tutorials","title":"Tutorials","text":"<ul> <li>Getting FTSO Data Feeds</li> </ul>"},{"location":"dev/tutorials/ftso/getting-data-feeds/","title":"Getting FTSO Data Feeds","text":"<p>This tutorial shows the simplest way to use the FTSO system to retrieve a specific data feed, like the price of Bitcoin.</p> <p>The tutorial shows:</p> <ul> <li>How to use the Flare periphery packages to simplify working with the Flare API.</li> <li>How to retrieve the latest price for a given asset from the FTSO system.</li> </ul>"},{"location":"dev/tutorials/ftso/getting-data-feeds/#code","title":"Code","text":"<p>Choose your preferred programming language and ensure you have a working development environment.</p> <p>For easy navigation, numbered comments in the source code link to the tutorial sections below.</p> SolidityJavaScript GettingDataFeeds.sol<pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// 1. Import dependencies\nimport \"@flarenetwork/flare-periphery-contracts/flare/util-contracts/userInterfaces/IFlareContractRegistry.sol\";\nimport \"@flarenetwork/flare-periphery-contracts/flare/ftso/userInterfaces/IFtsoRegistry.sol\";\n\ncontract GettingDataFeeds {\n\n    address private constant FLARE_CONTRACT_REGISTRY =\n        0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019;\n\n    function getTokenPriceWei(\n        string memory _symbol\n    ) public view returns(\n        uint256 _price, uint256 _timestamp, uint256 _decimals)\n    {\n        // 2. Access the Contract Registry\n        IFlareContractRegistry contractRegistry = IFlareContractRegistry(\n            FLARE_CONTRACT_REGISTRY);\n\n        // 3. Retrieve the FTSO Registry\n        IFtsoRegistry ftsoRegistry = IFtsoRegistry(\n            contractRegistry.getContractAddressByName('FtsoRegistry'));\n\n        // 4. Get latest price\n        (_price, _timestamp, _decimals) =\n            ftsoRegistry.getCurrentPriceWithDecimals(_symbol);\n    }\n\n}\n</code></pre> <p>Source code license</p> Using HardhatUsing Foundry Building with Hardhat <ol> <li>Create a new folder and move into it.</li> <li>Create a new Hardhat project (More information in the Hardhat setup guide):     <pre><code>npm init\nnpm install hardhat @nomicfoundation/hardhat-toolbox\nnpx hardhat init\n</code></pre></li> <li>You will not be using the sample project, therefore:<ul> <li>Remove <code>contracts/Lock.sol</code></li> <li>Remove <code>test/Lock.js</code></li> </ul> </li> <li>Add Flare's Periphery Package as a dependency with:     <pre><code>npm install @flarenetwork/flare-periphery-contracts\n</code></pre></li> <li>Copy the Solidity code above into a new file called <code>GettingDataFeeds.sol</code> in the <code>contracts</code> folder.</li> <li>Compile with:     <pre><code>npx hardhat compile\n</code></pre></li> </ol> Testing with Hardhat <p>Testing smart contracts before deploying them is typically performed by forking the network or by using mock contracts. These instructions quickly show you how to use the former.</p> <ol> <li>Build the Hardhat project following the previous instructions.</li> <li>Modify your <code>hardhat.config.js</code> to look like this:     hardhat.config.js<pre><code>require(\"@nomicfoundation/hardhat-toolbox\");\n\n/** @type import('hardhat/config').HardhatUserConfig */\nmodule.exports = {\n    solidity: \"0.8.19\",\n    networks: {\n        hardhat: {\n            forking: {\n                url: 'https://flare-api.flare.network/ext/bc/C/rpc',\n            },\n        },\n    },\n};\n</code></pre></li> <li>Copy the code below into a new file called <code>TestGettingDataFeeds.js</code> in the <code>test</code> folder.     TestGettingDataFeeds.js<pre><code>const { expect } = require(\"chai\");\n\ndescribe(\"GettingDataFeeds\", async function () {\n    let contract;\n    beforeEach(async function () {\n        contract = await ethers.deployContract(\"GettingDataFeeds\");\n    });\n    it(\"Should return sensible values\", async function () {\n        const res = await contract.getTokenPriceWei(\"BTC\");\n\n        expect(res._timestamp).to.greaterThan(1695817332);\n        expect(res._decimals).to.within(0, 18);\n        expect(res._price).to.within(0, 1000000 * 10 ** Number(res._decimals));\n    });\n});\n</code></pre></li> <li>Run the test with:     <pre><code>npx hardhat test\n</code></pre></li> </ol> Building with Foundry <ol> <li>If you don't have Foundry installed, follow the instructions for your operating system in the Foundry's Installation guide.</li> <li>Create a new Foundry project:     <pre><code>forge init &lt;PROJECT_NAME&gt;\n</code></pre>     This command creates a new directory called <code>&lt;PROJECT_NAME&gt;</code>. Use a name that suits your needs.</li> <li>Move into the project's directory:     <pre><code>cd &lt;PROJECT_NAME&gt;\n</code></pre></li> <li>Install dependencies with:     <pre><code>forge install flare-foundation/flare-foundry-periphery-package\n</code></pre></li> <li>Remove the sample project that Foundry created for you, as you do not need it:<ul> <li>Remove <code>src/Counter.sol</code></li> <li>Remove <code>test/Counter.t.sol</code></li> </ul> </li> <li>Copy the Solidity code above into a new file called <code>GettingDataFeeds.sol</code> in the <code>src</code> folder.</li> <li>Open the <code>foundry.toml</code> file, and add the following line at the end:     <pre><code>remappings = [ \"@flarenetwork/flare-periphery-contracts/=lib/flare-foundry-periphery-package/src/\"]\n</code></pre></li> <li>Compile with:     <pre><code>forge build\n</code></pre></li> </ol> Testing with Foundry <p>Testing smart contracts before deploying them is typically performed by forking the network or by using mock contracts. These instructions quickly show you how to use the former.</p> <ol> <li>Build the Foundry project following the previous instructions.</li> <li>Copy the code below into a new file called <code>GettingDataFeeds.t.sol</code> in the <code>test</code> folder.     GettingDataFeeds.t.sol<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Import dependencies\nimport \"forge-std/Test.sol\";\nimport \"../src/GettingDataFeeds.sol\";\n\n// Test Contract\ncontract TestGettingDataFeeds is Test {\n\n    string private constant FLARE_RPC =\n        \"https://flare-api.flare.network/ext/bc/C/rpc\";\n    uint256 private flareFork;\n\n    function setUp() public {\n        flareFork = vm.createFork(FLARE_RPC);\n    }\n\n    function testSimplePrice() public {\n        vm.selectFork(flareFork);\n        GettingDataFeeds datafeeds = new GettingDataFeeds();\n\n        (uint256 _price, uint256 _timestamp, uint256 _decimals) =\n            datafeeds.getTokenPriceWei(\"BTC\");\n\n        assertGt(_timestamp, 1695817332,\n            \"Timestamp expected to be greater than a known past block\");\n        assertGe(_decimals, 0,\n            \"Number of decimals expected to be &gt;= 0\");\n        assertLe(_decimals, 18,\n            \"Number of decimals expected to be &lt;= 18\");\n        assertGt(_price, 0,\n            \"Price expected to be &gt; 0\");\n        assertLt(_price, 1000000 * 10 ** _decimals,\n            \"Price expected to be &lt; 1'000'000\");\n    }\n}\n</code></pre></li> <li>Run the test with:     <pre><code>forge test -vv\n</code></pre></li> </ol> GettingDataFeeds.js<pre><code>const FLARE_PACKAGE = \"@flarenetwork/flare-periphery-contract-artifacts\";\nconst FLARE_RPC = \"https://flare-api.flare.network/ext/bc/C/rpc\";\n\nasync function GettingDataFeeds_run(_symbol) {\n    console.log(`Retrieving current price of ${_symbol}...`);\n\n    // 1. Import dependencies\n    var ethers, flare;\n    if (typeof window === \"undefined\") {\n        // Node.js\n        ethers = await import(\"ethers\");\n        flare = await import(FLARE_PACKAGE);\n    } else {\n        // Browser\n        ethers = await import(\"https://esm.run/ethers@6.3\");\n        flare = await import(`https://esm.run/${FLARE_PACKAGE}`);\n    }\n\n    // Node to submit queries to.\n    const provider = new ethers.JsonRpcProvider(FLARE_RPC);\n\n    // 2. Access the Contract Registry\n    const flareContractRegistry = new ethers.Contract(\n        \"0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019\",\n        flare.nameToAbi(\"FlareContractRegistry\", \"flare\").data,\n        provider);\n\n    // 3. Retrieve the FTSO Registry\n    const ftsoRegistryAddr = await\n        flareContractRegistry.getContractAddressByName(\"FtsoRegistry\");\n    const ftsoRegistry = new ethers.Contract(\n        ftsoRegistryAddr,\n        flare.nameToAbi(\"FtsoRegistry\", \"flare\").data,\n        provider);\n\n    // 4. Get latest price\n    const [_price, _timestamp, _decimals] =\n        await ftsoRegistry[\"getCurrentPriceWithDecimals(string)\"](_symbol);\n\n    console.log(`${Number(_price) / Math.pow(10, Number(_decimals))} USD`);\n    console.log(`Calculated at ${new Date(Number(_timestamp) * 1000)}`);\n}\n\nGettingDataFeeds_run(\"BTC\");\n</code></pre> <p>Source code license</p> <p></p> Run with Node.js <p>This tutorial has been tested with npm v9.5 and Node.js v18.16.</p> <ol> <li>Create a new folder and move into it.</li> <li>Copy &amp; paste the code above into a new file called <code>GettingDataFeeds.js</code>.</li> <li>Install dependencies with:     <pre><code>npm init\nnpm install ethers @flarenetwork/flare-periphery-contract-artifacts\n</code></pre></li> <li>Run the program with:     <pre><code>node GettingDataFeeds.js\n</code></pre></li> </ol> <p> Run in browser <pre><code>\n</code></pre> </p>"},{"location":"dev/tutorials/ftso/getting-data-feeds/#tutorial","title":"Tutorial","text":""},{"location":"dev/tutorials/ftso/getting-data-feeds/#1-import-dependencies","title":"1. Import Dependencies","text":"<p>The tutorial uses the following dependencies:</p> <ul> <li> <p>The Flare Periphery Package for Solidity and the Flare Periphery Artifacts Package for JavaScript, which provide the API for all Flare smart contracts.</p> </li> <li> <p>If you use JavaScript, the ethers package is also needed to work with smart contracts.</p> </li> </ul> SolidityJavaScript <pre><code>import \"@flarenetwork/flare-periphery-contracts/flare/util-contracts/userInterfaces/IFlareContractRegistry.sol\";\nimport \"@flarenetwork/flare-periphery-contracts/flare/ftso/userInterfaces/IFtsoRegistry.sol\";\n</code></pre> <pre><code>    var ethers, flare;\n    if (typeof window === \"undefined\") {\n        // Node.js\n        ethers = await import(\"ethers\");\n        flare = await import(FLARE_PACKAGE);\n    } else {\n        // Browser\n        ethers = await import(\"https://esm.run/ethers@6.3\");\n        flare = await import(`https://esm.run/${FLARE_PACKAGE}`);\n    }\n</code></pre> <p>The Periphery Packages simplify working with the Flare smart contracts significantly. If you remove this dependency, you must manually provide the signatures for all the methods you want to use.</p>"},{"location":"dev/tutorials/ftso/getting-data-feeds/#2-access-the-contract-registry","title":"2. Access the Contract Registry","text":"<p>The <code>FlareContractRegistry</code> contains the current addresses for all Flare smart contracts, and it is the only recommended way to retrieve them.</p> <p>Its address is the same on all of Flare's networks, and it is the only Flare address that needs to be hard-coded into any program.</p> SolidityJavaScript <pre><code>        IFlareContractRegistry contractRegistry = IFlareContractRegistry(\n            FLARE_CONTRACT_REGISTRY);\n</code></pre> <pre><code>    const flareContractRegistry = new ethers.Contract(\n        \"0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019\",\n        flare.nameToAbi(\"FlareContractRegistry\", \"flare\").data,\n        provider);\n</code></pre>"},{"location":"dev/tutorials/ftso/getting-data-feeds/#3-retrieve-the-ftso-registry","title":"3. Retrieve the FTSO Registry","text":"<p>Prices for all assets tracked by the FTSO system are recovered through the <code>FtsoRegistry</code> contract.</p> <p>Use the <code>getContractAddressByName()</code> method from the <code>FlareContractRegistry</code> to retrieve the address of the <code>FtsoRegistry</code>.</p> SolidityJavaScript <pre><code>        IFtsoRegistry ftsoRegistry = IFtsoRegistry(\n            contractRegistry.getContractAddressByName('FtsoRegistry'));\n</code></pre> <pre><code>    const ftsoRegistryAddr = await\n        flareContractRegistry.getContractAddressByName(\"FtsoRegistry\");\n    const ftsoRegistry = new ethers.Contract(\n        ftsoRegistryAddr,\n        flare.nameToAbi(\"FtsoRegistry\", \"flare\").data,\n        provider);\n</code></pre> <p>This address can be retrieved in the initialization phase of your program and used afterward. There is no need to fetch it every time it must be used.</p>"},{"location":"dev/tutorials/ftso/getting-data-feeds/#4-get-latest-price","title":"4. Get Latest Price","text":"<p>Finally, the asset's price is fetched from the <code>FtsoRegistry</code> using <code>getCurrentPriceWithDecimals</code>.</p> SolidityJavaScript <pre><code>        (_price, _timestamp, _decimals) =\n            ftsoRegistry.getCurrentPriceWithDecimals(_symbol);\n</code></pre> <pre><code>    const [_price, _timestamp, _decimals] =\n        await ftsoRegistry[\"getCurrentPriceWithDecimals(string)\"](_symbol);\n\n    console.log(`${Number(_price) / Math.pow(10, Number(_decimals))} USD`);\n    console.log(`Calculated at ${new Date(Number(_timestamp) * 1000)}`);\n</code></pre> <ul> <li> <p>The only parameter of this method is the symbol for the asset being queried, like <code>\"FLR\"</code> or <code>\"BTC\"</code>.     You can use <code>getSupportedSymbols()</code> to retrieve the list of all supported symbols.</p> <p>Warning</p> <p>On Coston and Coston2, the symbol names are prefixed with \"test\", such as <code>\"testBTC\"</code>. When you use the <code>getSupportedSymbols()</code> function to retrieve the list of supported symbols, the symbol names will already contain the prefix.</p> </li> <li> <p>Given that Solidity does not support numbers with decimals, this method returns the requested price as an integer and the number of decimal places by which the comma must be shifted.</p> <p>For example, if it returns 1234 for the price and 2 for the decimals, the actual price of the asset in USD is 12.34.</p> </li> <li> <p>It also returns the time when the price was calculated by the FTSO system as a UNIX timestamp.     You can use an online tool like EpochConverter to turn the timestamp into a human-readable form,     or use <code>Date</code> as in the JavaScript example.</p> </li> </ul> JavaScript note on overloaded methods <p>The call to the <code>getCurrentPriceWithDecimals</code> method is a bit cumbersome in JavaScript:</p> <pre><code>    const [_price, _timestamp, _decimals] =\n        await ftsoRegistry[\"getCurrentPriceWithDecimals(string)\"](_symbol);\n</code></pre> <p>The call needs to be like this because this method is overloaded. <code>getCurrentPriceWithDecimals</code> has two versions: one accepting a string for the symbol and another one accepting an integer for the asset's index in the FTSO system. Therefore, the call needs to disambiguate both versions.</p> <p>The vast majority of methods are not overloaded and allow a more natural call format. For example:</p> <pre><code>await ftsoRegistry.getSupportedSymbols();\n</code></pre>"},{"location":"dev/tutorials/ftso/getting-data-feeds/#conclusion","title":"Conclusion","text":"<p>This tutorial served as the Hello World program for the FTSO system. It has shown:</p> <ul> <li>How to use the Flare Periphery Package, both from Solidity and from JavaScript.</li> <li>How to retrieve the latest price for a given asset from the FTSO system.</li> </ul>"},{"location":"dev/tutorials/network-access/","title":"Accessing the Network","text":"<p>The following tutorials deal with common problems encountered when accessing the Flare networks, like sending transactions or reading events.</p>"},{"location":"dev/tutorials/network-access/#tutorials","title":"Tutorials","text":"<ul> <li>Checking Transaction Finalization</li> <li>Reliable Event Reading</li> <li>Obtaining a Transaction's Revert Reason</li> </ul>"},{"location":"dev/tutorials/network-access/obtaining-revert-reason/","title":"Obtaining a Transaction's Revert Reason","text":"<p>Sometimes contract calls revert and throw a generic \"Transaction has been reverted\" exception which is not very helpful, since it does not contain the revert reason.</p> <p>In this case, simulating the call in the EVM without sending any transaction, using the <code>.call()</code> syntax, can provide the missing information, assuming the blockchain's state has not changed much between calls.</p> <p>The whole process is:</p> <ul> <li>Catch the exception, and check if the revert reason is part of the exception data.</li> </ul> <p>If not:</p> <ul> <li>Repeat the same contract call using <code>.call()</code> syntax and parse the revert reason.</li> </ul> <p>Note that the second step should be performed as soon as possible, to ensure that the chain has a similar state in both calls.</p> <p>The function below demonstrates this process.</p> <pre><code>async function contractCall(account, to, gas, gasPrice, fnToEncode, nonce) {\n  let tx = {from: account.address, to, gas, gasPrice, data: fnToEncode.encodeABI(), nonce};\n  let signedTx = await account.signTransaction(tx);\n  try {\n    return await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  } catch (e) {\n    if (e.message.indexOf(\"Transaction has been reverted by the EVM\") &gt;= 0) {\n      // This call should throw a new exception containing the revert reason\n      await fnToEncode.call({ from: account.address });\n    }\n    // Otherwise, either revert reason was already part of the original error or\n    // we failed to get any additional information.\n    throw e;\n  }\n}\n</code></pre> <p>Where <code>account</code> and <code>fnToEncode</code> are obtained, for example, as follows:</p> <pre><code>let account = web3.eth.accounts.privateKeyToAccount(privateKey);\nlet fnToEncode = web3Contract.methods.someMethodOnContract(param1, param2);\n</code></pre>"},{"location":"dev/tutorials/network-access/reliable-event-reading/","title":"Reliable Event Reading","text":"<p>Subscription to events, for example using listeners, has proved to be unreliable, especially when high traffic exists on the network.</p> <p>To reliably read events it is recommended to use the <code>getPastEvents</code> function on web3 contracts.</p> <p>This function has parameters <code>fromBlock</code> and <code>toBlock</code> so the caller has to keep track of which blocks have already been requested.</p> <p>The number of blocks the user can request in a single RPC call depends on the configuration of the RPC node being used. In particular, if the node is run with the environment variable <code>WEB3_API</code> set to <code>debug</code> (a so-called \"full node\"), usually 100 blocks of events can be read in one call. On the other hand, if <code>WEB3_API</code> is set to <code>enabled</code> (a \"light node\") only 1 block of events can be read.</p>"},{"location":"dev/tutorials/network-access/transaction-finalization/","title":"Checking Transaction Finalization","text":"<p>On Flare and Songbird, obtaining the receipt of a submitted transaction does not guarantee that the transaction is finalized. One has to wait until the sender's account nonce (the total number of sent transactions) increases.</p> <p>The following function shows how to send a signed transaction and wait for its finalization.</p> <p>The function polls the current nonce up to 8 times before giving up, using an exponential backoff. This means that the time spent between successive polls of the nonce is increased exponentially to avoid taxing the network too much.</p> <pre><code>async function sendAndFinalize(senderAddress, signedTx, delay = 1000) {\n  let oldNonce = await web3.eth.getTransactionCount(senderAddress);\n  let receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction)\n  let backoff = 1.5;\n  let maxRetries = 8;\n  while ((await web3.eth.getTransactionCount(senderAddress)) == oldNonce) {\n    await new Promise((resolve) =&gt; {setTimeout(()=&gt;{resolve()}, delay)})\n    maxRetries--;\n    if(maxRetries == 0) {\n      throw new Error(\"Response timeout\");\n    }\n    delay = Math.floor(delay * backoff);\n  }\n  return receipt;\n}\n</code></pre>"},{"location":"exchange/","title":"Exchange Guides","text":"<p>This section contains information and bits of advice for Exchanges willing to support the Flare blockchain.</p> <p>The first thing you should know is that:</p> <p>Flare is used just like Ethereum!</p> <p>Even though the node code is different, Flare offers the same API as Ethereum so you can integrate with it in the same way.</p> <ul> <li>Deploy a Flare Observer node to access the network.</li> <li>Use the appropriate Chain ID.</li> <li>Use standard Ethereum libraries like web3.js if you want.</li> </ul>"},{"location":"exchange/#quick-information-about-flare","title":"Quick Information about Flare","text":"Website address flare.network Brand assets Google Drive Rosetta API endpoint <code>https://flare-rosetta-api.flare.network/</code> Node source code github.com/flare-foundation/flare Node installation documentation docs.flare.network/infra/observation/deploying Node requirements 8 CPU, 16 GB RAM, 2 TB disk space Maximum block rate 1 block/second. Token names <code>FLARE</code>, <code>SONGBIRD</code> Tickers <code>FLR</code>, <code>SGB</code> Tokens precision 18 decimal places Supported wallets docs.flare.network/user/wallets <p>Network configuration information, including:</p> <ul> <li>Flare Networks Configuration Values</li> <li>RPC Nodes for Connected Chains</li> </ul> <p>Note</p> <p>The <code>$FLR</code> and <code>$SGB</code> tokens are not ERC-20 tokens: they are the native currency of Flare (the Main network) and Songbird (The Canary network) respectively. As such, these tokens are handled the same way <code>$ETH</code> is handled on the Ethereum blockchain.</p> <p>Select one of the topics below:</p> <ul> <li>Architecture of an Exchange</li> <li>Delegating on the User's Behalf</li> <li>Troubleshooting Guide</li> </ul>"},{"location":"exchange/architecture/","title":"Architecture of an Exchange","text":"<p>What follows is the suggested architecture for a centralized Exchange. Even if your Exchange does not adopt this exact design, it defines the concepts that are used throughout the other pages in this section.</p>"},{"location":"exchange/architecture/#general-structure","title":"General Structure","text":"<p>The suggested architecture uses a Central Exchange wallet with multiple User reception wallets controlled by the Exchange.</p> <p> </p> General structure of an Exchange."},{"location":"exchange/architecture/#exchanges-central-wallet-hot","title":"Exchange's Central Wallet (Hot)","text":"<p>This account contains the Exchange's funds required to perform user operations: Users' deposits are ultimately routed here, and users' withdrawals are taken from here.</p> <p>The private keys to this account need to be on an online machine (the Exchange server) so this is considered a hot wallet. For security reasons, it is recommended that the hot wallet only contains enough funds to perform daily operations, whereas the bulk of the funds are kept in the cold wallet.</p>"},{"location":"exchange/architecture/#exchanges-central-wallet-cold","title":"Exchange's Central Wallet (Cold)","text":"<p>The private keys to this account are kept in an offline machine so it is less vulnerable to attacks. Moreover, it is recommended that this is a multi-signature account so the approval of more than one administrator is required to move funds from it.</p> <p>Periodically (e.g., once a day) funds are transferred from or to the hot wallet so it can continue operating while the bulk of the funds are protected in the cold wallet.</p>"},{"location":"exchange/architecture/#users-reception-wallets","title":"Users' Reception Wallets","text":"<p>When users sign up with the Exchange, a reception wallet is created for them in order to perform deposits. The reception wallets are usually empty: as soon as they receive funds these are transferred to the Exchange's hot wallet.</p> <p>The private keys to the reception wallets always remain under the Exchange's control; these wallets are offered to users as a convenience only. Users cannot perform any operation on these wallets other than deposits.</p>"},{"location":"exchange/architecture/#users-wallet","title":"User's Wallet","text":"<p>This is the origin of deposits made to the Exchange and the receiver of withdrawals made from the Exchange. It can be a wallet in control of the user (the user holds its private key), a custodial wallet or another Exchange, for example.</p>"},{"location":"exchange/architecture/#exchange-server","title":"Exchange Server","text":"<p>This is an online server, part of the Exchange's infrastructure, that receives withdrawal requests from users and monitors the reception wallets to detect incoming deposits. It holds the private keys to the hot wallet and to all the reception wallets so it can move funds from them in response to user's requests.</p> <p>Warning</p> <p>This server must be available 24/7 so it is a clear target for malicious actors.</p>"},{"location":"exchange/architecture/#balances-db","title":"Balances DB","text":"<p>This database keeps track of every user's funds, since the actual tokens from all users are pooled together in the hot and cold wallets.</p> <p>The Exchange server updates this DB in response to user's deposits and withdrawals.</p>"},{"location":"exchange/architecture/#flare-observer-node","title":"Flare Observer Node","text":"<p>An observer node is a regular Flare node that does not partake in consensus but is still aware of the current state of the blockchain and allows submitting transactions. It is highly recommended that Exchanges deploy their own observer nodes to access the network, instead of relying on third-party services. Read the Deploying an Observer Node guide to learn how to do this.</p>"},{"location":"exchange/architecture/#detecting-deposits","title":"Detecting Deposits","text":"<p>The Exchange server must be continuously monitoring transfers into ALL reception wallets to detect incoming deposits. Here's a summary of the process:</p> <p> </p> Depositing to an Exchange. <ol> <li> <p>The user deposits (transfers) funds to their assigned reception wallet.</p> </li> <li> <p>The transaction is detected by the Exchange server monitoring the wallets.</p> <p>The server can discover a new transaction as soon as it is submitted by subscribing to the <code>pendingTransactions</code> event. This allows showing the transaction as \"pending\" in the UI, but there is still a chance that it is reverted.</p> <p>To avoid problems, the Exchange should only act on transactions appearing on blocks old enough for the chance of them being reverted to be negligible. This can be done by subscribing to the <code>newBlockHeaders</code> event and examining the transactions in a previous block (for example, 5 blocks behind).</p> <p>The code below exemplifies this process (See the web3.js documentation for the API details):</p> <pre><code>// https://web3js.readthedocs.io\nconst Web3 = require('web3');\n\n// Use your own node URL\n// https://docs.flare.network/dev/reference/coston-testnet/\nconst web3 = new Web3(\"wss://coston-api.flare.network/ext/bc/C/ws\");\n\n// Use your receiving wallet address\nconst receivingAddress = \"0x947c76694491d3fD67a73688003c4d36C8780A97\";\n\nweb3.eth.subscribe(\"pendingTransactions\")\n.on(\"data\", async (transactionHash) =&gt; {\n    // New transaction hash received.\n    // Retrieve the actual transaction.\n    let tx = await web3.eth.getTransaction(transactionHash);\n    // If it is directed to our address...\n    if (tx.to === receivingAddress) {\n        // Mark it as pending.\n        console.log(\"Transaction\", tx.hash, \"is pending\");\n    }\n}).on(\"error\", console.error);\n\nweb3.eth.subscribe(\"newBlockHeaders\")\n.on(\"data\", async (blockHeader) =&gt; {\n    // New block has been produced.\n    // Retrieve a block old enough to be considered confirmed.\n    let block = await web3.eth.getBlock(blockHeader.number - 5);\n\n    // Get all its transactions.\n    block.transactions.forEach(async (transactionHash) =&gt; {\n        // Retrieve the actual transaction.\n        let tx = await web3.eth.getTransaction(transactionHash);\n        // If it is directed to our address...\n        if (tx.to === receivingAddress) {\n            // Mark it as confirmed.\n            console.log(\"Transaction\", tx.hash,\n                \"is confirmed in block\", block.number);\n        }\n    });\n}).on(\"error\", console.error);\n</code></pre> <p>Warning</p> <p>Note that all transactions from a block are retrieved simultaneously and this can easily trigger a rate limit on the node. A proper implementation should avoid this by serializing requests or managing the request rate manually.</p> </li> <li> <p>The server then checks the wallet address to find which user account it belongs to, and adds the received amount to the user's balance.</p> </li> <li> <p>The server announces a transaction to the network (through the Exchange's own observer node) to move the received funds to the hot wallet.</p> <p>See a JavaScript example in the Ethereum documentation. Since you will be using your own node, you can skip the Alchemy part and directly use the <code>web3</code> package as in the example above.</p> </li> <li> <p>The received funds are transferred to the hot wallet when the transaction is approved by the network. The reception wallets always remain empty.</p> </li> </ol>"},{"location":"exchange/architecture/#performing-withdrawals","title":"Performing Withdrawals","text":"<p>Users must request withdrawals directly to the Exchange server through its user interface. After checking that the user has the required balance, the funds are transferred from the Exchange's hot wallet directly to the user's wallet. Here's a summary of the process:</p> <p> </p> Withdrawing from an Exchange. <ol> <li> <p>The user requests a withdrawal to the Exchange server. The request includes some kind of user ID, the requested amount and the destination wallet's address.</p> </li> <li> <p>The server checks that the user has the required balance to perform the withdrawal.</p> </li> <li> <p>The server announces a transaction to the network (through the Exchange's own observer node) to move the requested funds from the hot wallet to the requested destination address.</p> <p>See a JavaScript example in the Ethereum documentation. Since you will be using your own node, you can skip the Alchemy part and directly use the <code>web3</code> package as in the example above.</p> <p>Warning</p> <p>Please make sure you sign the transaction before submitting it, as shown in the example. Unsigned transactions are ignored by the network.</p> </li> <li> <p>The requested funds are transferred to the user's wallet when the transaction is approved by the network.</p> </li> </ol>"},{"location":"exchange/delegation/","title":"Delegating on the User's Behalf","text":"<p>Delegation is one of the multiple ways in which the Flare blockchain rewards participants of the ecosystem. In particular, delegation allows token holders to put their stake behind an FTSO data provider to increase its relative weight (See the FTSO page for more information). In return, each time a data provider submits useful information it shares its reward with all the token holders that delegated to it.</p> <p>The Delegation Guide details this process for users. However, since Exchanges keep user's tokens, only Exchanges can perform delegation. If you are an Exchange and want to offer your users the ability to earn rewards by delegation, this page summarizes the process and explains how to perform it on the user's behalf.</p>"},{"location":"exchange/delegation/#introduction","title":"Introduction","text":"<p>Flare (and Songbird) accounts can delegate any percentage they choose of their tokens to one or two FTSO data providers.</p> <p>This limitation means that, if your Exchange keeps all users' tokens in a single wallet (as described in the Architecture of an Exchange page), you cannot give your users the option to select the data provider they want to delegate to: The wallet containing all tokens can only delegate to one (or two) data providers.</p> <p>Keeping this in mind, this page explains how to delegate the users' tokens and collect the rewards.</p> <p>Reward Epochs</p> <p>As shown later, several features of the delegation mechanism are timed in Reward Epochs.</p> <ul> <li>On Songbird, these epochs last 7 days and start every Saturday at around 8:40AM UTC.</li> <li>On Flare, they last 3.5 days and start roughly every Monday at 7:00 UTC and Thursday at 19:00 UTC.</li> </ul>"},{"location":"exchange/delegation/#selecting-a-data-provider","title":"Selecting a Data Provider","text":"<p>It is the Exchange that must select the FTSO data provider upon which to delegate, so the first step is to choose the one you are most confident to provide consistently good data (and therefore higher rewards).</p> <p>Anyone can become an FTSO data provider, but only the ones that had the most voting power during the previous reward epoch are available for delegation.</p> <p>The list of available data providers for the current reward epoch can be retrieved from the <code>VoterWhitelister</code> smart contract, method <code>getFtsoWhitelistedPriceProviders</code>. There exist a number of websites like flaremetrics.io or ftso-signal-providers that display this information in a far more convenient way.</p> <p>Note</p> <p>Data providers take a fee before sharing their rewards with their delegators. An Exchange can decide to run its own data provider to avoid paying this fee to an external entity, at the cost of having to develop a good price prediction algorithm.</p> <p>Keep in mind that FTSO data providing is already a very competitive business, and only the most successful algorithms are being rewarded.</p> <p>Lastly, delegations can be changed at any time, but they are only taken into account once per reward epoch (See more details in the FTSO page). Therefore, depending on the time it is submitted, a new delegation will not take effect until the beginning of the next reward epoch, or the one after that. Furthermore, rewards cannot be collected until another reward epoch has elapsed.</p>"},{"location":"exchange/delegation/#delegation-process","title":"Delegation Process","text":"<p>See Manual Delegation and Claiming in the FTSO page.</p>"},{"location":"exchange/troubleshooting/","title":"Troubleshooting Guide","text":"<p>This page contains links to other sections answering the most common support requests received when integrating with the Flare network.</p> <ul> <li> <p>Regarding Node Deployment</p> </li> <li> <p>Regarding Delegation</p> </li> <li> <p>Regarding Reward Claiming</p> </li> </ul>"},{"location":"infra/","title":"Infrastructure Guides","text":"<p>This section contains step-by-step guides on how to deploy the different components that make up the Flare ecosystem, and be rewarded for it.</p> <p>Select one of the topics below:</p> <ul> <li>Becoming an Attestation Provider</li> <li>FTSO Data Providers</li> <li>Observer Nodes</li> <li>Validator Nodes</li> </ul>"},{"location":"infra/attestation/","title":"Attestation Providers","text":"<p>The following guides explain how to provide the infrastructure required for the State Connector.</p> <p>Select one of the guides below:</p> <ul> <li>Operating an Attestation Provider</li> </ul>"},{"location":"infra/attestation/operating/","title":"Operating an Attestation Provider","text":"<p>Anyone can operate an attestation provider without any capital requirement (see the attestation-client repository for deployment information), which can readily be used as a local provider on validators that trust it.</p> <p>To be included in the default set, though, the same operator must run one of the top-performing FTSO data providers to prove its commitment to the network's well-being. More details will be added soon.</p>"},{"location":"infra/data/","title":"FTSO Data Providers","text":"<p>These guides explain how to manage the infrastructure required for the FTSO system.</p> <p>Select one of the guides below:</p> <ul> <li>Operating a Data Provider</li> <li>Working with Whitelists</li> <li>Managing the Ecosystem</li> </ul>"},{"location":"infra/data/operating/","title":"Operating a Data Provider","text":""},{"location":"infra/data/operating/#introduction","title":"Introduction","text":"<p>Quick links</p> <ul> <li>NPM Kickoff package</li> <li>Reference implementation</li> </ul> <p>Data providers play an essential role in the decentralized oracle system by submitting data to on-chain contracts deployed on the Flare and Songbird networks. Operating a data provider generates rewards in <code>$FLR</code>, <code>$SGB</code>, or both for you and the people who delegate tokens to you. To maximize your rewards, your data provider needs to be constantly available and operating. If your data provider is unavailable and doesn't send data during a specific epoch, you and your delegators won't earn rewards during that epoch.</p> <p>If all the submission and reveal transactions are successful, the cost is approximately 3 - 4 <code>$FLR</code> or <code>$SGB</code> per day.</p> <p>Data providers consist of the following code components, and you can write them in any language:</p> <ul> <li>FTSO interface: The code that submits data to the FTSO.   This code is all the necessary logic to determine which data epoch you want to submit data in and to assess when and what to submit throughout all reward epochs.</li> <li>Data algorithm: The code that runs the algorithm that collects and processes data.   The more efficient this code is the better advantage over competing data providers you will have.   Consider these tips for maximizing your advantage.</li> </ul> <p>The rest of this guide explains how to deploy and operate a data provider.</p>"},{"location":"infra/data/operating/#prerequisites","title":"Prerequisites","text":"<p>While none of the listed prerequisites are required, you will be more successful if you have them before you try to deploy an FTSO data provider:</p> <ul> <li>Familiarity with smart contracts, signal processing, game theory, and prompt data submission on blockchains</li> <li> <p>Experience with a coding language that has a web3 library, for example:</p> Language Web3 Library Go go-web3 Java web3.j JavaScript ethers.js, web3.js Node.js ethers.js, web3.js Python web3.py Rust rust-web3 </li> </ul>"},{"location":"infra/data/operating/#getting-started","title":"Getting Started","text":"<p>To start building your data provider, use the npm kick-off package. It showcases the main contracts related to whitelisting a data provider and submitting data, and it enables you to deploy FTSO mock contracts in a local setup and submit data to those contracts.</p> <p>Providing data by using this package is like providing data on-chain. The following aspects work identically in the package and on-chain:</p> <ul> <li>Smart-contract APIs</li> <li>Events</li> </ul> <p>Timing aspects in the package work similarly but not identically to timing aspects on-chain. The package does not run the weighted-median algorithm or do calculations to distribute rewards like the FTSO smart contract deployed on-chain does.</p> <p>The Flare Network price provider repository shows an example of a data-provider implementation. This implementation shows the FTSO interface and a sample data algorithm. To earn rewards, you must write your own data algorithm.</p>"},{"location":"infra/data/operating/#interacting-with-smart-contracts","title":"Interacting with Smart Contracts","text":"<p>Data providers interact primarily with the <code>PriceSubmitter</code> contract and the different <code>FTSO</code> contracts. Other useful contracts are:</p> <ul> <li><code>FtsoRegistry</code>: Holds information about specific FTSOs, their symbols, indices, and addresses.   To see supported tickers, query the <code>getSupportedSymbols</code> method.   New tickers can be added by a governance vote.</li> <li><code>FtsoManager</code>: Holds epoch and voting-related configuration data, oversees all FTSOs, and gives access to additional useful contracts, such as the <code>Inflation</code> and <code>Supply</code> contracts.</li> <li><code>VoterWhitelister</code>: Accepts the names of data providers that list themselves to submit data.</li> </ul> <p>Find these contract's addresses in the Contract Addresses page.</p>"},{"location":"infra/data/operating/#generating-random-numbers","title":"Generating Random Numbers","text":"<p>The data-providing process is structured as a commit-and-reveal scheme to prevent users from copying another user's submitted data. The commit-and-reveal phases are restricted to only a few minutes in duration. With each reveal the data provider also provides a random number. The random number is used first as a salt in the commit-and-reveal scheme and later during the reward calculation process.</p> <p>Strong random numbers are important for network security because they are the only true source of randomness on the network, and they make the commit-and-reveal scheme resilient to attacks. Random numbers below 2<sup>128</sup> are considered weak and unsafe, and they are rejected when they are revealed.</p> <p>To provide strong, cryptographically secure, random numbers with high entropy and sufficient range, consider implementing the following strategies:</p> <ul> <li>Use available random-number generators, such as the <code>csprng library</code> for Node.js applications or the <code>web3.utils.toBN(web3.utils.randomHex(32))</code> function in the <code>web3.utils</code> package for JavaScript.</li> <li>Submit 256-bit random numbers.</li> </ul>"},{"location":"infra/data/operating/#calculating-hash-for-the-commit-and-reveal-scheme","title":"Calculating Hash for the Commit-and-Reveal Scheme","text":"<p>The FTSO price provider shows the complete specification for the commit-and-reveal scheme.</p> <p>The following code snippets show how to generate hashes in Typescript and Python using publicly available web3 libraries:</p> TypescriptPython <pre><code>import BN from \"bn.js\";\nimport {\n    BigNumber\n} from \"ethers\";\nimport {\n    ethers\n} from \"hardhat\";\nconst MIN_RANDOM = web3.utils.toBN(2).pow(web3.utils.toBN(128));\n\nfunction submitHash(ftsoIndices: (number | BN | BigNumber)[],\n    prices: (number | BN | BigNumber)[],\n    random: number | BN | BigNumber,\n    address: string): string {\n\n    return ethers.utils.keccak256(web3.eth.abi.encodeParameters(\n        [\"uint256[]\", \"uint256[]\", \"uint256\", \"address\"],\n        [ftsoIndices, prices, random, address]));\n}\nconst ftsoIndices = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst randoms = [MIN_RANDOM, MIN_RANDOM.addn(5), MIN_RANDOM.addn(1059),\n    MIN_RANDOM.addn(10682), MIN_RANDOM.addn(159726)\n];\nconst prices = [0, 1, 2, 3, 5, 10, 50, 100, 101, 10 ** 5 + 1, 10 ** 8];\nconst addrs = [accounts[10], accounts[11], accounts[12], accounts[13]];\n\nconsole.log(`Prices: ${prices}`);\nfor(let addr of addrs) {\n    console.log(`Address: ${addr}`);\n    for(let random of randoms) {\n        console.log(`\\tRandom: ${random}`)\n        const hash = submitHash(ftsoIndices, prices, random, addr);\n        console.log(`\\t\\t${hash}`);\n    }\n}\n</code></pre> <pre><code>from typing import List\nfrom web3 import Web3\nimport eth_abi\n\nminimal_random = 2 ** 128\n\ndef submit_price_hash(\n    ftsoIndices: List[int], prices: List[int], random: int, address: str\n) -&gt; str:\n    assert len(ftsoIndices) == len(prices)\n    assert list(sorted(ftsoIndices)) == ftsoIndices and len(\n        set(ftsoIndices)\n    ) == len(ftsoIndices), \"Indices are non increasing\"\n    return Web3.keccak(\n        eth_abi.encode_abi(\n            [\"uint256[]\", \"uint256[]\", \"uint256\", \"address\"],\n            [ftsoIndices, prices, random, address],\n        )\n    ).hex()\n\n\ndef test_fun(\n    prices: List[int],\n    random: int,\n    address=\"0xD7de703D9BBC4602242D0f3149E5fFCD30Eb3ADF\",\n) -&gt; List[str]:\n    return submit_price_hash(list(range(len(prices))), prices, random, address)\n\n\naddrs = [\n    \"0xD7de703D9BBC4602242D0f3149E5fFCD30Eb3ADF\",\n    \"0xEa960515F8b4C237730F028cBAcF0a28E7F45dE0\",\n    \"0x3d91185a02774C70287F6c74Dd26d13DFB58ff16\",\n]\nprices = [0, 1, 2, 3, 5, 10, 50, 100, 101, 10 ** 5 + 1, 10 ** 8]\nrandoms = [\n     min_random + r for r in\n     [0, 1, 100, 101, 100000000000000000000]\n]\nfor addr in addrs:\n    print(f\"Address: {addr}\")\n    for rand in randoms:\n        print(f\"  Random: {rand}\")\n        print(\"    hash:\", test_fun(prices, rand, addr))\n    print()\n</code></pre> <p>Info</p> <p>To see sample code for calculating submit hashes using the <code>web3.py</code> library, see the <code>hasher.py</code> gist.</p>"},{"location":"infra/data/operating/#retrieving-information-about-rewarded-data","title":"Retrieving Information About Rewarded Data","text":"<p>Listen for <code>PriceFinalized</code> events, which contain information about calculated median data and rewarding bounds. Each FTSO emits these events.</p>"},{"location":"infra/data/operating/#managing-vote-power","title":"Managing Vote Power","text":"<ul> <li> <p>To check your vote power in a specific vote power block, use the  <code>votePowerOfAt</code> method in the <code>WNat</code> contract.</p> </li> <li> <p>To find the vote-power block of the current reward epoch, use the <code>getCurrentRewardEpoch</code> method in the <code>FtsoManager</code> contract.   Then, use the <code>getRewardEpochVotePowerBlock</code> method in the same contract.</p> </li> <li> <p>Vote power delegated to you belongs to only you; you cannot redelegate it.   To retrieve information about delegations you receive, listen to <code>Delegate</code> events because this information is not contained in any on-chain structure.</p> </li> </ul>"},{"location":"infra/data/operating/#retrieving-price-epoch-information","title":"Retrieving Price Epoch Information","text":"<p>Use the <code>getPriceEpochConfiguration</code> method in the <code>FtsoManager</code> contract to retrieve:</p> <ul> <li>When the first price epoch started, as a UNIX timestamp.</li> <li>The duration of every price epoch, in seconds.</li> <li>The duration of every reveal phase, in seconds.</li> </ul> <p>These numbers allow you to calculate the price epoch number from any timestamp.</p> <p>The duration of price epochs is fixed and can only change through a governance decision.</p>"},{"location":"infra/data/operating/#submitting-data-on-chain","title":"Submitting Data On-Chain","text":"<p>After you feel comfortable running the local npm package, you can start submitting your data on the real network.</p> <p>To run on the real network, you need to:</p> <ul> <li>Gain vote power: You can whitelist yourself as a data provider only if you have enough vote power.</li> <li>Optimize your timing:<ul> <li>Align with the on-chain time data.     Because the network is decentralized, the on-chain timestamp might skew up to 30 - 40 seconds from the real-world time.     To avoid missing commit-and-reveal periods, synchronize local time with global time through the Network Time Protocol (NTP).</li> <li>The later you submit, the more time you have to gather data.     However, if you submit too late, you might miss the epoch window.     Find the balance that works best for you.</li> </ul> </li> <li>Claim rewards: Ensure you regularly claim your rewards and wrap them to earn more vote power. Each FTSO emits a <code>PriceFinalized</code> event that contains information about calculated median data and rewarding bounds.</li> <li>Set the gas limit of your commit-and-reveal transactions to around 2'500'000 gwei so that you provide enough gas.</li> </ul>"},{"location":"infra/data/operating/#maximizing-your-data-algorithms-performance","title":"Maximizing Your Data Algorithm's Performance","text":"<p>Use the following tips:</p> <ul> <li>Run your own observer node and submit all your data through it.   This will allow you to more efficiently and securely operate your data provider.</li> <li>Gather your data directly from each source instead of using APIs provided by data aggregators.</li> <li>Write your own code instead of relying entirely on third-party code.</li> <li>Keep an open mind, and try new strategies to find your advantage over other data providers and keep it.</li> </ul> <p>If your submissions are reverted, ensure the node you submit them through is healthy and has enough peers, and review the above tips.</p>"},{"location":"infra/data/whitelisting/","title":"Working with Whitelists","text":""},{"location":"infra/data/whitelisting/#introduction","title":"Introduction","text":"<p>To be a data provider, you must be whitelisted. Only the top 100 data providers with the most vote power per FTSO can submit data. No minimum amount of vote power is required. Per FTSO, a data provider's vote power is based on its balance of <code>$WFLR</code> or <code>$WSGB</code>. When a data provider tries to whitelist itself, its vote power is calculated by the vote-power block of the current reward epoch. Increased vote power on a different block will not enable your address to be whitelisted. Vote power is only read and whitelists updated once per reward epoch. Reward epochs start roughly on Saturdays at 8:40AM UTC on Songbird, and on Monday at 7:00 UTC and Thursday at 19:00 UTC on Flare. Whitelisting a data provider is a fully decentralized process facilitated by the <code>VoterWhitelister</code> contract. To retrieve this contract, see Contract Addresses.</p> <p>To be added to the whitelist, submit a request for your address by using one of the functions listed in the next section. When the whitelist is not full, your address is immediately added to it. If both the list is full and your vote power is greater than the data provider with the lowest vote power, your address replaces that data provider's address on the whitelist.</p> <p>If the number of spaces for data providers is ever reduced by governance, addresses will be removed from the whitelist one by one, beginning with the address with the lowest vote power.</p> <p>Events are emitted to notify providers about changes of their status on the whitelist. Once an address is delisted, submissions will also start reverting.</p>"},{"location":"infra/data/whitelisting/#requesting-to-be-added-to-the-whitelist-or-relisted","title":"Requesting to be Added to the Whitelist or Relisted","text":"<p>Use the following methods in the <code>VoterWhitelister</code> contract:</p> <ul> <li><code>requestWhitelistingVoter()</code>: Requests whitelisting for a specific asset index.</li> <li><code>requestFullVoterWhitelisting()</code>: Requests whitelisting for all assets.</li> </ul> <p>Ensure you have more delegations and vote power than the data provider that has the lowest amount before the vote power block is chosen and before you submit the request to be relisted.</p>"},{"location":"infra/data/whitelisting/#reading-whitelists","title":"Reading Whitelists","text":"<p>Each FTSO contains an array of whitelisted addresses. Use the functions in the following contracts to determine whether you are on the list and eligible to submit data:</p> <ul> <li> <p><code>VoterWhitelister</code> contract</p> <p>The <code>getFtsoWhitelistedPriceProviders</code> function returns a list of addresses for all data providers on the whitelist. Specify the required index, run the query, and search for your address.</p> </li> <li> <p><code>PriceSubmitter</code> contract</p> <p>The <code>voterWhitelistBitmap</code> function returns a bitmap corresponding to allowed FTSO indices in big-endian format. Specify your address, run the query and examine the returned bitmap. E.g., if you were allowed to submit prices for FTSOs with indices 0, 2 and 3, the returned bitmap would be 13 (<code>1101</code> in binary).</p> </li> </ul>"},{"location":"infra/data/whitelisting/#monitoring-your-whitelist-status","title":"Monitoring Your Whitelist Status","text":"<p>When you are added to a whitelist, the <code>VoterWhitelisted</code> event is emitted from the <code>VoterWhitelister</code> contract. When you are removed from a whitelist, the <code>VoterRemovedFromWhitelist</code> event is emitted, and your subsequent submissions fail. To stay aware of your whitelist status, consider listening to events that notify you about additions and removals when they happen.</p>"},{"location":"infra/data/managing-ecosystem/","title":"Managing the Ecosystem","text":"<p>The following information explains how to manage the FTSO ecosystem by participating in the FTSO Management Group, as described in FIP.02, which was accepted on March 6, 2023.</p> <p>To prevent malicious behaviors that impair the FTSO ecosystem, the FTSO Management Group reports possible infractions committed by FTSO data providers and determines whether to punish them.</p> <p>Punished data providers are chilled, which means they are removed from the whitelist, either temporarily or permanently, depending on the quantity of infractions they have committed.</p> <p>Any address can request to be a member of the group, but only upstanding FTSO data providers are accepted.</p> <p>As a security measure to be used only when absolutely necessary, the Flare Foundation reserves the right to add and remove members on its own accord.</p>"},{"location":"infra/data/managing-ecosystem/#management-process","title":"Management Process","text":"<p>The group adheres to the following management process. For complete details about each step in the process, click each hyperlink.</p> <ol> <li>Discuss possible infractions (section 2.2.1).</li> <li>Submit a chill proposal (section 2.2.2).</li> <li>Vote on the proposal (sections 2.2.2 - 2.2.4).</li> </ol> <p>Depending on the outcome of the vote, the provider might be chilled (section 2.3).</p>"},{"location":"infra/data/managing-ecosystem/#discussing-infractions","title":"Discussing Infractions","text":"<p>When you suspect a data provider is harming the ecosystem, you must discuss the malicious behavior with other group members in the Flare FTSO Self-Policing Forum to inform the FTSO community about the problem and gather the necessary quorum for a potential vote. It facilitates the decision about whether to submit a formal proposal to chill the attacker. The discussion is not binding.</p>"},{"location":"infra/data/managing-ecosystem/#retrieving-the-pollingftso-contract","title":"Retrieving the <code>PollingFtso</code> contract","text":"<p>The <code>PollingFtso</code> contract handles interactions such as managing group members, submitting proposals, voting, and more. The following procedure explains how to interact directly with this contract. However, if you prefer a simpler interface, the Flare community is developing front-ends to facilitate the interactions, such as Flaremetrics.</p> <ol> <li>Open a block explorer for the appropriate network.</li> <li>Follow the Retrieval from Blockchain procedure to find and open the <code>PollingFtso</code> contract.     The Contract Address Details page is displayed.</li> <li>Optional: If you need to call a method in the Write tab, click the Write Contract tab, click Connect Wallet, and complete the steps to connect your wallet.</li> </ol> <p>After the <code>PollingFtso</code> contract is open in the explorer, you can complete operations to manage members and chill proposals.</p>"},{"location":"infra/data/managing-ecosystem/#managing-group-members","title":"Managing Group Members","text":"<p>To be a member you need to be an upstanding data provider, which means:</p> <ul> <li>You have received FTSO rewards for the last 20 reward epochs.</li> <li>You have not been chilled in the last 20 reward epochs.</li> <li>You have not been removed from the group in the last week.</li> </ul> <p>After the <code>PollingFtso</code> contract is open in the explorer, you can do the following operations, among others.</p>"},{"location":"infra/data/managing-ecosystem/#adding-members","title":"Adding Members","text":"<p>Anyone can request to become a member of the FTSO Management Group.</p> <ol> <li>In the Write tab, locate the <code>addMember</code> method, and click Write to call it.</li> <li> <p>Follow the steps to complete the transaction in your wallet.</p> <p>Your request to be added to the group is submitted. If you meet the conditions of an upstanding data provider, you are automatically added to the group.</p> </li> </ol>"},{"location":"infra/data/managing-ecosystem/#removing-members","title":"Removing Members","text":"<p>Anyone can ask for a member of the FTSO Management Group to be removed.</p> <ol> <li> <p>In the Write tab, locate the <code>removeMember</code> method, and specify a value for this parameter:</p> <ul> <li><code>_account(address)</code>: The address of the member you want to remove from the group.</li> </ul> </li> <li> <p>Click Write to call the <code>removeMember</code> method.</p> </li> <li> <p>Follow the steps to complete the transaction in your wallet.</p> <p>Your request to remove a member from the group is submitted. If the member no longer meets the conditions of an upstanding data provider, the member is immediately removed.</p> </li> </ol>"},{"location":"infra/data/managing-ecosystem/#managing-chill-proposals","title":"Managing Chill Proposals","text":"<p>After the <code>PollingFtso</code> contract is open in the explorer, you can do the following operations, among others.</p>"},{"location":"infra/data/managing-ecosystem/#submitting-a-proposal","title":"Submitting a Proposal","text":"<p>If you are a member of the FTSO Management Group or a member's proxy, you can submit a chill proposal.</p> <ol> <li> <p>In the Write tab, locate the <code>propose</code> method, and specify values for these parameters:</p> <ul> <li><code>_description(string)</code>: A free-form description of the problem to be voted on.     It does not have a fixed structure, but it must contain at least the URL for the discussion in the forum (section 2.2.2.d)</li> <li><code>value(FLR or SGB)</code>: The cost to call the <code>propose</code> method to submit the proposal, which you must specify as the value. The current cost is 100 <code>$FLR</code> or <code>$SGB</code>. Because this cost can fluctuate, retrieve the current cost by locating the <code>proposalFeeValueWei</code> method in the Read tab, which automatically displays the cost.</li> </ul> </li> <li> <p>Click Write to call the <code>propose</code> method.</p> </li> <li> <p>Follow the steps to complete the transaction in your wallet.</p> <p>Your proposal is submitted, and the <code>proposalId</code> is returned.</p> </li> <li> <p>Post the <code>proposalId</code> in the discussion thread so that members of the group can use it to vote on the proposal.</p> </li> </ol>"},{"location":"infra/data/managing-ecosystem/#voting-on-a-proposal","title":"Voting on a Proposal","text":"<p>You can vote on a proposal when the following conditions are met:</p> <ul> <li>You are a member of the FTSO Management Group or a member's proxy.</li> <li>The proposal is active.</li> </ul> <p>To vote on a proposal:</p> <ol> <li> <p>In the Write tab, locate the <code>castVote</code> method, and specify values for these parameters:</p> <ul> <li><code>_proposalId(uint256)</code>: The proposal ID posted by the proponent in the discussion thread.     This ID was obtained by proponent when the proposal was submitted. If you specify nonexistent IDs or IDs for proposals that have completed, the transaction reverts, and the explorer returns empty results.</li> <li> <p><code>_support(uint8)</code>: Specify one of the following values.</p> <ul> <li><code>0</code>: Vote against the proposal.</li> <li><code>1</code>: Vote in favor of the proposal.</li> </ul> <p>If you specify values other than <code>0</code> or <code>1</code>, the transaction reverts.</p> </li> </ul> </li> <li> <p>Click Write to call the <code>castVote</code> method.</p> </li> <li> <p>Follow the steps to complete the transaction in your wallet.</p> <p>Your vote is cast.</p> </li> </ol>"},{"location":"infra/data/managing-ecosystem/#setting-a-proxy-voter","title":"Setting a Proxy Voter","text":"<p>If you are a member of the group, you can declare one address that can manage proposals and vote on them on your behalf. This address is known as your proxy. Your proxy can submit proposals and vote on them.</p> <ol> <li> <p>In the Write tab, locate the <code>setProxyVoter</code> method, and specify the value for this parameter:</p> <ul> <li><code>_proxyVoter(address)</code>: The address you want to declare as your proxy.</li> </ul> </li> <li> <p>Click Write to call the <code>setProxyVoter</code> method.</p> </li> <li> <p>Follow the steps to complete the transaction in your wallet.</p> <p>The specified address is set as your proxy voter.</p> </li> </ol>"},{"location":"infra/data/managing-ecosystem/#removing-a-proxy-voter","title":"Removing a Proxy Voter","text":"<ol> <li> <p>In the Write tab, locate the <code>setProxyVoter</code> method, and specify the value for this parameter:</p> <ul> <li><code>_proxyVoter(address)</code>: Specify  the zero address <code>0x0000000000000000000000000000000000000000</code>.</li> </ul> </li> <li> <p>Click Write to call the <code>setProxyVoter</code> method.</p> </li> <li> <p>Follow the steps to complete the transaction in your wallet.</p> <p>The previously specified proxy address is revoked.</p> </li> </ol>"},{"location":"infra/data/managing-ecosystem/#determining-your-proxy-voters-address","title":"Determining Your Proxy Voter's Address","text":"<ol> <li> <p>In the Read tab, locate the <code>providerToProxy</code> method, and specify the value for this parameter:</p> <ul> <li><code>(address)</code>: The address that declared the proxy.</li> </ul> </li> <li> <p>Click Query to call the <code>providerToProxy</code> method.</p> <p>The address of the proxy voter is returned.</p> </li> </ol>"},{"location":"infra/data/managing-ecosystem/#retrieving-the-last-proposal","title":"Retrieving the Last Proposal","text":"<p>In the Read tab, locate the <code>getLastProposal</code> method.</p> <p>The number of the most recent proposal and its description are displayed.</p>"},{"location":"infra/data/managing-ecosystem/#retrieving-a-list-of-group-members","title":"Retrieving a List of Group Members","text":"<p>In the Read tab, locate the <code>getManagementGroupMembers</code> method.</p> <p>A list of the addresses of members is displayed.</p>"},{"location":"infra/data/managing-ecosystem/#retrieving-a-proposal-description","title":"Retrieving a Proposal Description","text":"<ol> <li> <p>In the Read tab, locate the <code>getProposalDescription</code> method, and specify the value for this parameter:</p> <ul> <li><code>proposalId(uint256)</code>: The ID of the proposal whose description you want.   If you don't know the proposal ID, refer to the proposal's discussion thread.</li> </ul> </li> <li> <p>Click Query to call the <code>getProposalDescription</code> method.</p> <p>The description of the specified proposal ID is returned. If you specified a nonexistent ID for the <code>proposalId</code> parameter, an empty string is returned.</p> </li> </ol>"},{"location":"infra/data/managing-ecosystem/#retrieving-a-vote-count","title":"Retrieving a Vote Count","text":"<ol> <li> <p>In the Read tab, locate the <code>getProposalVotes</code> method, and specify the value for this parameter:</p> <ul> <li><code>proposalId(uint256)</code>: The ID of the proposal whose vote count you want.   Proposal IDs are posted in its corresponding discussion thread.</li> </ul> </li> <li> <p>Click Query to call the <code>getProposalVotes</code> method.</p> <p>The number of votes in favor of the proposal and the number of votes against it are returned. If you specified a nonexistent ID for the <code>proposalId</code> parameter, <code>0</code> is returned as the number of votes for the proposal and as the number of votes against it.</p> </li> </ol>"},{"location":"infra/data/managing-ecosystem/#determining-a-members-vote-status","title":"Determining a Member's Vote Status","text":"<ol> <li> <p>In the Read tab, locate the <code>hasVoted</code> method, and specify the value for these parameters:</p> <ul> <li><code>proposalId(uint256)</code>: The ID of the proposal for which you want to determine a member's vote status.</li> <li><code>voter(address)</code>: The address of the member. If you do not know the address, refer to the list of addresses for all group members.</li> </ul> </li> <li> <p>Click Query to call the <code>hasVoted</code> method.</p> <p>A boolean value indicating whether the member has voted is returned. If you specified a nonexistent ID for the <code>proposalId</code> parameter, <code>false</code> is returned.</p> </li> </ol>"},{"location":"infra/data/managing-ecosystem/#related-guides","title":"Related Guides","text":"<ul> <li>Exploring Collusion</li> <li>Monitoring Price History</li> </ul>"},{"location":"infra/data/managing-ecosystem/exploring-collusion/","title":"Exploring Collusion","text":"<p>Members of the FTSO Management Group are responsible for monitoring the FTSO ecosystem for malicious behaviors, such as collusion. Collusion in the FTSO ecosystem is a problem for several reasons:</p> <ul> <li>It artificially raises the power of the colluding data providers, which endangers the quality of the FTSO data.</li> <li>It is specifically forbidden by FIP.02.</li> </ul> <p>In a healthy ecosystem, submissions from data providers are chasing the median, and they are close to the reward band. Collusion is possibly evident in this environment when multiple data providers submit similar data that is relatively distant from the median. To explore possible collusion between data providers in the ecosystem, use the collusion tool in the Flare FTSO Monitor.</p>"},{"location":"infra/data/managing-ecosystem/exploring-collusion/#collusion-tool-dashboard","title":"Collusion Tool Dashboard","text":"<p>The following image shows the dashboard of the collusion tool:</p> <p></p> FTSO Monitor Collusion Tool. <p>The elements of the collusion tool are:</p> <ul> <li>Threshold: Scans for the percentage of similarity that you want to see between the data providers for which you search.   Details about how to specify the percentage are in step 2 of the procedure to identify data providers.</li> <li>Search: Locates data providers within the FTSO ecosystem.   Details about how to specify names of data providers are in step 3 of the procedure to identify data providers.</li> <li>End time: Sets the date you want to view.</li> <li>Cluster map of data providers: Illustrates data providers that might be colluding by linking them with weighted connectors. The map is generated based on the data submitted during 00:00 - 24:00 UTC on the date you select in the End time field. Heavier weights suggest more potential for collusion than lighter weights.</li> </ul> <p>For example, the following image of part of the cluster map shows a pair of data providers weighted heavily enough to suggest a case of collusion.</p> <p></p> Heavily Weighted Data Providers."},{"location":"infra/data/managing-ecosystem/exploring-collusion/#identifying-colluding-data-providers","title":"Identifying Colluding Data Providers","text":"<p>For exploratory purposes only</p> <p>Use this tool only for exploratory purposes. Do not exclusively rely on this tool to infer that collusion has occurred.</p> <ol> <li>Open the collusion tool in the FTSO Monitor.    The collusion tool dashboard is displayed.</li> <li>In the Threshold field, specify the percentage of similarity you want to see.    For example, if you specify <code>.98</code>, 98% of the weakest similarities are omitted, and the strongest 2% of the similarities are displayed.</li> <li> <p>Use one of the following search methods:</p> <ul> <li>If you know the names of the data providers you want to compare, specify them in a comma-separated series in the Search field. The field is case-sensitive and accepts partial names of providers. For example, if you specify <code>FTSO</code>, the tool selects all providers that have FTSO in their names, regardless of case.</li> <li>In the cluster map, locate data provider nodes linked with heavily weighted connectors by zooming in. Zoom in and out by using the appropriate method on your device, such as spinning a mouse wheel. After you zoom in, you can center a node or a group of them on the screen by clicking the map and dragging it. Select at least two providers you want to compare by pressing and holding the Control key while you click each data provider node.</li> </ul> </li> <li> <p>Optional: Explore a previous date by changing the End time option to a date other than the current date.</p> </li> <li>Click Compare.    As shown in the following image, the Prices tab opens, displaying a line graph that shows the data submitted by each specified data provider during the most recent 30-minute interval on the date you selected in the End time field.</li> </ol> <p></p> Price History."},{"location":"infra/data/managing-ecosystem/exploring-collusion/#comparing-price-history","title":"Comparing Price History","text":"<p>In the price history, analyze the data for multiple providers consistently submitting prices that are distant from the median but near each other.</p> <p>In your analysis, consider anomalous situations, such as an exchange going offline, a vast region of the internet becoming disconnected, or a stablecoin depegging from its reference asset. In these situations, submitted data from providers is expected to be wildly different. If multiple providers still manage to submit similar data, carefully examine them.</p> <p>Although a depegged stablecoin should not affect FTSO prices, because price pairs use USD instead of a stablecoin, prices have been affected in the past, and the evidence is noticeable in the line graph. This situation reveals data providers who were using a stablecoin instead of USD in their submissions.</p> <p>As shown in the image in each tab below, additional details about the data providers and the submitted data are provided beneath the price-history dashboard. The details on Songbird are different from the details on Flare because of the secondary reward band implemented by STP.02.</p> <p>Use these details to more deeply explore the similarities between the data submitted by the providers you selected.</p> FlareSongbird <p> Details About Specified Data Providers. </p> <ul> <li>Address: The hexadecimal identifier of the data provider.   The circle beside the address corresponds with the address in the graph.   The correspondence between the circle and the address works for up to five addresses.</li> <li>Number of cases: The quantity of data samples during the specified interval.</li> <li>High: The percentage of samples above the reward band.</li> <li>Low: The percentage of samples below the reward band.</li> <li>Out: The total percentage of high combined with low.</li> <li>Border: The percentage of samples on the border of the reward band.</li> <li>Inner: The percentage of samples inside the reward band.</li> <li>Expected: The success rate of the data.   The value is represented as a percentage and calculated by the formula <code>Inner + 0.5(Border)</code>.</li> </ul> <p>In the following image, the percentage of samples are color-coded in the following ways:</p> <ul> <li>IQR reward band: Interquartile range percentages are blue.</li> <li>Pct reward band: Percentage range percentages are red.</li> </ul> <p> Details About Specified Data Providers. </p> <ul> <li>Address: The hexadecimal identifier of the data provider.   The circle beside the address corresponds with the address in the graph.   The correspondence between the circle and the address works for up to five addresses.</li> <li>Number of cases: The quantity of data samples during the specified interval.</li> <li>High: The percentage of samples above the reward bands.</li> <li>Low: The percentage of samples below the reward bands.</li> <li>Out: The total percentage of high combined with low.</li> <li>Border: The percentage of samples on the borders of the reward bands.</li> <li>Inner: The percentage of samples inside the reward bands.</li> <li>Expected: The success rate of the data.   The value is represented as a percentage and calculated by the formula <code>Inner + 0.5(Border)</code>.</li> </ul>"},{"location":"infra/data/managing-ecosystem/exploring-collusion/#the-similarity-metric","title":"The Similarity Metric","text":"<p>This section describes the similarity metric used to obtain the cluster map. To estimate collusion, the similarity metric assigns a value of similarity between data submitted by pairs of data providers. As previously stated, collusion between data providers is evident when they submit similar data that is relatively distant from the median because similar algorithms will make similar mistakes.</p> <p>For data providers DP1 and DP2 during a given range of price epoch for comparison, the prices <code>P1</code> and <code>P2</code> submitted for each cryptocurrency pair and epoch are checked. If both prices are available alongside the median price <code>M</code>, the contribution to the collusion metric is calculated in the following way:</p> <pre><code>diff = abs(P2 - P1)\ndiff1 = abs(P1 - M)\ndiff2 = abs(P2 - M)\n\nrelativePriceDiff = max(diff / M, threshold)\nrelativeOffset = scale(min(diff1, diff2) / M)\n\ncontribution = relativeOffset / relativePriceDiff\n</code></pre> <p>where</p> <pre><code>threshold = 0.00000001\nscale(x) = 20000 x + 1, if x &lt; 0.0001 and 3 otherwise\n</code></pre> <p>The threshold is selected to avoid a division by zero when the two providers submit exactly the same data, and scale displays the data more clearly.</p>"},{"location":"infra/data/managing-ecosystem/monitoring-price-history/","title":"Monitoring Price History","text":"<p>Work in Progress</p> <p>Some functions for monitoring price history are works in progress.</p> <p>In the FTSO system, price histories show the evolution of submitted and calculated prices over time on a line graph. The data plotted on the line graph enables you to study in detail the relationship between suspicious data providers, which you can first observe by using the collusion tool. The data on the graph includes:</p> <ul> <li>Median prices.</li> <li>Quantity of votes.   This information helps you locate outage periods in which a large-enough number of providers failed to submit data to impact the graph.</li> <li>Reward bands.   This information indicates the dispersion of the submitted values.</li> </ul> <p>Additionally, if the price history is displayed because you selected data providers by using the collusion tool, the graph includes submissions by those providers, enabling you to see:</p> <ul> <li>Whether a submission is inside or outside of the reward band and by how much.</li> <li>Whether multiple providers were chasing each other instead of the median, which could imply collusion.</li> </ul>"},{"location":"infra/data/managing-ecosystem/monitoring-price-history/#price-history-dashboard","title":"Price-History Dashboard","text":"Price-History Dashboard. <p>The elements of the dashboard are:</p> <ul> <li>Navigation Bar: The main functions of the Flare FTSO Monitor.</li> <li>Network Selector: Toggles between FTSO Monitors for other Flare networks.</li> <li>Line Graph: Displays the price history and the number of votes when you are not comparing specific data providers.</li> <li>Cryptocurrency Selector: Toggles between supported cryptocurrencies.</li> <li>Exchange Selector: Feature is currently not enabled.</li> <li>Date and Time Selector: Isolates the price history for the date and time you specify.</li> <li>View Selector: Toggles to relative view, which typically makes reward bands on the graph more apparent.</li> <li>Time Frame Slider: Changes the time frame displayed in the graph based on selections you make by moving the slider.</li> <li>Interval Selector: Toggles the interval during which you want to view price history.</li> </ul> <p>The default settings are:</p> <ul> <li>Cryptocurrency symbol: <code>XRP</code></li> <li>Time frame: <code>30m</code></li> <li>End time: The current date and time when you opened the Prices tab.</li> </ul>"},{"location":"infra/data/managing-ecosystem/monitoring-price-history/#comparing-price-history","title":"Comparing Price History","text":"<ol> <li>Open the price-history dashboard in the FTSO Monitor. The price-history dashboard, which is based on the default settings, is displayed.</li> <li>Optional: If you need to monitor the FTSO ecosystem on a different network, click the Network Selector, as shown in the price-history dashboard, and select a different network.</li> <li> <p>For more specific comparisons, change the default settings by using the various elements in the dashboard to further express the data:</p> <ul> <li>Toggle the currencies and interval.</li> <li>Adjust the date and time.</li> <li>Add or remove from the graph some data, such as an address, a currency's median price, the voter count, and the award area.</li> </ul> </li> </ol> <p>If the price-history dashboard opened because you compared data providers using the collusion tool, the list of data providers is also displayed below the dashboard.</p>"},{"location":"infra/observation/","title":"Observer Nodes","text":"<p>Select one of the guides below:</p> <ul> <li>Deploying an Observer Node</li> </ul>"},{"location":"infra/observation/deploying/","title":"Deploying an Observer Node","text":"<p>Observer nodes enable anyone to observe the network and submit transactions. Unlike validator nodes, which provide state consensus and add blocks, observer nodes remain outside the network and have no effect on consensus or blocks.</p> <p>Running an observer node is optional. However, submitting transactions through your own node offers a number of benefits:</p> <ul> <li>Transactions are sent directly to the network instead of through a third party, removing a potential security risk.</li> <li>Public nodes are usually rate-limited (the amount of requests they accept per second is restricted).   Your own node does not have such restriction.</li> <li>The time savings described above allow FTSO data providers to submit their data a few seconds later, thus having more time to gather data before submitting.</li> </ul> <p>This guide explains how to deploy your own observer node so you can reap the benefits.</p>"},{"location":"infra/observation/deploying/#prerequisites","title":"Prerequisites","text":"<p>This guide contains different instructions depending on which Flare network you want to deploy to, so make sure you are aware of the available networks.</p> FlareSongbirdCostonCoston2 Hardware Software CPU cores 8 Operating System Ubuntu (18.04 or 20.04) or macOS (&gt;= 10.15 Catalina) RAM 32 GB Dependencies Go (&gt;= 1.18.5) Disk space 1 TB SSD gcc Disk growth 2.5 TB/year g++ jq Hardware Software CPU cores 8 Operating System Ubuntu (18.04 or 20.04) or macOS (&gt;= 10.15 Catalina) RAM 32 GB Dependencies Go (&gt;= 1.16.8) Disk space 3.5 TB SSD gcc Disk growth 2.5 TB/year g++ jq Hardware Software CPU cores 4 Operating System Ubuntu (18.04 or 20.04) or macOS (&gt;= 10.15 Catalina) RAM 16 GB Dependencies Go (&gt;= 1.16.8) Disk space 500 GB SSD gcc Disk growth 250 GB/year g++ jq Hardware Software CPU cores 4 Operating System Ubuntu (18.04 or 20.04) or macOS (&gt;= 10.15 Catalina) RAM 16 GB Dependencies Go (&gt;= 1.18.5) Disk space 500 GB SSD gcc Disk growth 250 GB/year g++ jq <p>Plus a reliable IPv4 or IPv6 network connection, with an open public port.</p> <p>Keep in mind that enabling pruning as described below can reduce the required disk space by as much as 60%.</p>"},{"location":"infra/observation/deploying/#guide","title":"Guide","text":""},{"location":"infra/observation/deploying/#1-installation","title":"1. Installation","text":"Flare &amp; Coston2Songbird &amp; Coston <p>Clone the go-flare repository and run the <code>build.sh</code> script:</p> <pre><code>git clone https://github.com/flare-foundation/go-flare.git\ncd go-flare/avalanchego\n./scripts/build.sh\n</code></pre> <p>The resulting executable will be <code>build/avalanchego</code>.</p> <p>Note</p> <p>You can verify the installation by running:</p> <pre><code>go test $(go list ./... | grep -v /tests/) # avalanchego unit tests\ncd ../coreth\ngo test ./... # coreth unit tests\ncd ../avalanchego\n</code></pre> <p>Clone the go-songbird repository and run the <code>build.sh</code> script:</p> <pre><code>git clone https://github.com/flare-foundation/go-songbird.git\ncd go-songbird/avalanchego\n./scripts/build.sh\n</code></pre> <p>The resulting executable will be <code>build/flare</code>.</p> <p>Note</p> <p>You can verify the installation by running:</p> <pre><code>go test $(go list ./... | grep -v /tests/) # avalanchego unit tests\ncd coreth\ngo test ./... # coreth unit tests\ncd ..\n</code></pre>"},{"location":"infra/observation/deploying/#2-songbird-node-whitelisting","title":"2. Songbird Node Whitelisting","text":"<p>While the Songbird network is being tested, all nodes wanting to peer with it, including observer nodes, need to have their IP address whitelisted.</p> <p>To do this, please contact Tom T. over Discord (<code>Tom T#7603</code>), Telegram (<code>@TampaBay7</code>), or email (tom@flare.network), and request to be whitelisted. To have greater redundancy, you can whitelist multiple nodes per single provider.</p> Checking the status of your Songbird whitelisting request <pre><code>curl -m 10 -sX POST \\\n--data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\\n-H 'content-type:application/json;' \\\nhttps://songbird.flare.network/ext/info\n</code></pre> <p>If your IP address is whitelisted, this command returns a JSON response. Otherwise you will get a 403 error (\"Forbidden\").</p> <p>Please note that whitelisting is not needed on the Flare network or any of the Coston networks.</p>"},{"location":"infra/observation/deploying/#3-run-the-node","title":"3. Run the Node","text":"<p>This is the minimum command to quickly get your node up and running. To understand each parameter read the following step before launching the node.</p> FlareSongbirdCostonCoston2 <pre><code>./build/avalanchego --network-id=flare --http-host= \\\n  --bootstrap-ips=\"$(curl -m 10 -sX POST \\\n    --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\\n    -H 'content-type:application/json;' https://flare.flare.network/ext/info \\\n    | jq -r \".result.ip\")\" \\\n  --bootstrap-ids=\"$(curl -m 10 -sX POST \\\n    --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\\n    -H 'content-type:application/json;' https://flare.flare.network/ext/info \\\n    | jq -r \".result.nodeID\")\"\n</code></pre> <pre><code>./build/flare --network-id=songbird --http-host= \\\n  --bootstrap-ips=\"$(curl -m 10 -sX POST \\\n    --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\\n    -H 'content-type:application/json;' https://songbird.flare.network/ext/info \\\n    | jq -r \".result.ip\")\" \\\n  --bootstrap-ids=\"$(curl -m 10 -sX POST \\\n    --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\\n    -H 'content-type:application/json;' https://songbird.flare.network/ext/info \\\n    | jq -r \".result.nodeID\")\"\n</code></pre> <pre><code>./build/flare --network-id=coston --http-host= \\\n  --bootstrap-ips=\"$(curl -m 10 -sX POST \\\n    --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\\n    -H 'content-type:application/json;' https://coston.flare.network/ext/info \\\n    | jq -r \".result.ip\")\" \\\n  --bootstrap-ids=\"$(curl -m 10 -sX POST \\\n    --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\\n    -H 'content-type:application/json;' https://coston.flare.network/ext/info \\\n    | jq -r \".result.nodeID\")\"\n</code></pre> <pre><code>./build/avalanchego --network-id=costwo --http-host= \\\n  --bootstrap-ips=\"$(curl -m 10 -sX POST \\\n    --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\\n    -H 'content-type:application/json;' https://coston2.flare.network/ext/info \\\n    | jq -r \".result.ip\")\" \\\n  --bootstrap-ids=\"$(curl -m 10 -sX POST \\\n    --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\\n    -H 'content-type:application/json;' https://coston2.flare.network/ext/info \\\n    | jq -r \".result.nodeID\")\"\n</code></pre> <p>After a lot of log messages the node should start synchronizing with the network, which might take a long time (currently about 4 hours for Flare, over a week for Songbird, depending on network speed and machine specs).</p> <p>You can stop the node at any time by pressing <code>Ctrl-C</code>. Use the same command line as before to restart the node. Synchronization will resume where it left if it is interrupted.</p> <p>You will know your node is fully booted and accepting transactions when the output of this command:</p> <pre><code>curl http://127.0.0.1:9650/ext/health\n</code></pre> <p>Contains the field <code>\"healthy\":true</code> in the returned JSON object.</p> <p>Note</p> <p>If the node gets stuck during bootstrap (it takes far longer than the estimates given above), try to add the parameter <code>--bootstrap-retry-enabled=false</code>.</p>"},{"location":"infra/observation/deploying/#4-additional-configuration","title":"4. Additional Configuration","text":"<p>These are some of the most relevant command line parameters you can use. You can read about all of them in the Avalanche documentation.</p> <ul> <li> <p><code>--bootstrap-ips</code>,     <code>--bootstrap-ids</code>:     IP address and node ID of the peer used to connect to the rest of the network for bootstrapping.</p> <p>You can use Flare's public nodes for this, as shown in the quick start command given above:</p> FlareSongbirdCostonCoston2 <p>Peer's IP address:</p> <pre><code>curl -m 10 -sX POST \\\n--data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\\n-H 'content-type:application/json;' \\\nhttps://flare.flare.network/ext/info | jq -r \".result.ip\"\n</code></pre> <p>Peer's node ID:</p> <pre><code>curl -m 10 -sX POST \\\n--data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\\n-H 'content-type:application/json;' \\\nhttps://flare.flare.network/ext/info | jq -r \".result.nodeID\"\n</code></pre> <p>Peer's IP address:</p> <pre><code>curl -m 10 -sX POST \\\n--data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\\n-H 'content-type:application/json;' \\\nhttps://songbird.flare.network/ext/info | jq -r \".result.ip\"\n</code></pre> <p>Peer's node ID:</p> <pre><code>curl -m 10 -sX POST \\\n--data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\\n-H 'content-type:application/json;' \\\nhttps://songbird.flare.network/ext/info | jq -r \".result.nodeID\"\n</code></pre> <p>Peer's IP address:</p> <pre><code>curl -m 10 -sX POST \\\n--data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\\n-H 'content-type:application/json;' \\\nhttps://coston.flare.network/ext/info | jq -r \".result.ip\"\n</code></pre> <p>Peer's node ID:</p> <pre><code>curl -m 10 -sX POST \\\n--data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\\n-H 'content-type:application/json;' \\\nhttps://coston.flare.network/ext/info | jq -r \".result.nodeID\"\n</code></pre> <p>Peer's IP address:</p> <pre><code>curl -m 10 -sX POST \\\n--data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\\n-H 'content-type:application/json;' \\\nhttps://coston2.flare.network/ext/info | jq -r \".result.ip\"\n</code></pre> <p>Peer's node ID:</p> <pre><code>curl -m 10 -sX POST \\\n--data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\\n-H 'content-type:application/json;' \\\nhttps://coston2.flare.network/ext/info | jq -r \".result.nodeID\"\n</code></pre> <p>Remember that you need to whitelist your node's IP address or your queries will always be answered with 403 error codes.</p> </li> <li> <p><code>--http-host</code>:     Use <code>--http-host=</code> (empty) to allow connections from other machines.     Otherwise, only connections from <code>localhost</code> are accepted.</p> </li> <li> <p><code>--http-port</code>:     The port through which the node will listen to API requests.     The default value is <code>9650</code>.</p> </li> <li> <p><code>--staking-port</code>:     The port through which the network peers will connect to this node externally.     Having this port accessible from the internet is required for correct node operation.     The default value is <code>9651</code>.</p> </li> <li> <p><code>--db-dir</code>:     Directory where the database is stored.     Make sure to use a disk with enough space as recommended in the Hardware prerequisites section.     It defaults to <code>~/.avalanchego/db</code> on Flare and Coston2, and to <code>~/.flare/db</code> on Songbird and Coston.</p> <p>For example, you can use this option to store the database on an external drive.</p> </li> <li> <p><code>--chain-config-dir</code>:     Optional JSON configuration file, in case you want to use lots of non-default values.</p> Sample configuration file for observer nodes <p>These are the most common configuration options. Put them in a file in the <code>{chain-config-dir}/C/config.json</code> folder.</p> <pre><code>{\n    \"snowman-api-enabled\": false,\n    \"coreth-admin-api-enabled\": false,\n    \"eth-apis\": [\n        \"public-eth\",\n        \"public-eth-filter\",\n        \"net\",\n        \"web3\",\n        \"internal-public-eth\",\n        \"internal-public-blockchain\",\n        \"internal-public-transaction-pool\"\n    ],\n    \"rpc-gas-cap\": 50000000,\n    \"rpc-tx-fee-cap\": 100,\n    \"pruning-enabled\": true,\n    \"local-txs-enabled\": false,\n    \"api-max-duration\": 0,\n    \"api-max-blocks-per-request\": 0,\n    \"allow-unfinalized-queries\": false,\n    \"allow-unprotected-txs\": false,\n    \"remote-tx-gossip-only-enabled\": false,\n    \"log-level\": \"info\"\n}\n</code></pre> </li> </ul> <p>Archival nodes: An archival node keeps the whole history of the blockchain, instead of pruning old transactions which is the default setting. Use the <code>pruning-enabled</code> configuration setting to control whether your node performs pruning or not. Archival nodes have significantly increased disk requirements.</p>"},{"location":"infra/observation/deploying/#5-maintaining-a-healthy-node","title":"5. Maintaining a Healthy Node","text":"<p>In some cases, your node might not work correctly or you might receive unusual messages that appear difficult to troubleshoot. Use the following solutions to ensure your node stays healthy:</p> <ul> <li> <p>Remember that when your node has less than 16 peers, your node will not work correctly.   To retrieve the number of connected peers, run the following command and find the line that contains <code>connectedPeers</code>:</p> <pre><code>curl http://127.0.0.1:9650/ext/health | jq\n</code></pre> <p>To automate the process, use:</p> <pre><code>curl -s http://127.0.0.1:9650/ext/health | \\\n    jq -r \".checks.network.message.connectedPeers\"\n</code></pre> </li> <li> <p>If your node does not sync after a long time and abruptly stops working, ensure the database location has sufficient disk space, and remember the database size might change a lot during bootstrapping.</p> </li> <li>If you receive unusual messages after you make submissions or when transactions are reverted, your node might not be connected correctly.   First, ensure the database location has sufficient disk space, and then restart the node.</li> <li> <p>If you receive this error related to <code>GetAcceptedFrontier</code> during bootstrapping, your node was disconnected during bootstrapping.    Restart the node.</p> <pre><code>failed to send GetAcceptedFrontier(MtF8bVH241hetCQJgsKEdKyJBs8vhp1BC, 11111111111111111111111111111111LpoYY, NUMBER)\n</code></pre> </li> <li> <p>If you sync your node, but it stays unhealthy for no discernible reason, restart the node.</p> </li> </ul>"},{"location":"infra/validation/","title":"Validator Nodes","text":"<p>The following guide explains how to set up and manage validators.</p> <ul> <li>Deploying a Validator Node</li> </ul>"},{"location":"infra/validation/deploying/","title":"Deploying a Validator Node","text":"<p>Deploy validator nodes to participate in consensus and collect rewards that the network provides to those who help secure it.</p> <p>As explained in the Validator Nodes page, they are servers that fulfill a critical role in securing the network. They:</p> <ul> <li>Check that all received transactions are valid.</li> <li>Run a consensus algorithm so that all validators in the network agree on the transactions to add to the blockchain.</li> <li>Finally, add the agreed-upon transactions to their copy of the ledger.</li> </ul> <p>Additionally, all blockchains employ certain measures against Sybil attacks. In this regard, Flare validators must:</p> <ul> <li>Be associated with an FTSO Data Provider.     The performance of the data provider has an impact on the validation rewards.</li> <li>Stake native tokens, as in Proof of Stake.</li> </ul> <p>To maintain decentralization, these limits apply:</p> <ul> <li>A single FTSO data provider can be associated with up to 4 validators, each with its own stake and each claiming their own rewards.     Each validator can be associated with only one FTSO provider.</li> <li>The staking cap on each validators' rewards is 5% of the total staked funds on the network.</li> </ul> <p>The following instructions apply to the Flare network only. Validators on Songbird are managed by the Flare Foundation.</p>"},{"location":"infra/validation/deploying/#prerequisites","title":"Prerequisites","text":"<p>Validators run the same software as regular observer nodes, therefore, this guide assumes you have already read the Deploying an Observer Node guide.</p> <p>The requirements to deploy a validator node are the same as for observer nodes, except on the CPU and RAM front which are heavier due to the extra work required:</p> Hardware Software CPU cores 16 Operating System Ubuntu (18.04 or 20.04) or macOS (&gt;= 10.15 Catalina) RAM 64 GB Dependencies Go (&gt;= 1.18.5) Disk space 1 TB SSD gcc Disk growth 2.5 TB/year g++ jq npm (&gt;= 8.11)"},{"location":"infra/validation/deploying/#guide","title":"Guide","text":"<p>A validator node is deployed like an observer node, but there are some additional considerations.</p> <p>Firstly, validators do more work than plain observer nodes so please consider the recommended hardware specifications above.</p> <p>And secondly, validator security impacts the whole network, so configure the node for security, as follows, before running it.</p>"},{"location":"infra/validation/deploying/#1-configure-the-node","title":"1. Configure the Node","text":"<p>Please consider the following security items carefully:</p>"},{"location":"infra/validation/deploying/#mandatory-security-measures","title":"Mandatory security measures","text":"<ul> <li> <p>Ensure port 9650 is not externally reachable.     This is the port used to answer API requests and validators should not be doing that.</p> </li> <li> <p>Disallow password authentication over SSH.</p> </li> <li> <p>Don't run any non-validator services on the same IP (website, mail server, etc).</p> </li> </ul> <p>Warning</p> <p>A monitoring tool run by Flare periodically checks that the above measures are followed by all validators.</p> <p>Failure to comply impacts the validator's rewards.</p>"},{"location":"infra/validation/deploying/#suggested-security-measures","title":"Suggested security measures","text":"<ul> <li> <p>Disallow any ICMP traffic.</p> </li> <li> <p>Have the machine firewalled.   Only the ports required for validator operation should be open (i.e. only the staking port, which defaults to 9651).</p> <p>If you use a virtual server, use only its web interface for management and close the SSH port.</p> <p>If the SSH port must be open, it should ideally be restricted to a private IP (i.e. only accessible through VPN) or only temporarily open to the operator's office/home static IP or a bastion SSH VM that can be turned off between use.</p> </li> <li> <p>The node should only act as a validator, and not accept RPC API calls.</p> <p>You should deploy a separate observer node for tasks requiring RPC API access. Additionally, this observer node can point to your validator for peering and bootstrapping.</p> </li> <li> <p>The validator should only enable the minimum set of EVM APIs by adding this line to a configuration file:</p> <pre><code>\"eth-apis\": [\n    \"web3\"\n]\n</code></pre> Sample configuration file for validator nodes <pre><code>{\n    \"snowman-api-enabled\": false,\n    \"coreth-admin-api-enabled\": false,\n    \"coreth-admin-api-dir\": \"\",\n    \"eth-apis\": [\n        \"web3\"\n    ],\n    \"continuous-profiler-dir\": \"\",\n    \"continuous-profiler-frequency\": 900000000000,\n    \"continuous-profiler-max-files\": 5,\n    \"rpc-gas-cap\": 50000000,\n    \"rpc-tx-fee-cap\": 100,\n    \"preimages-enabled\": false,\n    \"pruning-enabled\": true,\n    \"snapshot-async\": true,\n    \"snapshot-verification-enabled\": false,\n    \"metrics-enabled\": true,\n    \"metrics-expensive-enabled\": false,\n    \"local-txs-enabled\": false,\n    \"api-max-duration\": 30000000000,\n    \"ws-cpu-refill-rate\": 0,\n    \"ws-cpu-max-stored\": 0,\n    \"api-max-blocks-per-request\": 30,\n    \"allow-unfinalized-queries\": false,\n    \"allow-unprotected-txs\": false,\n    \"keystore-directory\": \"\",\n    \"keystore-external-signer\": \"\",\n    \"keystore-insecure-unlock-allowed\": false,\n    \"remote-tx-gossip-only-enabled\": false,\n    \"tx-regossip-frequency\": 60000000000,\n    \"tx-regossip-max-size\": 15,\n    \"log-level\": \"info\",\n    \"offline-pruning-enabled\": false,\n    \"offline-pruning-bloom-filter-size\": 512,\n    \"offline-pruning-data-directory\": \"\"\n}\n</code></pre> </li> </ul>"},{"location":"infra/validation/deploying/#2-run-the-node","title":"2. Run the Node","text":"<p>After taking the above considerations into account, you can now start up your node by following the Deploying an Observation Node guide.</p> <p>Preregistered validator keys</p> <p>Some users have received preregistered validator keys, this is, the keys required to deploy a node which has already been registered as a validator.</p> <p>If that is your case, you just need to add these parameters to the launch command line:</p> <pre><code>--staking-tls-cert-file=&lt;NODE_CRT_PATH&gt; \\\n--staking-tls-key-file=&lt;NODE_KEY_PATH&gt;\n</code></pre>"},{"location":"tech/","title":"Flare Fundamentals","text":"<p>This section contains in-depth descriptions of Flare's key concepts, technology and tools.</p> <p>Select one of the topics below:</p> <ul> <li>What Is Flare?</li> <li>Automatic Claiming</li> <li>The FlareDrop</li> <li>Flare Beta</li> <li>Flare API Portal</li> <li>FAssets</li> <li>FTSO</li> <li>Governance</li> <li>Personal Delegation Accounts</li> <li>State Connector</li> <li>Validator Nodes</li> <li>Glossary</li> <li>Archive</li> </ul>"},{"location":"tech/api-portal/","title":"Flare API Portal","text":"<p>Flare's API Portal is a paid product that gives developers access to a number of private nodes running on different blockchains, including Flare, Songbird and Coston, but also other networks like Bitcoin or XRPL.</p> <p>These nodes are not rate-limited, so it is typically more convenient to connect your apps to them than to deploy your own nodes, or connect to public nodes.</p> <p>This is one more step towards Flare's goal to connect all blockchains.</p> <p>Visit Flare's API Portal website</p> <p>Visit the API Portal's FAQ if you are having authentication issues!</p>"},{"location":"tech/automatic-claiming/","title":"Automatic Claiming","text":"<p>Automatic claiming enables users to appoint an executor to claim rewards on their behalf.</p>"},{"location":"tech/automatic-claiming/#introduction","title":"Introduction","text":"<p>The Flare network rewards users that contribute to it, for example, by delegating to an FTSO data provider.</p> <p>Delegation rewards accrue every 3.5 days when users have delegated wrapped Flare tokens (WFLR) to FTSO data providers. These rewards must be claimed periodically by users, since rewards expire after a few months.</p> <p>For users, claiming rewards can be inconvenient and can risk losing rewards and compound interest if overlooked. If users are claiming rewards from a cold wallet, they can expose the wallet more often than necessary.</p> <p>Instead, users can enlist the services of executors to claim for them, putting the responsibility of remembering to claim on the executor. Automatic claiming through an executor saves user time and inconvenience, optimizes the opportunity for compound interest, and avoids unnecessary exposure of users' cold wallets.</p> <p>Automatic claiming is secure because the executor cannot claim to any address but the ones the user provides. It is trustless (does not require trust) because it is managed by a smart contract, not the executor.</p> <p>For executors, automatic claiming is an opportunity to earn a fee for performing claiming as a service to users.</p>"},{"location":"tech/automatic-claiming/#how-automatic-claiming-works","title":"How Automatic Claiming Works","text":"<p>Without an executor, users need to claim twice a week if they want to benefit from the rewards as soon as possible.</p> <p> </p> The claiming process without an executor. <p>With an executor, a third party can claim for users, for an optional fee.</p> <p> </p> The claiming process with an executor. <p>There are two ways to claim with an executor: manual and registered. They both provide \"automatic claiming\" for the user in the sense that claiming rewards requires no intervention from the user once the executor takes over. However, when the executor does not register, several parts of the process are not automated, such as finding each other and paying the fee. The \"manual\" version is less automated. The registered version is highly automated.</p>"},{"location":"tech/automatic-claiming/#manual-claiming-process","title":"Manual Claiming Process","text":"<p>If an executor account is not registered, claiming is said to be Manual.</p> <p>With Manual claiming users only need to provide the executor's address, which authorizes the executor to claim on the user's behalf. How the user discovers the executor's address and whether they will pay a service fee can only be settled off-chain.</p> <p>Example</p> <p>For example, executors could create a dapp where users pay a fee (in fiat or spot) and sign the transaction that sets the executor's address.</p> <p>Only reward claiming remains automated, whereby rewards are sent directly to the user's address. Executors do not receive a fee automatically.</p> <p>Here is how the process works when executor claiming is manual:</p> <ol> <li>Users who have accrued rewards and want an executor to claim on their behalf can identify an executor known to them off-chain.</li> <li>These users then make an off-chain agreement with the executor and they exchange addresses.</li> <li>Agreeing to a fee is optional and off-chain.    If they do agree to a fee, they pay manually.</li> <li>Executors claim rewards for one or more users.    Their fees are not automatically deducted from the claimed rewards.</li> <li>Executors notify users off-chain if they discontinue providing this service.</li> </ol>"},{"location":"tech/automatic-claiming/#registered-claiming-process","title":"Registered Claiming Process","text":"<p>On the other hand, the process can be simplified if the executor address is Registered. Registration allows accounts to list themselves on-chain as registered executors and post their service fees. Registration simplifies both the user task of finding a suitable executor and the executor's task, since its fee is automatically transferred when user rewards are claimed. The users pay a fee to set an executor to claim their rewards and their rewards are claimed automatically, i.e., without their intervention. With a registered executor, all agreements happen on-chain.</p> <p>Here is how the registered claiming process works, with applications performing these actions on behalf of executors and users:</p> <ol> <li>Executors who want to make themselves publicly available to users register as executors, paying a registration fee. The fee to register as an executor is burned.</li> <li>Registered executors post their fee for claiming rewards.</li> <li>Users who have accrued rewards and want an executor to claim on their behalf can choose from the list of registered executors.</li> <li>These users pay a setup fee to enable a registered executor to claim their rewards.    The fee to enable a registered executor is sent to the executor.</li> <li>Executors claim rewards for one or more users, and their fees are automatically deducted from the claimed rewards.</li> <li>Executors notify users off-chain if they discontinue providing this service.</li> </ol> <p>Throughout the process:</p> <ul> <li>Users and executors can see reports on which addresses executors are claiming for and which executors are registered.</li> <li>Registered executors can change fees or unregister, and users can change the registered executors claiming on their behalf or disable automatic claiming.</li> </ul>"},{"location":"tech/automatic-claiming/#other-use-cases","title":"Other Use Cases","text":""},{"location":"tech/automatic-claiming/#cold-wallets","title":"Cold Wallets","text":"<p>Many users claim from a cold wallet because they can reap the most rewards where they store the greatest share of their holdings. When they claim from a cold wallet, they are exposing it online. Setting an executor can protect the cold wallet, as the executor would claim the rewards and pass them on to the user's account automatically without putting the cold wallet online.</p>"},{"location":"tech/automatic-claiming/#your-own-executor","title":"Your Own Executor","text":"<p>If a user has multiple addresses, it may be convenient to designate one of their own addresses as an executor, and claim for all of them from it. Additionally, this avoids the fee that a public executor will typically charge.</p> <p>Warning</p> <p>By using the automatic claiming feature, neither Flare Foundation nor any of the contracts published on the Flare network guarantee that the selected executor will actually claim any or all of the user\u2019s rewards. This agreement is solely between the user and the selected executor. The Flare network offers only the possibility of setting up an automatic execution service and is not liable for any damages if this service is not performed. For more information, see FLARE TERMS OF SERVICE &amp; PRIVACY POLICY.</p> <p>Developing autoclaiming functionality</p> <p>For information on how to develop an executor, or how to write an application that supports autoclaiming, see Automatic Claiming in the Developer section.</p>"},{"location":"tech/automatic-claiming/#related-user-guides","title":"Related User Guides","text":"<ul> <li>Automatic claiming</li> </ul>"},{"location":"tech/automatic-claiming/#related-developer-docs","title":"Related Developer Docs","text":"<ul> <li>Automatic claiming</li> </ul>"},{"location":"tech/flare-beta/","title":"Flare Beta","text":"<p>Decentralization will be achieved by moving the transaction validation duty from the Flare Foundation to community-run FTSO data providers, but this will not happen instantly.</p> <p>Instead, to ensure a safe transition, a number of professional validators were initially enabled and continue to be employed.</p> <p>The professional validators were chosen among companies with proven experience running blockchain infrastructure and at first held most of the validation power. This power, though, will be progressively shifted onto the community-run validators until they run the network on their own.</p> <p>This initial period is called Flare Beta, and it will span several launch phases.</p>"},{"location":"tech/flare-beta/#flare-beta-details","title":"Flare Beta Details","text":"<p>The Flare Beta began at the same time as the token distribution event (TDE).</p> <p>During this period:</p> <ul> <li> <p>20 total validators with equal validation power (20K FLR each, initially) are enabled.</p> <ul> <li>4 run by the Flare Foundation.</li> <li>16 run by 4 professional validators.</li> </ul> </li> <li> <p>Each FTSO running an observation node will be a candidate to become a validator node later. These nodes are regularly scanned to ensure they meet security standards. If they meet the security standards, they enable the node operators to receive rewards.</p> </li> <li> <p>Validator rewards are split 50% for the professional validators and 50% for the FTSOs running observation nodes.</p> </li> <li> <p>Estimated duration: 6 - 9 months, depending on the evolution of the network.</p> </li> </ul>"},{"location":"tech/flare/","title":"What Is Flare?","text":"<p>Flare is the blockchain for data. It is a layer 1, EVM smart contract platform designed to expand the utility of blockchain.</p> <p>Flare's aim is to provide data as a public good, meaning that data is not controlled by a centralized entity and is available to all. The infrastructure providers, which perform doubly as validators and data providers, enable two native oracles, the FTSO and the State Connector. This native processing provides developers on Flare with efficient access to large amounts of data and data proofs at minimal cost.</p> <p>By giving developers trustless access to the broadest range of data, Flare can advance the development of more blockchain use cases where data is important, such as in DeFi, gaming, NFT, music, and social networks.</p>"},{"location":"tech/flare/#flare-protocols","title":"Flare Protocols","text":"<p>Flare has the following native data acquisition protocols at these stages of development:</p> <ul> <li>The Flare Time-Series Oracle (FTSO) provides continuous estimations of changing data, such as price pairs.</li> <li>The State Connector allows querying of verifiable, non-changing data from other chains and the internet.</li> <li>The FAssets system is being developed by Flare Labs. It allows tokens on blockchains that do not support smart contracts to be used trustlessly with smart contracts on the Flare blockchain.</li> <li>Flare LayerCake is being developed by Flare Labs to provide a decentralized, trustless bridging system between smart contract networks. For an overview of trustless bridges, see LayerCake.</li> </ul>"},{"location":"tech/flare/#developing-on-flare","title":"Developing on Flare","text":"<p>Flare developers can work in a familiar Ethereum-like environment. It offers the same API and uses the Ethereum Virtual Machine (EVM), so Ethereum's Solidity smart contracts can be used directly. Like Ethereum, Flare supports other assets, such as NFTs. See Developer Docs.</p> <p>The Flare native currency, <code>$FLR</code>, works the same as <code>$ETH</code> on the Ethereum blockchain. For those contracts that can only work with ERC-20 tokens, <code>$FLR</code> can be easily wrapped as <code>$WFLR</code>, which is an ERC-20 representation of <code>$FLR</code>. Flare's FTSO delegation and Flare governance are examples of such apps.</p> <p>Common blockchain tools like wallets, a token management portal, and block explorers are available on Flare.</p> <p>Flare is actively seeking developers eager to discover what new utility can be brought to the blockchain industry when acquiring data is possible in a decentralized way. To start, since Flare is EVM-compatible, you can migrate Ethereum smart-contract dapps to Flare. Then consider, for example, creating DeFi, gaming, NFT, music, or social network dapps. See Start Building, for more information.</p>"},{"location":"tech/flare/#flare-networks","title":"Flare Networks","text":"<p>Flare has 4 networks with different purposes:</p> <ul> <li>Flare is the main network, where <code>$FLR</code> is the native currency.</li> <li>Songbird is the canary network, where <code>$SGB</code> is the native currency. Created with users in mind, it is meant for testing features under \"real fire\" conditions, before deploying them on the main network.</li> <li>Coston is Songbird's public test network, created with developers in mind.</li> <li>Coston2 is Flare's public test network, created with developers in mind.</li> </ul> <p></p> General feature adoption flow."},{"location":"tech/flare/#flare-chains","title":"Flare Chains","text":"<p>Flare uses two chains and is developing a built-in interoperability mechanism between them.</p> <ul> <li>C-Chain: The contract chain that is used for smart contracts. It is where the Ethereum Virtual Machine operates, and is the chain where the vast bulk of the community currently interact.</li> <li>P-Chain: The platform chain that accommodates staking and provides rewards to its validators.</li> </ul>"},{"location":"tech/ftso/","title":"FTSO","text":"<p>The Flare Time Series Oracle (FTSO) is a smart contract running on the Flare network that provides continuous estimations for different types of data. It does so in a decentralized manner (no single party is in control of the process) and securely (it takes a lot of effort to disrupt the process).</p> <p>To achieve a secure, decentralized system, a set of independent data providers retrieves data from external sources, like centralized and decentralized exchanges, and supplies the data to the FTSO system. Then, this information is weighted according to each provider's vote power, and a median is calculated to produce the final estimate.</p> <p>Important</p> <p>When FTSOs were initially designed, they supported only cryptocurrency price pairs. Now, they support all types of data. However, contract names and methods still refer to prices and price epochs, and price pairs are used in the following information to show how FTSOs work.</p> <p>The following diagram shows how price pairs are submitted to and filtered by the FTSO system.</p> <p> </p> FTSO summary. <p>Data providers that supply useful information, such as price pairs that are not removed as outliers because they are too far away from the median value, are rewarded, and the resulting data estimates are finally published on-chain.</p> <p>The following information describes:</p> <ul> <li>The FTSO workflow</li> <li>How results are calculated</li> <li>Vote power</li> <li>Delegation</li> </ul>"},{"location":"tech/ftso/#procedure-overview","title":"Procedure Overview","text":"<p>Using price data as an example, the procedure in the following diagram runs continuously. It produces new data estimates during every price epoch, which is 3 minutes long.</p> <p> </p> FTSO workflow. <ol> <li> <p>Any user with an account (address) on the Flare network can act as an FTSO data provider, submit data, and collect rewards.</p> <p>During each epoch, only submissions from the 100 data providers with the most vote power are considered. An account's vote power is based on its wrapped <code>$FLR</code> or <code>$SGB</code> balance and the delegations made to it (see Vote Power below).</p> <p>Submitted data must be the current price (in <code>$USD</code>) for one or more of the supported price pairs, currently: <code>$ADA</code>, <code>$ALGO</code>, <code>$ARB</code>, <code>$AVAX</code>, <code>$BNB</code>, <code>$BTC</code>, <code>$DOGE</code>, <code>$ETH</code>, <code>$FIL</code>, <code>$FLR</code>, <code>$LTC</code>, <code>$MATIC</code>, <code>$SOL</code>, <code>$USDC</code>, <code>$USDT</code>, <code>$XDC</code>, <code>$XLM</code>, and <code>$XRP</code>. On Songbird, replace <code>$FLR</code> with <code>$SGB</code>.</p> <p>More general data types might be added in the future.</p> </li> <li> <p>FTSO data providers submit data in rounds in a commit-and-reveal process, so they cannot see each other's submissions until a round is over.</p> <p>This process is like submitting data in a closed envelope, and when the round is over, all envelopes are opened.</p> <p>During a 3-minute price epoch, providers fetch the information, run their algorithms, and submit a hash of the data (commit). Then, during the first half of the following price epoch (1.5 minutes), providers submit the actual data (reveal).</p> <p>See technical details about the data-submission process in the developer reference section.</p> </li> <li> <p>The FTSO system calculates the resulting median, taking into account each provider's vote power (see How Results are Calculated below).</p> <p>Results are publicly available for 5 price epochs for any app or contract to read. Previous epochs can always be retrieved from an archival node.</p> </li> <li> <p>For each price epoch in which the submitted data is close enough to the median value, data providers and their delegators are rewarded.</p> <p>Rewards are accumulated in reward epochs, which last 3.5 days on the Flare network and 7 days on Songbird, and you can claim them after the epoch finishes.</p> <p>See Rewards below.</p> </li> </ol>"},{"location":"tech/ftso/#how-results-are-calculated","title":"How Results are Calculated","text":"<p>The following example uses price pairs to show the filtering process that turns all submitted data into a single estimate. See all details in the Flare whitepaper.</p> <p> </p> FTSO price calculation. <ul> <li> <p>The contract in charge of each price pair calculates the resulting price for a price epoch using the submissions received from all data providers during that epoch.   Price epochs are 3 minutes long.</p> </li> <li> <p>Each submission has a price and a weight.   Weight is based on the data provider's vote power, as explained below.</p> </li> <li> <p>The weighted median of the prices is the resulting price for the price epoch.</p> </li> <li> <p>Submissions in the top and bottom 25% range are not rewarded.</p> </li> </ul>"},{"location":"tech/ftso/#vote-power","title":"Vote Power","text":"FTSO delegation weight calculation. <ul> <li> <p>As explained above, an FTSO data provider's submissions are weighted by its vote power.   A data provider's vote power is proportional to the amount of wrapped Flare or Songbird tokens (<code>$WFLR</code> or <code>$WSGB</code>) it holds, plus any amount delegated to it.</p> <p>A data provider's influence is limited</p> <p>A vote-power cap limits the influence of individual data providers to 2.5% of the total vote power on both Flare and Songbird.</p> <p>Any vote power above this cap is ignored. If vote power exceeds the limit, consider delegating those <code>$WFLR</code> or <code>$WSGB</code> to a different data provider.</p> </li> <li> <p>A snapshot of each data provider's vote power is taken once per reward epoch, and the resulting weight is then used throughout the next reward epoch.</p> </li> <li>The actual snapshot block is called the vote-power block, and it is randomly chosen from the last blocks of the previous epoch.   On Flare, the vote-power block is randomly chosen from roughly the last 50% of the blocks, and on Songbird, it is randomly chosen from roughly the last 25%.   The random selection only roughly corresponds to the last 50% or 25% of the time because block production times are not constant.</li> </ul> <p>Reward epochs</p> <p>The first reward epoch on Songbird started on Saturday, 18 September 2021 08:41:39 (GMT), 1631954499 in Unix time and repeats every 7 days. Therefore, all Songbird reward epochs start on Saturday morning (GMT).</p> <p>The first reward epoch on Flare started on Thursday, 21 July 2022 19:00:05 (GMT), 1658430005 in Unix time and repeats every 3.5 days. Therefore, all Flare reward epochs start on Thursday evening (GMT) and Monday morning (GMT).</p>"},{"location":"tech/ftso/#delegation","title":"Delegation","text":"<p>If you hold <code>$FLR</code> or <code>$SGB</code> tokens, you can delegate them to an FTSO data provider to increase its vote power and earn a share of its rewards, resulting in a mutually beneficial arrangement. When you delegate your vote power, you not only earn rewards but also support reliable data providers, which strengthens the stability of the FTSO and the whole ecosystem.</p> <p>Before you can delegate your native <code>$FLR</code> and <code>$SGB</code> tokens, you must wrap these tokens into ERC-20 <code>$WFLR</code> and <code>$WSGB</code> tokens, an operation you can reverse at any time.</p> <p>After you wrap your tokens, you will have the vote power that is equivalent to the wrapped token balance, and you can delegate 100% of this vote power to 1 or 2 data providers. Delegating 100% of your vote power to reliable data providers committed to providing accurate data maximizes your rewards and enhances the stability of the ecosystem.</p> <p>The reward rate (for advanced users)</p> <p>As you explore data providers, consider the expected reward rate each one offers. The reward rate describes how many tokens were earned by a data provider during a reward epoch for every 100 tokens delegated.</p> <p>The reward rate is calculated as \\(total\\_reward / vote\\_power * (100 - fee)\\), where:</p> <ul> <li>\\(total\\_reward\\): All accumulated rewards for the data provider and its delegators in the reward epoch.</li> <li>\\(vote\\_power\\): All the data provider's <code>$WFLR</code> and all the <code>$WFLR</code> delegated to it in the vote-power block selected for the reward epoch.</li> <li>\\(fee\\): The amount kept by the data provider as compensation for the service it provides. The value is specified as a percentage. For example, if the data provider's fee is 21.3%, specify 21.3 to calculate the reward rate.</li> </ul> <p>Because rewards are distributed in units of <code>$FLR</code>, the reward rate is calculated in units of <code>$FLR</code>.</p> <p>For the duration of the delegation, you will earn rewards that are commensurate with vote power and the performance of the chosen data providers. Rewards accumulate, and they become claimable for each reward epoch that is finalized.</p> <p>Inflation is distributed to everyone who participates in the FTSO system, which includes data providers and entities that delegate their vote power to the data providers. Delegated tokens are not locked, meaning that they remain in the user's control and the delegation can be removed at any time.</p> <p>Any <code>$WFLR</code> or <code>$WSGB</code> that is newly wrapped, sent, or received will automatically update your actual delegated vote power. However, if you receive native tokens, you must wrap them before you contribute to existing delegations.</p>"},{"location":"tech/ftso/#immediate-delegation-revocation","title":"Immediate Delegation Revocation","text":"<p>Sometimes, a data provider might maliciously attack the FTSO system to skew the reported data. If this type of attack occurs, the vote power of a data provider can be revoked immediately instead of in the next reward epoch.</p> <p>In this situation, an off-chain process, such as a Twitter storm, calls for users to revoke vote power from the data provider that has attacked the system. When vote power is revoked, the revocation occurs immediately.</p> <p>Learn how to perform this operation from the block explorer.</p>"},{"location":"tech/ftso/#effects-of-the-vote-power-block-snapshot-on-delegations","title":"Effects of the Vote-Power Block Snapshot on Delegations","text":"<p>The following table shows when new, changed, and revoked delegations take effect in relation to the vote-power block snapshot.</p> Delegation Type Before or After Vote-Power Block Snapshot When Delegation Takes Effect New or changed Before In the next reward epoch After After the next reward epoch ends Revoked N/A Immediately"},{"location":"tech/ftso/#delegation-procedure","title":"Delegation Procedure","text":"<p>You can delegate your tokens using the Flare Portal, a supported wallet like Bifrost, or a dapp. Some FTSO data providers have already started providing these dapps as a convenience. Take a look at flaremetrics.io and pick the one you prefer.</p> <p>If you are an advanced user, you can delegate manually by interacting directly with the FTSO smart contracts.</p>"},{"location":"tech/ftso/#rewards","title":"Rewards","text":"<p>A percentage of the annual network inflation is reserved to reward FTSO data providers and distributed uniformly among the year's reward epochs. The mechanism that distributes rewards to data providers consists of several bands:</p> <ul> <li>Primary reward band: This band rewards 50% of submitted data, weighted by vote power and centered around the median price. That is, the primary reward band fixes the rewarded vote power at 50%, which makes the width of the primary reward band in each epoch variable.</li> <li>Secondary reward band: This band rewards submitted data that falls within a fixed percentage around the calculated median. That is, the width of the secondary reward band is fixed, which makes the rewarded vote power in each epoch variable.</li> </ul> <p>Submitted data in each reward epoch belongs to one of the following:</p> <ul> <li>Primary reward band</li> <li>Primary and secondary reward band</li> <li>Neither reward band</li> </ul> <p>On Flare, reward epochs are 3.5 days. On Songbird, reward epochs are 7 days. In each reward epoch, rewards are distributed to providers whose submission falls within the primary or secondary reward bands.</p> <p>Because the secondary reward band is wider, it rewards more data providers than the primary band. However, submissions still must be close enough to the median to be included. If a submission falls within both bands, it receives both rewards because each reward band is independent.</p> <p>The secondary reward band receives 30% of all FTSO rewards, and the primary reward band receives the remaining 70%. As the FTSO system evolves, these reward percentages might be revised later, in accordance with an accepted proposal that requests changes to the secondary reward band.</p> <p>After the band rewards are distributed, each provider can take an optional, configurable fee, which is set to 20% by default, and distributes the rest of the reward among all contributors to its vote power, i.e., itself and all its delegators, according to the delegated amounts.</p> <p>If you delegated to a data provider, the amount of your rewards depends on multiple factors:</p> <ul> <li>The percentage of vote power you delegated</li> <li>The data providers to which you delegated your vote power</li> <li>The performance of those data providers</li> <li>The fee charged by those data providers</li> <li>Whether the total vote power of one or both of those data providers exceeded the vote power cap</li> </ul> <p>You can claim your rewards at the end of each reward epoch.</p> <p>You must claim your rewards within 90 days of their availability. After 90 days, unclaimed rewards on Flare are burned, and on Songbird, they are reallocated.</p>"},{"location":"tech/ftso/#reward-claiming-procedure","title":"Reward-Claiming Procedure","text":"<p>FTSO rewards are not automatically transferred to their recipients. Instead, the amounts are accumulated in a smart contract and must be claimed once the reward epoch is finished.</p> <p>You can claim your rewards using the Flare Portal, a supported wallet like Bifrost, or a dapp. Take a look at flaremetrics.io and pick the one you prefer.</p> <p>If you are an advanced user, you can claim manually by interacting directly with the FTSO smart contracts.</p> <p>To save on gas costs, rewards from multiple reward epochs are claimed simultaneously when you use the Portal. However, be aware that rewards expire after 90 days. Moreover, you probably want to claim soon, to redelegate the received amount and obtain compounded rewards.</p> <p>It is also worth noting that:</p> <ul> <li>Rewards are paid in the network's native currency. On Flare, the native token is <code>$FLR</code>, and on Songbird, the native token is <code>$SGB</code>.</li> <li>Data providers and their delegators must claim independently.</li> </ul>"},{"location":"tech/ftso/#related-user-guides","title":"Related User Guides","text":"<ul> <li>Managing delegations</li> <li>Managing rewards</li> <li>Wrapping tokens</li> </ul>"},{"location":"tech/ftso/#related-infrastructure-guides","title":"Related Infrastructure Guides","text":"<ul> <li>Operating a Data Provider</li> <li>Working with Whitelists</li> <li>Managing the Ecosystem</li> </ul>"},{"location":"tech/ftso/#related-developer-docs","title":"Related Developer Docs","text":"<ul> <li>FTSO Reference</li> <li>FTSO Tutorials</li> </ul>"},{"location":"tech/glossary/","title":"Glossary","text":"Account In blockchain, an account is a place to store tokens and smart contracts. Accounts are generated from private keys, and you typically need to know an account's private key to be able to transfer any token out of it. The crypto saying \"Not your keys, not your coins\" refers to this fact. An account is a synonym for wallet and address. Address In blockchain, an address is a synonym for wallet and account. Attestation A data proof provided to the State Connector by a decentralized set of Attestation Providers that confirms the validity or otherwise of any request. Autoclaiming Automatic claiming enables users to appoint an executor to claim rewards on their behalf. Read more... Avalanche An open-source blockchain using the Snow family of consensus protocols and Proof of Stake for Sybil resistance. It is advertised as the fastest smart contract platform. Read more... Block For performance reasons, blockchains do not process transactions one by one. Instead, transactions are grouped together in blocks which are then validated by the consensus algorithm. Block Explorer A tool that enables its users to analyze transactions and interact with addresses on blockchains. Read more... Blockchain Digital ledger storing data and transactions on a distributed network of computers to make it more robust. Cryptography protects against information tampering, and a consensus algorithm ensures that the majority of the network agrees on the stored data even if some of its nodes act maliciously. Bootstrapping Node An observation node associated with a validator node and acting as its bastion: the bootstrapping node exposes a minimum RPC interface, so the validator does not have to. The nodeID and nodeIP returned by the bootstrapping node's RPC allow an external node to connect and peer with the core network of validators. The bootstrapping node also gossips the core network's validators nodeIDs and nodeIPs to the external node to peer to. The main purpose of a bootstrapping node is to allow new nodes to connect to the network (hence the name \"bootstrapping\") while reducing its associated validator node attack surface. Flare offers some public bootstrapping nodes. Byzantine Fault Tolerance Property of a distributed system that is capable of continuous operation even when some of its participants are unreliable. Participants acting against the interest of the whole system, by accident or on purpose, are said to have \u201cgone Byzantine\u201d. Canary Network A network used for testing features under \u201creal fire\u201d conditions, before deploying them on the main network. All users of the canary network are real users, but they are aware of the experimental nature of the platform. The name comes from the time when actual miners used actual canaries to detect the presence of poisonous gas in the mines. Flare's canary network is called Songbird. Cold Wallet A wallet whose private key is only reachable from the internet when needed, spending the rest of the time in isolation. This makes it less vulnerable to theft than a key stored on a server permanently online (see hot wallet), as the window of opportunity for attackers is much smaller. Consensus Algorithm that makes nodes on a blockchain\u2019s network agree on the validity of a given transaction, even if some of the nodes provide invalid transactions or try to disrupt the network (Byzantine Fault Tolerance). Coston The name given to both of Flare's public test networks (Coston and Coston2), in remembrance and celebration of a great inventor, Martha J. Coston (1826-1904). Cross-chain (or inter-ecosystem) interoperability Communication between two or more disparate blockchain ecosystems that are technologically incompatible due to the lack of shared systems, protocols or code (e.g. Ethereum and Solana). DAO A Decentralized Autonomous Organization is an entity with no central authority. Its governance is mandated by rules encoded on a blockchain so it is tamper-proof. Dapp A Decentralized Application is a computer program that makes use of blockchain technology and therefore the information it uses or stores has the same benefits (trustlessness, censorship resistance, geographical redundancy, etc). The dapp itself may or may not be hosted on a blockchain. Data Provider Each of the multiple programs supplying external information to an FTSO running on the Flare network, and getting rewarded for it. Token holders can delegate their stake to a data provider and receive a share of the rewards. DeFi Decentralized Finance is a form of finance that does not rely on a central financial institution. DeFi is commonly based on blockchain technology. Delegate To assign a duty to someone else, so they do it for you. On the Flare network, an address can delegate any fraction of the votes associated with the tokens it holds to another address, for the purpose of FTSO weighting or governance participation. Note that no tokens are transferred. ERC-20 The Ethereum Request for Comments 20, proposed in November 2015, is an Ethereum token standard that implements an API for tokens within smart contracts. It is a standard for fungible (exchangeable) tokens, which have a property that makes each token exactly the same (in type and value) as another token. For example, an ERC-20 token acts just like Ethereum's ETH token, meaning that 1 token is and will always be equal to all the other tokens. Read more... EVM The Ethereum Virtual Machine allows executing smart contracts on the Ethereum network, regardless of the kind of computer that executes it. Multiple blockchain networks, including Flare, support EVM contracts. Read more... Executor Users who do not want to claim rewards themselves can set an executor to claim rewards for them and send them directly to their users' accounts. Read more... Faucet A dapp that distributes test tokens to anyone that requests them. Used only on test networks, obviously. See the Network Configuration page to learn about Flare's faucets. FBA Federated Byzantine Agreement is a form of Byzantine fault tolerance where each node keeps its own list of trusted nodes. It does not require nodes to invest stake or computing power as Proof of Stake or Proof of Work protocols do. FCP The Flare Consensus Protocol is an asynchronous, ordered and leaderless version of Federated Byzantine Agreement (FBA) consensus. The whitepaper is already available and it is currently in the process of being implemented. Read more... Flare Token (FLR) The native currency of the Flare's main network. Flash loan A loan that is requested and then repaid in a very short time, sometimes within the same block when combined with sandwiching. Front-running When a network validator reorders transactions before adding them to a block so that his own transactions appear before the rest, extracting value in the process. Compare with sandwiching. FTSO The Flare Time Series Oracles provide external information to the Flare network in a decentralized manner, by using multiple independent data providers that are rewarded for providing accurate information. Read more... Governance Mechanism to propose, vote and implement changes on a blockchain protocol. On Flare, anybody can propose updates and token holders vote to accept them. Hot Wallet A wallet whose private key is stored on a server connected permanently to the internet. This makes the key convenient to use by automated programs, but makes it more vulnerable to theft than an offline key (see cold wallet), as unauthorized access to the server could steal the key. Know Your Customer (KYC) The process an entity completes to verify the identities of its users to comply with global requirements. Layer 1 An L1 is a blockchain in the classical sense, in that it comprises a network of nodes that exchange information to guarantee the integrity of a shared ledger and offer functionality like token exchange and programmability. Compare it to an L2, which is built on top of an existing L1. Layer 2 An L2 is a blockchain built on top of an existing L1 making use of its programmability. L2 chains add extra functionality to the L1, like scalability. Ledger Historically, a book where financial transactions are recorded. In blockchain technology, a ledger can contain any kind of information, which has multiple copies distributed among several computers, kept in sync by a consensus algorithm. Light Client Relay A simplified communication mechanism built for speed that only queries the header data of any transaction and therefore lacks the security that comes from querying a full node with full history (e.g. SPV). Liquidity Pool A collection of funds locked in a smart contract for the purpose of facilitating trading, lending and other functionality in a decentralized manner. Main Network (MAINNET) The computer network that supports a blockchain in its production stage, i.e., the real thing (instead of a Canary or Test network). Metaverse An old concept, at times called Virtual Reality or Cyberspace, that translates human interaction to virtual (i.e. non-physical) worlds. Currently in vogue again because blockchain technology promises to link the physical and the virtual worlds and thus bring a degree of reality to the latter. Multi-chain (or intra-ecosystem) interoperability Communication between two or more technologically compatible blockchains that exist within the same ecosystem and share systems, protocols and code (e.g. Polkadot Parachains, Cosmos Tendermint chains or Ethereum layer 2 protocols). Multisignature (or multisig) An account linked to multiple private keys so that some operations require a configured number of keys to sign off. When N out of the total M possible key signatures are required, the account is called an N-of-M multisig. This provides additional security over common single-key accounts, because a few keys being compromised still cannot gain access to the account. NFT Non-Fungible Tokens are digital representations of assets which are unique and therefore non-mergeable (non-fungible), made impossible to copy by blockchain technology. Common use cases are certificates of authenticity or ownership, or limited edition collectibles. Most NFT tokens are built on the Ethereum network using standards ERC-721 and ERC-1155. Oracle A mechanism to provide external information to a blockchain, so that it can be used by smart contracts, for example. Flare oracles are called FTSO. Proof of Stake A kind of Sybil resistance based on staking assets to participate in consensus. The rationale is that a participant investing enough assets will not be interested in attacking the network that supports such assets. Moreover, if malicious behavior is detected part of the assets can be taken as punishment. Proof of Work A kind of Sybil resistance based on spending computer power to participate in consensus. The rationale is that attacking the network becomes prohibitively expensive in terms of computer power. Pruning A blockchain database reduction technique, which keeps the state of all addresses (like their balance) and the transactions that led to that state, but removes any old transaction that does not impact the current state anymore. Quantum Resistance The ability of a cryptographic algorithm (and therefore of a blockchain) to resist an attack from a theoretical quantum computer. Quorum Set of participants on a consensus algorithm that must agree on a result for the whole network to accept that result. On a blockchain, once consensus is reached about a block, it is added to the ledger and the next block is processed. Quorum Slice In FBA consensus each node has multiple lists of other nodes which it voluntarily decides to trust, forming its quorum slices. All nodes in a quorum slice agreeing on a result are enough to convince the node of that result. If the quorum slices are correctly built, global quorum emerges from these local quorum slices. RPC Remote Procedure Call is a protocol that allows a program executing on a computer to request a service from another program, typically running on a different computer. Flare offers some public and private nodes with RPC capabilities. Sandwiching When a network validator reorders transactions before adding them to a block so that its own transactions appear right before and after a target transaction, extracting value in the process. A typical example would involve flash loans. Compare with front-running. Smart Contract Computer program running on a blockchain, typically one based on the EVM. The blockchain\u2019s immutability ensures that the contract is not tampered with, and running it on several machines bound together by a consensus algorithm ensures faithful execution. Smart contracts are said to be self-enforcing. Songbird Flare's canary network, launched in September 2021. State Connector Piece of the Flare network that keeps track of the state of other networks, facilitating the implementation of advanced mechanisms like the FAssets. The State Connector uses several independent Attestation Providers that are rewarded for providing correct information. Read more... Stablecoin A cryptocurrency whose value is pegged to the value of another currency. For example, <code>$USDC</code> is a stablecoin pegged to the US dollar. Sybil Resistance The ability of a distributed system to overcome a Sybil attack, in which a malicious actor creates multiple identities to gain voting or mining power. Resistance is typically gained by making voting or mining too costly for the attack to be worth it (as in Proof of Work or Proof of Stake) or by requiring new entities to be approved by existing actors (as in FBA). Test Network (TESTNET) The computer network that supports a blockchain in its development stage. It is intended for testing purposes and should not store valuable assets, as its contents might be deleted (purposely or by accident) at any time. Among other facilities, testnets typically provide faucets. Compare to a Canary or a Main network. Flare's testnets are Coston for Songbird and Coston2 for Flare. Transaction A request to add information to the blockchain, which is then analyzed by the network and accepted when consensus is reached about its validity. It can be a movement of funds between two accounts, or the execution of a contract, for example. Transaction Fee Amount of cryptocurrency that must be paid by anybody submitting a transaction for inclusion on a blockchain. These fees reward block producers for their work processing transactions, and typically vary depending on network congestion. Token A digital representation of an asset. Fungible tokens are indistinguishable from one another so they can be merged together (e.g. a cryptocurrency). Non-fungible tokens (NFT) are unique and therefore cannot be merged. Turing-completeness The ability of a machine to solve any computational problem, no matter how complex, given the necessary steps and enough time and memory. This is a mandatory feature of any general-purpose processor like a CPU or the EVM. Validator A validator node is a machine connected to a blockchain network that verifies transactions and emits a vote. When there is a quorum among all validators regarding a given block of transactions, they are accepted into the blockchain. Voting Power Weight proportional to the tokens held by an address plus the tokens delegated to it. This weight is used during FTSO operation and governance votes, for example. Wallet In blockchain, a wallet is a synonym for account and address. Wen flare The war cry of all the impatient that would like to see the Flare network launch before it is fully tested. Pay no heed to them. Zero address A special address represented as <code>0x0000000000000000000000000000</code>. Also known as the null address, it is typically used as a return value from functions to indicate an error condition."},{"location":"tech/governance/","title":"Governance","text":""},{"location":"tech/governance/#introduction","title":"Introduction","text":"<p>Flare governance gives everyone in the ecosystem the opportunity to collaborate on decision-making on the Flare and Songbird networks, making governance an important element of decentralization.</p> <p>This process enables the Flare Foundation and Flare and Songbird community members to:</p> <ul> <li>Propose policy changes.</li> <li>Vote on them.</li> <li>Execute them if accepted.</li> </ul> <p>The following sections detail the different kinds of proposals Flare allows and the process for each of them.</p> <p>If you are already familiar with Flare's governance and just need to know how to cast your vote through the Flare Portal, check the Voting User Guide.</p>"},{"location":"tech/governance/#flares-governance","title":"Flare's Governance","text":"<p>Excluding the testnets Coston and Coston2, Flare currently has two networks: Flare and Songbird. Moreover, two kinds of proposals are planned, depending on who initiates them: those proposed by the community and those proposed by the Flare Foundation.</p> <p>This situation leads to four types of proposals, of which only two are currently supported and detailed next.</p>"},{"location":"tech/governance/#flare-improvement-proposals-and-songbird-test-proposals","title":"Flare Improvement Proposals and Songbird Test Proposals","text":"<p>Flare Improvement Proposals (FIPs) and Songbird Test Proposals (STPs) are initiated by the Flare Foundation and are aimed at improving the Flare and Songbird networks. Community-initiated proposals will be supported later.</p> <p>To increase its stability, FIPs are rejected by default, meaning that they are accepted only if enough votes are cast in their favor.</p> <p>To increase the swiftness at which new proposals can be tested on Songbird, STPs are accepted by default, meaning that they are rejected only if enough votes are cast against them.</p> <p>See Voting Outcomes below for more details.</p>"},{"location":"tech/governance/#who-votes","title":"Who Votes","text":"<p>To vote on a proposal on a network, you must have the valid wrapped token:</p> Network Proposal Type Token Wrapped Token Flare FIP <code>$FLR</code> <code>$WFLR</code> Songbird STP <code>$SGB</code> <code>$WSGB</code> <p>Warning</p> <ul> <li>Available votes depend on the amount of valid wrapped tokens you have, not the native tokens. Therefore, remember to wrap your tokens.</li> <li>Don't wrap all your tokens. Keep some of them to pay for transaction fees.</li> <li>To vote with your tokens, they must be wrapped before the proposal is submitted.</li> </ul> <p>The Flare Foundation announces proposals in advance, so that users can read them and wrap their tokens if they have to.</p> Vote Transfer <p>Votes can be transferred to another account while the wrapped tokens remain in your possession. Being able to transfer votes is useful, for example, if you have wrapped tokens in multiple self-custody wallets, because voting can then be simplified by transferring all the votes to a single wallet and voting from there.</p> <p>Votes can only be transferred to one address, but it can receive votes from multiple addresses. Received votes cannot be transferred again to a third address.</p> <p>Once activated, vote transfers always send 100% of an account's votes to the selected address and remain active until they are canceled.</p> <p>As an example, if you have 100 <code>$WSGB</code> before a proposal and you activate the transfer, you will transfer 100 votes. If you later add 100 more <code>$WSGB</code>, for the next proposal you will automatically transfer 200 votes, since the transfer remains active until you cancel it.</p> <p>The following is a more complex example, showing the changes produced by vote transfers, and token wrapping and unwrapping on Songbird:</p> <p> Changes in the number of votes on Songbird. </p> <p>Note</p> <p>Transferring votes has no connection with FTSO delegation: Wrapped tokens can be delegated to an FTSO data provider and at the same time the votes they grant can be transferred to a different address.</p>"},{"location":"tech/governance/#the-vote-count-block","title":"The Vote Count Block","text":"<p>Since the amount of wrapped tokens an account holds varies over time, a snapshot of all accounts is taken before each voting period starts. The amount of wrapped tokens held by an account at the snapshot then dictates the number of votes available later.</p> <p>The block at which the snapshot is taken is called the vote count block.</p> <p>To encourage users to use their tokens and keep them in the network, instead of just acquiring them for voting and then disposing of them, the vote count block is randomly selected. The next section details when this happens.</p>"},{"location":"tech/governance/#voting-process","title":"Voting Process","text":"<p>The image in this section shows the voting process, which includes several conditions:</p> <ul> <li> <p>Threshold condition: A minimum quorum must be reached, meaning that enough votes must be cast, or no minimum quorum is required.</p> </li> <li> <p>Majority condition: More than 50% of the votes cast, must be for or against the proposal.</p> </li> </ul> <p> </p> Voting process. <ul> <li> <p>Announcement: The Flare Foundation publishes the proposal online and announces it through social media channels (linked on the footer of this page) and the Flare website.</p> </li> <li> <p>Notice period: Once the proposal is published, the Flare Foundation allows a notice period before voting can start, typically lasting one week.     During this time the proposal can be discussed, clarified, commented on, and even cancelled if serious issues are found with it.</p> <p>For security reasons only, the Foundation may reduce the timeframe of this period.</p> </li> <li> <p>Block selection period: The vote count block is selected at a random time during this period.     The duration of this period is also random.</p> <p>Warning</p> <p>If you need to wrap tokens, do so before this period starts since tokens wrapped after the selected vote count block will not result in additional votes.</p> </li> <li> <p>Voting period: The proposal is submitted to the Flare Portal, and it is immediately available for voting.     Voting concludes after a week, and final results are presented on the portal.</p> </li> </ul>"},{"location":"tech/governance/#voting-outcomes","title":"Voting Outcomes","text":""},{"location":"tech/governance/#fips","title":"FIPs","text":"<p>Voting on FIPs is acceptance-based. For an FIP to be accepted, a simple majority of the votes cast must be in favor of it. No minimum quorum is required.</p> <p>Therefore, an FIP will be rejected only if less than half of the cast votes are for it.</p>"},{"location":"tech/governance/#stps","title":"STPs","text":"<p>Voting on STPs is rejection-based. For an STP to be rejected, both of the following conditions must be true:</p> <ul> <li> <p>Threshold condition: The minimum quorum is at least 75% of all <code>$SGB</code> tokens circulation (excluding the Flare Foundation's tokens) at the vote count block.</p> <p>Note that the quorum is specified as a fraction of the circulating native <code>$SGB</code> tokens instead of the wrapped tokens <code>$WSGB</code> used for voting. This measure tries, again, to encourage users to wrap their tokens and use them in the network.</p> </li> <li> <p>Majority condition: More than 50% of the votes cast, must be against the proposal.</p> </li> </ul> <p>Therefore, an STP will be accepted if the quorum threshold is not reached or if less than half of the cast votes are against it.</p>"},{"location":"tech/governance/#execution","title":"Execution","text":"<p>Once a proposal is accepted, Flare's governance contracts allow for its automatic execution via a contract call.</p> <p>However, some proposals might require changes that are not implementable through a smart contract and therefore automatic execution is disabled for them. Both FIPs and STPs are manually executed by the Flare Foundation.</p>"},{"location":"tech/governance/#related-user-guides","title":"Related User Guides","text":"<ul> <li>Voting</li> </ul>"},{"location":"tech/personal-delegation-account/","title":"Personal Delegation Accounts","text":"<p>Flare token holders are eligible to receive a number of rewards, for example through FTSO Delegation. The Flare network offers the option to set up Personal Delegation Accounts (PDAs) to temporarily receive and store rewards to track which funds are from rewards, for example, for personal or tax purposes. In certain jurisdictions, delaying the realization of earnings for a specified time can lead to a reduced tax rate.</p> <p>Each Flare address can be associated with one PDA, which behaves like a regular account in many respects. For example, it can receive funds from any address. Like regular accounts, it is under control of the owner and can perform functions such as delegation and claiming.</p> <p>Here are some of the differences from a regular account:</p> <ul> <li>A PDA cannot have another PDA of its own.</li> <li>PDA addresses cannot participate in governance directly, but their owners can transfer all their votes to another address (their main account or someone else's).</li> <li>A PDA automatically converts any <code>$FLR</code> tokens transferred to it to wrapped Flare tokens (<code>$WFLR</code>), which are more useful for functions such as delegation.</li> <li>Only the owner of the main account can transfer funds from the PDA and only to the main account.</li> <li>When an executor is configured, it will claim rewards both from the main account and the PDA, and send them to the PDA.</li> </ul> <p>Warning</p> <p>The Flare Foundation is not liable for any damages, especially pertaining to tax related issues when using this service. Check your local tax laws.</p> <p>Developing PDA functionality</p> <p>For information on how to develop a PDA, or how to write an application that supports a PDA, see Personal Delegation Accounts in the Developer section.</p>"},{"location":"tech/personal-delegation-account/#related-user-guides","title":"Related User Guides","text":"<ul> <li>Managing your PDA</li> </ul>"},{"location":"tech/personal-delegation-account/#related-developer-docs","title":"Related Developer Docs","text":"<ul> <li>Managing PDAs in applications</li> </ul>"},{"location":"tech/state-connector/","title":"State Connector","text":""},{"location":"tech/state-connector/#introduction","title":"Introduction","text":"<p>The State Connector is a smart contract running on the Flare network that allows anyone to query non-changing, verifiable information (such as blockchain or geographic data) from outside the Flare network. Data that changes, such as the latest BTC to USD conversion rate, and non-verifiable data, such as data behind a paywall, are not available through the State Connector.</p> <p>The State Connector accesses data in a decentralized manner (no single party is in control of the process) and securely (it takes a lot of effort to disrupt the process). This is accomplished by using a set of independent attestation providers which fetch the required information from the world and deliver it to the Flare network. The State Connector smart contract then checks if there is enough consensus among the received answers and publishes the results if so.</p> <p>As an added security measure, individual validators can also define local attestation providers which, when in disagreement with the rest, cause the validator to branch into an idle, safe state while the situation is resolved.</p> <p> </p> The State Connector. <p>The State Connector can, for instance, check whether a deposit has been made on another blockchain, opening the door to more advanced mechanisms like the FAsset or the Layer Cake bridges.</p> <p>This page gives technical details about the whole procedure, the different security and scalability measures that have been taken into account in its design and the kind of queries that can be performed.</p>"},{"location":"tech/state-connector/#procedure-overview","title":"Procedure Overview","text":"<p>This is how user queries are processed. The following sections contain more details.</p> <p> </p> State Connector procedure overview."},{"location":"tech/state-connector/#1-request","title":"1. Request","text":"<p>Anybody, be it a smart contract running on Flare or an application, can request the attestation of a specific event from the State Connector.</p> <p>Requests are yes/no questions regarding things that happened outside the Flare network, for example, \"Has transaction 0xABC been confirmed on the Bitcoin network enough times?\". The answers, though, might contain any kind of additional data attached, like the content of transaction 0xABC, for example.</p> <p>Requests must adhere to one of the available request types, which have been designed to be strictly decidable, i.e., the answers are objective and cannot be argued. Otherwise, queries like \"What is the weather like in Paris?\" would have a hard time reaching consensus among the different attestation providers. Section Adding New Attestation Types below contains more details.</p> Making a request (for App developers) <p>Make your requests using the <code>requestAttestations</code> method (#2) of the StateConnector contract:</p> <pre><code>function requestAttestations(\n    bytes calldata data\n) external;\n</code></pre> <p>The <code>requestAttestations</code> method has a single parameter, <code>data</code>, which is a byte array with a content that depends on the desired request type. You can learn how to build this array in the state-connector-attestation-types repository.</p>"},{"location":"tech/state-connector/#2-request-forwarding","title":"2. Request forwarding","text":"<p>The State Connector simply forwards the request to all connected attestation providers through an EVM event. Therefore, the request is not stored on the blockchain and its gas cost is very low for the requester.</p>"},{"location":"tech/state-connector/#3-data-retrieval","title":"3. Data retrieval","text":"<p>Attestation providers fetch the requested data by means that depend on the type of attestation, for example, retrieving data from another blockchain or public API.</p> <p>Keep in mind that attestation providers are not controlled by Flare in any way. Anybody can listen to the request events and provide answers using any combination of hardware, software, and code they see fit.</p>"},{"location":"tech/state-connector/#4-attestation","title":"4. Attestation","text":"<p>To prevent attestation providers from peeking at each other's answers, these are submitted in a \"Commit and Reveal\" fashion called the CCCR protocol and detailed below.</p> Submitting an attestation (For attestation provider developers) <p>Attestation providers use the <code>submitAttestation</code> method (#3) of the StateConnector contract:</p> <pre><code>function submitAttestation(\n    uint256 _bufferNumber,\n    bytes32 _commitHash,\n    bytes32 _merkleRoot,\n    bytes32 _randomNumber\n) external returns (\n    bool _isInitialBufferSlot\n);\n</code></pre> <p>Keep reading to understand the meaning of the parameters. More information in the Attestation Client repository.</p>"},{"location":"tech/state-connector/#5-consensus","title":"5. Consensus","text":"<p>If at least 50% of the attestation providers submitted the same answer, it is made public. Otherwise, no consensus is achieved: requests remain unanswered and must be issued again.</p> <p>The answers are stored in the State Connector smart contract for a week, where anybody can read them, including the original requester.</p> Retrieving your request's answer (for App developers) <p>To retrieve the stored answers just read the <code>merkleRoots</code> public array (#8) in the StateConnector contract.</p> <p>More information on how to retrieve a particular answer in the State Connector contract source code.</p> <p>As shown below, multiple answers are actually packed into a single Merkle root. The Attestation Packing section explains how to retrieve an individual answer.</p>"},{"location":"tech/state-connector/#attestation-protocols","title":"Attestation Protocols","text":"<p>For simplicity, the above description omitted two very important mechanisms, reviewed here.</p> <p>The main one is Attestation packing, which decouples the number of requests from the number of answers, effectively providing unbounded scalability. It requires requests to be first collected and then answered all at once, so a protocol called CCCR is used.</p>"},{"location":"tech/state-connector/#overlapped-cccr-protocol","title":"Overlapped CCCR Protocol","text":"<p>Requests and answers are submitted sequentially in attestation rounds. Each attestation round has 4 consecutive phases, called Collect, Choose, Commit and Reveal.</p> <p>Phases happen in 90-second windows, and the Choose and Commit phases share the same window, so a whole attestation round takes 4.5 minutes.</p> <p> </p> The Collect-Choose-Commit-Reveal (CCCR) protocol. <ul> <li>Collect phase: Users send their requests to the State Connector contract which forwards them to every attestation provider.</li> <li>Choose phase: Attestation Providers vote on which requests they will be able to answer in the current round.</li> <li>Commit phase: Attestation providers send obfuscated answers to the State Connector, so they cannot cheat by peeking at each other's submissions.</li> <li>Reveal phase: Attestation providers send the deobfuscation key so their previous answers are revealed.   When all data is available, answers are made public if there is enough consensus.</li> </ul> <p>The CCCR protocol is akin to making submissions in a closed envelope which is not opened until all submissions are received.</p> <p>Results are available at the end of the Reveal phase, so the answer to a particular request can take anywhere from 3 to 4.5 minutes, depending on the time in which the request was made inside the Collect phase.</p> <p>Furthermore, the phases of the CCCR protocol are actually overlapped, so while requests are being collected for round \\((n+2)\\), answers are being simultaneously committed for the previous round \\((n+1)\\), and revealed for the round prior to that \\((n)\\).</p> <p> </p> The CCCR protocol with overlapped phases. <p>This means that new requests can be made without waiting for the previous ones to be completed.</p>"},{"location":"tech/state-connector/#attestation-packing","title":"Attestation Packing","text":"<p>Each round, attestation providers build a Merkle tree with the hashes of all valid answers to the requests that were agreed upon during the \"Choose\" phase. The obtained Merkle root is then called the Attestation Proof, since it is proof of the presence of each individual answer. Finally, the attestation proof is submitted to the State Connector for consensus evaluation.</p> <p> </p> Attestation Proof packing using a Merkle tree. <p>This allows any number of requests to be answered with a single hash, greatly improving scalability. Furthermore, the gas cost for attestation providers is constant each round, no matter how many requests they are answering.</p> <p>A request is only valid (and therefore added to the proof) if it is well-formed and it matches reality. Different providers might have different views on what reality is, and this is why the State Connector runs a consensus algorithm on the received answers.</p> <p>Additionally, the allowed request types are carefully designed to minimize the probability of contention. For example, requiring some time for transactions to settle before inquiring about them, and forcing requests to include the hash of a later block that confirms the transaction.</p> <p>Attestation providers keep the actual retrieved data for a week, in case it contains additional information beyond the yes/no result. Users can request this data directly from the providers through the Proof API.</p> <p>Note</p> <p>Please note that this data is safe to use even though it is obtained directly from the provider, because its hash is consistent with the Attestation Proof agreed upon by the State Connector's consensus.</p> <p>See the \"Proof unpacking\" box below to learn how to verify the data.</p> <p>Additional points worth noting:</p> <ul> <li> <p>If two attestation providers observe a different validity for any of the requests in the round, they will submit a completely different Attestation Proof.</p> </li> <li> <p>Attestation providers must answer all agreed-upon queries in the round or abstain from participating in the round, otherwise, their Merkle tree root will not match other providers and will probably be discarded by consensus.</p> </li> <li> <p>Hashes are sorted before being added to the tree, just to have a consistent ordering (albeit arbitrary).</p> </li> <li> <p>The exact way in which the root hash is calculated can be changed without impacting the State Connector contract, which will continue to vote only on the hash value.</p> </li> </ul> Proof Unpacking (for App developers) <p>The procedure for apps to check whether the State Connector answered yes or no to their request is detailed in the Attestation Client repository. What follows is an illustrative summary.</p> <p>The basic idea is that you must retrieve all data (both requests and answers) for the round from an attestation provider. You then rebuild the Merkle tree with this data and check that it matches the Attestation Proof provided by the State Connector.</p> <p> Proof unpacking. </p> <ol> <li> <p>In the attestation round after you made the request (3 attestation phases, so from 3 to 4.5 minutes) the Attestation Proof for the round should be available in the State Connector.     Retrieve it using method <code>getAttestation</code> (#7) of the StateConnector contract.</p> </li> <li> <p>Select any attestation provider you want and use the Proof API path <code>api/proof/votes-for-round/{roundId}</code> to retrieve all data for the round.</p> </li> <li> <p>Rebuild the Merkle tree for the retrieved data. There are tools to help you, like the MerkleTree.ts library.</p> </li> <li> <p>Check that the tree's root matches the Attestation Proof from step 1. If it does not match, this provider did not submit the answer agreed by the majority. Choose another provider in step 2.</p> <p>Conversely, you can use the <code>api/proof/get-specific-proof</code> API in step 2 which does steps 2, 3 and 4 for you. This API returns the JSON response data, including the attestation proof, if the attestation request was successfully verified in the given round.</p> </li> <li> <p>Now that you know that the retrieved data has been agreed upon by the consensus, you can use it. Look for your request inside the returned data. If it is not present, your request was deemed invalid (for example, the queried transaction was not present).</p> <p>Otherwise, your request is valid and you can find any extra information about it in the data array.</p> </li> </ol>"},{"location":"tech/state-connector/#branching-protocol","title":"Branching Protocol","text":"<p>Besides the consensus algorithm that runs on all received attestations, the State Connector provides one further security mechanism: the ability of any individual validator node to fork and halt execution if attestation providers specially trusted by it disagree with the majority.</p>"},{"location":"tech/state-connector/#attestation-provider-sets","title":"Attestation Provider Sets","text":"<p>To achieve this, two sets of attestation providers are defined:</p> <ul> <li> <p>Default attestation providers set</p> <p>Anybody can submit attestations to the State Connector, but the contract will only accept submissions from attestation providers in the default set. Every validator node in the Flare network relies on this set.</p> </li> <li> <p>Local attestation providers set</p> <p>Additionally, each node operator can provide a list of local attestation providers to be accepted besides the ones from the default set.</p> <p>Local providers are the same kind of nodes as default providers, and they are treated exactly the same by the State Connector. Furthermore, providers can belong to both sets.</p> </li> </ul> <p> </p> Default and Local attestation providers. <p>Then, for an attestation round to succeed these three conditions must be met:</p> <ul> <li> <p>The default set must agree on a result (50% consensus inside the set).</p> </li> <li> <p>The local set must agree on a result too (50% consensus inside the set).</p> </li> <li> <p>Both results must match.</p> </li> </ul> <p>Otherwise, the round is undecided and no answer is made public.</p> <p>This gives local attestation providers the capacity to stop results from being approved if they don't agree with their own observations. Ideally, local providers are managed by the same entity controlling the validator node using them, so they can be trusted implicitly.</p> <p>As a consequence of different validators using different attestation providers, sometimes State Connector queries can get different results on some validators, which naturally leads to chain forks.</p> <p>Typically, blockchains allow every branch in a fork to coexist and grow independently, until the discrepancy is detected and resolved. At that point, any branches deemed invalid are removed and all the validators that were following them experience a rollback: All transactions that happened after the fork are reverted and the state of those validators is synchronized with the rest of the network.</p> <p>When dealing with forks caused by the State Connector, the Flare network implements an extra security measure: Validators whose local attestation providers disagree with the default set halt execution after the fork, ensuring that they will not suffer any rollback once the fork is resolved.</p> <p>In other words, these validators remain in a safe state in which the disputed query is undecided and therefore no action is taken based on it.</p> <p>Example</p> <p> State Connector forks. </p> <p>In the example picture, all validator nodes use the attestation providers from the default set (not shown), but validators on the rightmost column, additionally, employ local providers. One of them returns a different answer for one of the queries, which leads to a fork of the chain since that validator's state does not match the rest of the network (the divergent ledger, depicted in red).</p> <p>The next section shows how forks are resolved and halted nodes restarted.</p>"},{"location":"tech/state-connector/#branch-resolution","title":"Branch Resolution","text":"The two states of the branching protocol. <p>The picture above shows the state of the network after a fork. The default network state is the one followed by validators which only use the default set of attestation providers. The alternate network state is where validators go if they use local attestation providers, and they disagree with the default set.</p> <p>In the alternate state no queries are answered and no blocks are produced, so it is a safe state for validators to wait for forks to be resolved.</p> <p>This resolution must come from operators when they are alerted that a validator node has stopped. To understand how to do this, note that attestations are designed to be objectively decidable, meaning that in the event of a fork one branch matches reality and the other does not.</p> <p>There are therefore only two ways to resolve a fork:</p> <ol> <li> <p>When local providers are wrong:</p> <p>The operator of the separated validator needs to find out why the local attestation providers failed and either fix them or remove them from the local set of the validator.</p> <p>Once this is fixed, the node simply rewinds its state to where it split and quickly fast-forward to rejoin the default state.</p> <p> Fork resolution when local providers are wrong. </p> <p>Note that no transactions need to be rolled back, on either branch.</p> <p>In the event of this kind of fork, dapps depending on information from a separated validator just have to wait longer to get their result.</p> </li> <li> <p>When the default set is wrong:</p> <p>First off, this is a very delicate situation and it should be rare.</p> <p>The default set uses consensus among attestation providers which have been chosen due to their merits as FTSO data providers. The fact that more than 50% of them are reporting data inconsistent with reality can be considered a 51% attack.</p> <p>The operator of the separated validator, upon convincing themselves that their branch is the correct one (it matches reality) they need to bring the fork to the attention of the misbehaving attestation providers' operators.</p> <p>All validators in the default state then need to roll back to the last correct state (reverting transactions) and continue from there on the forked branch, which becomes the new default state.</p> <p> Fork resolution when the default set is wrong. </p> <p>Note that stopped nodes can resume now, and they never had to roll back any transaction.</p> </li> </ol> <p>In summary, validators using at least one reliable local attestation provider do not have to worry about rollbacks, even in the face of 51% attacks.</p>"},{"location":"tech/state-connector/#attestation-types","title":"Attestation Types","text":"<p>Some attestation types are already defined. Attestation providers provide attestations for these types of defined requests:</p> <ul> <li>Payment: Whether a payment transaction occurred in which funds were sent from one address to another address.</li> <li> <p>Balance-decreasing transaction: Whether a transaction that might have decreased a balance occurred. This type allows for several possibilities:</p> <ul> <li>During a transaction, funds, including fees, were deducted from the balance at an address. As a result, the final balance at the address is less than the balance was before the transaction.</li> <li>During a transaction, funds to pay for fees were deducted from the balance at an address at the same time as more funds arrived. As a result, the balance at the address experienced a decrease, but the final balance is more than the balance was before the transaction.</li> </ul> </li> <li> <p>Confirmed block height: Whether a block on a certain height exists and was confirmed.</p> </li> <li> <p>Referenced payment nonexistence: Whether an account did not receive funds from a different account by a specific deadline. This type can serve as proof that a user's payment obligations to a DeFi protocol have been breached, considering the following cases:</p> <ul> <li>The required transaction was not confirmed on time.</li> <li>The required transaction was confirmed on time but failed because of an error made by the sender.</li> </ul> </li> </ul>"},{"location":"tech/state-connector/#adding-new-attestation-types","title":"Adding New Attestation Types","text":"<p>New real-world event-type integrations are introduced to the State Connector via acceptance by the default attestation providers, without requiring any changes to the core voting or branching protocols described above. This enables rapid deployment of new use-cases without any validator-level code changes.</p> <p>See the state-connector-attestation-types repository for more information.</p>"},{"location":"tech/the-flaredrop/","title":"The FlareDrop","text":"<p>The FlareDrop, previously called the Delegation Incentive Pool in the FIP.01, is a distribution method for the 24.25B remaining <code>$FLR</code> tokens after the original airdrop. It will last for 36 months and is destined for any holder of wrapped <code>$FLR</code> (<code>$WFLR</code>) that participates in the network as per the FIP.01.</p> <p>If you enabled your PDA and it contains <code>$WFLR</code>, it is also eligible to receive the FlareDrop distribution. Make sure to check both your Main Account and your Delegation Account for FlareDrop to claim.</p>"},{"location":"tech/the-flaredrop/#how-is-the-flaredrop-distributed","title":"How Is the FlareDrop Distributed?","text":"<p>The FlareDrop is distributed monthly over 36 30-day bank months to those that wrap their <code>$FLR</code> tokens. Each of the first 35 monthly allocations constitute 2.37% of the total FlareDrop, and the last one 2.05%.</p> <p>The total amount of <code>$WFLR</code> is calculated each month, and the monthly allocation is distributed among all <code>$WFLR</code> holders proportionally to the sampled average of their <code>$WFLR</code> balance. Users then receive an amount equal to their month's sampled <code>$WFLR</code> holdings divided by the month's total <code>$WFLR</code>, multiplied by the monthly allocation.</p> <p>Calculating an address's sampled average balance</p> <p>As each bank month passes, the FlareDrop receives a trigger to choose 3 random blocks in the previous 23 days. The FlareDrop smart contract then finds the average of the total <code>$WFLR</code> reported in those blocks and determines each address's percentage of the FlareDrop.  3-week average of wrapped <code>$FLR</code>. </p> <p>Upon claiming, the entitlement is sent directly to the account you claimed from. It is sent as <code>$FLR</code> to your Main Account and as <code>$WFLR</code> to your Personal Delegation Account (PDA). Each distribution expires two bank months and a week (67 days) after it becomes claimable and expired tokens are burned.</p> <p>To ensure having no effect on the amount of <code>$FLR</code> that each claiming address receives, Flare Foundation and team addresses opt out of the FlareDrop distribution.</p> <p>Two steps to ensure receiving all your <code>$FLR</code> !</p> <p>You must:</p> <ol> <li>Wrap <code>$FLR</code> to receive it. Rewards are proportional to the <code>$WFLR</code> balance, not <code>$FLR</code>, so always wrap as much <code>$FLR</code> as you can! Wrapping has no downside: Wrapped tokens continue to be available for delegation and governance voting, for example, and they can be unwrapped at any time.</li> <li>Claim before the distribution expires. After the distribution becomes claimable, it expires in two bank months and a week (67 days).</li> </ol> <p>You can also enable automatic claiming to make sure you don't miss any FlareDrop! Autoclaiming will claim for both your main account and your PDA if you enabled it.</p>"},{"location":"tech/the-flaredrop/#related-user-guides","title":"Related User Guides","text":"<ul> <li>Claiming the FlareDrop</li> <li>Wrapping tokens</li> </ul>"},{"location":"tech/the-flaredrop/#related-developer-docs","title":"Related Developer Docs","text":"<ul> <li>The FlareDrop</li> </ul>"},{"location":"tech/validators/","title":"Validator Nodes","text":""},{"location":"tech/validators/#blockchain-validation","title":"Blockchain Validation","text":"<p>Validator nodes are online servers running a blockchain's client software. They all keep their own copy of the ledger and are constantly talking to other nodes to make sure the copies are consistent with each other as new data is added.</p> <p> </p> A network of validator nodes, each one with an identical copy of the ledger. <p>The fact that the ledger is not under control of a single entity but distributed among a network of independent validators is what makes blockchains:</p> <ul> <li>Require less trust than traditional options.</li> <li>Censorship resistant.</li> <li>Byzantine fault-tolerant.</li> </ul> <p>Validators agree on the state of the ledger using a consensus algorithm that varies for each blockchain. For example, Flare uses the Snowman++ consensus protocol from Avalanche.</p> <p>Snowman++</p> <p>During each round, a validator is randomly selected to act as the leader and propose new blocks to be added to the ledger, which are then validated by the rest of nodes. To provide Sybil resistance, the probability that a node is elected the leader is proportional to the node's stake, effectively enacting a proof-of-stake consensus.</p> <p>With its vision to be the blockchain for data, Flare adds the FTSO Data provider and Attestation Provider roles to validators, creating a single infrastructure entity.</p> <p>When fully operational, these decentralized infrastructure entities are responsible for:</p> <ul> <li>Securing the network through proof-of-stake consensus.</li> <li>Providing continuous data to the FTSO system.</li> <li>Answering the State Connector's queries for attestations.</li> </ul> <p>In this way, the stake required to operate these entities secures all three functions.</p> <p>Infrastructure entities are rewarded for each one of these roles, a process that involves staking on the P-chain and rewards that are calculated on smart contracts running on the C-chain.</p>"},{"location":"tech/validators/#deployment-phases","title":"Deployment Phases","text":"<p>Deployment will occur in different phases for a number of reasons:</p> <ul> <li>Infrastructure entities will be onboarded progressively, to ensure the uninterrupted working of the network.</li> <li>Current FTSO data providers need to build a minimum stake to act as validators.</li> <li>Current validators need to upgrade their capabilities to act as data providers.</li> </ul> <p>Each phase will increasingly relinquish control, so more network validation will happen independently of the Flare Foundation.</p>"},{"location":"tech/validators/#initial-state","title":"Initial State","text":"<p>Upon network launch on July 14th 2022, a set of 20 validators had their node IDs hard-coded into the client software, so no other validators could participate. The Flare Foundation managed these nodes and gradually reassigned 16 of them to 4 external entities to achieve greater decentralization. These entities, known as professional validators, are infrastructure providers with experience managing blockchain nodes.</p> <p>During this period FTSO data providers operated completely independently of validators. The State Connector protocol was still being developed, so no attestation providers were available.</p>"},{"location":"tech/validators/#phase-1","title":"Phase 1","text":"<p>On July 2023 a network fork enabled Avalanche's proof-of-stake mechanism. From this moment, validation was open to everybody. At the same time, all the stake from the original validators expired.</p> <p>The Flare Foundation loaned all the stake for the initial validators, so the distribution of validation power remained the same while proof-of-stake was being tested.</p> <p>Later, after some FTSO data providers went through a KYC process, the Flare Foundation loaned enough funds to them to deploy validation nodes and act as validators.</p> <p>Because staking happens on the P-chain, staked tokens cannot access the rewards managed by smart contracts running on the C-chain. To solve this problem, a communication mechanism between the two chains is being developed.</p> <p>All staking rewards are manually calculated off-chain, and then distributed on-chain. The calculations will initially be private while they are fine-tuned, and the script will be made public in phase 2 so that anybody can verify them.</p>"},{"location":"tech/validators/#phase-2","title":"Phase 2","text":"<p>Once FTSO data providers have gathered enough stake to ensure the network's continued working, all stake loaned by the Flare Foundation to the validators in the initial state will be withdrawn. Professional validators are expected to cease operating at this point, unless they provide their own stake.</p> <p>The Flare Foundation might delegate stake to FTSO data providers that went through the KYC process, to help kick-start the system. This is known as stake boosting and will run only for a limited amount of time.</p> <p>Staked funds can earn FlareDrops and participate in governance, but not earn FTSO rewards.</p> <p>Staking rewards will:</p> <ul> <li>Take into account validator uptime, which can be publicly monitored.</li> <li>Take into account staked amount.</li> <li>Require that the validator is also an FTSO data provider that is being constantly rewarded for providing good enough prices.</li> <li>Be manually calculated off-chain using a public script, and then distributed on-chain.</li> </ul>"},{"location":"tech/validators/#phase-3","title":"Phase 3","text":"<p>After secure communication between the P- and C-chains is available, staking rewards will be managed entirely on-chain. The goal is that funds staked on the P-chain will have the same rights as wrapped <code>$FLR</code> on the C-chain, opening the possibility to earn FTSO rewards, FlareDrops and participate in governance.</p>"},{"location":"tech/validators/#summary","title":"Summary","text":"Launch Phase 1 Phase 2 Phase 3 Validation open to everybody \u2718 \u2714 \u2714 \u2714 Validators must provide own stake \u2718 \u2718 \u2714 \u2714 Validators must be data providers to earn rewards \u2718 \u2718 \u2714 \u2714 Locked stake can earn staking rewards \u2718 \u2718 \u2714 \u2714 Staking rewards are handled on-chain \u2718 \u2718 \u2718 \u2714 Same rights for staked and wrapped tokens \u2718 \u2718 \u2718 \u2714"},{"location":"tech/validators/#related-infrastructure-guides","title":"Related Infrastructure Guides","text":"<ul> <li>Deploying a Validator Node</li> </ul>"},{"location":"tech/archive/","title":"Archive","text":"<p>This section archives old information.</p> <p>Select one of the topics below:</p> <ul> <li>Flare Launch Process</li> </ul>"},{"location":"tech/archive/flare-launch-process/","title":"Flare Launch Process","text":"<p>The Flare launch included a rather large airdrop, a community vote, and the deployment of a novel meritocratic consensus system. Because of its complexity, it was divided into a series of sequential phases with clearly-defined triggers that signaled each transition.</p> <p>The following information was intended to remove any confusion around the launch process by clearly describing the purpose of each phase and what happened in them.</p> <p> Click on a phase to navigate to its description. </p>"},{"location":"tech/archive/flare-launch-process/#definitions","title":"Definitions","text":"<p>The following definitions make the rest of this page clear and unambiguous.</p> <ul> <li> <p>FIP.01: A governance proposal that, among other things, changed the initial token distributions as explained below. This proposal needed to be voted on according to the schedule described in this page.</p> </li> <li> <p>Flare Airdrop for XRP Holders: Certain holders of XRP tokens on Dec 12, 2020, were eligible to register for the FLR token distribution (then called Spark tokens) once the Flare network launched.</p> <p>The FIP.01 proposal modified the way in which the airdrop worked.</p> </li> <li> <p>Original Airdrop: 28.53B FLR tokens, which in the original distribution plan went to those who registered for the distribution.</p> </li> <li> <p>New Airdrop: 4.28B FLR tokens destined for those that registered for the distribution.</p> </li> <li> <p>Delegation Incentive Pool (DIP): 24.25B FLR tokens destined for any Flare holder that participated in the network over 36 months as per the FIP.01 distribution plan.</p> <p>Note that the New Airdrop plus the DIP match the Original Airdrop.</p> </li> <li> <p>Token Distribution Event (TDE): The moment when the initial <code>$FLR</code> tokens were distributed to those who registered for the <code>$FLR</code> token distribution. These tokens were minted and locked when the network was created, and they were released when it was sufficiently decentralized.</p> </li> </ul>"},{"location":"tech/archive/flare-launch-process/#token-distribution-plans","title":"Token Distribution Plans","text":"<p>The following distribution plans were offered. The FIP.01 Distribution Plan was implemented after FIP.01 was approved.</p> <ul> <li> <p>Original Distribution Plan:</p> <ul> <li>15% of the original airdrop would have been sent to those who registered for the <code>$FLR</code> distribution upon the TDE, and the rest would have been delivered monthly over the subsequent 36 months.</li> <li>Inflation would have been 10% of the fully diluted supply, per annum.</li> </ul> </li> <li> <p>FIP.01 Distribution Plan:</p> <ul> <li>The new airdrop was sent to those who registered for the <code>$FLR</code> distribution upon the TDE, and the DIP was distributed to all <code>$FLR</code> token holders (actually, wrapped <code>$FLR</code> holders) over 36 months. Flare employees and companies were excluded.</li> <li>Inflation is 10% of available supply in the first year, then 7% the following year, 5% the year after and in perpetuity, except that from year 3 onwards inflation is capped at 5bn <code>$FLR</code> per year.</li> <li>Inflation distribution: 70% to FTSO rewards, 20% to validator rewards and 10% to the default Attestation Provider Set of the state connector.</li> </ul> </li> </ul>"},{"location":"tech/archive/flare-launch-process/#launch-phases","title":"Launch Phases","text":""},{"location":"tech/archive/flare-launch-process/#private-observation-mode","title":"Private Observation Mode","text":"<p>Trigger: The Flare network launches</p> <p>On July 14, 2022, the network started centralized, with only 21 validators, run by the Flare Foundation.</p> <p>Flare validator source code was not available yet.</p> <p>FTSO data providers:</p> <ul> <li> <p>Could submit data, as they do on Songbird, but did not act as validators because they could not run nodes.</p> </li> <li> <p>Were not rewarded. All inflation would be burned during observation mode.</p> </li> </ul>"},{"location":"tech/archive/flare-launch-process/#public-observation-mode","title":"Public Observation Mode","text":"<p>Trigger: The Flare validator source code becomes publicly available</p> <p>During this mode, professional validators started onboarding, so the network started to become decentralized.</p> <p>FTSO data providers:</p> <ul> <li> <p>Could submit data, as they do on Songbird, but did not act as validators because they would not have funds to stake until the TDE.</p> </li> <li> <p>Were not rewarded. All inflation was burned during observation mode.</p> </li> </ul>"},{"location":"tech/archive/flare-launch-process/#initial-distribution-period","title":"Initial Distribution Period","text":"<p>Trigger: 66% of validator power is independent of Flare,AND Exchanges agree to distribute the <code>$FLR</code> token to their customers within a few days of the TDE</p> <p>Token Distribution Event (TDE) happens</p> <p>The new airdrop was sent to the Flare addresses provided by <code>$XRP</code> token holders when they claimed.</p> <p>Part of the airdrop went to Exchange accounts, which distributed it to the users that originally claimed (the intended recipients).</p> <p>During this period, Flare monitored how many of the airdrop tokens reached the intended recipients, by following the Exchange's communication channels.</p> <p>FTSO data providers:</p> <ul> <li> <p>Could deploy their own validator nodes.</p> </li> <li> <p>Acted as validators and their voting power depended on their FTSO performance and stake.</p> </li> </ul> <p>FTSO and validator rewards were enabled. Inflation was not burned anymore.</p>"},{"location":"tech/archive/flare-launch-process/#fip01-notice-period","title":"FIP.01 Notice Period","text":"<p>Trigger: 66% of the new airdrop reaches its intended recipients</p> <p>FIP.01 proposed to modify how the rest of the tokens (after the TDE) would be distributed, so it required the community to vote. Users voted with their <code>$FLR</code> token stake, so voting could not start until enough tokens had reached the intended recipients.</p> <p>After 66% of the FLR tokens distributed during the TDE reached these users, a 1-week notice period began.</p> <p>Flare announced to the community that enough tokens were distributed and the notice period had started.</p>"},{"location":"tech/archive/flare-launch-process/#fip01-voting-period","title":"FIP.01 Voting Period","text":"<p>Trigger: 1 week after Notice Period starts</p> <p>All <code>$FLR</code> token holders (obtained either from the new airdrop or bought at Exchanges) could vote on FIP.01 using a voting front-end.</p> <p>Flare announced to the community that the Voting Period had started and relayed instructions about how to vote.</p> <p>Voting Period lasted 1 week.</p>"},{"location":"tech/archive/flare-launch-process/#regular-operation-beta","title":"Regular Operation (Beta)","text":"<p>Trigger: FIP.01 is approved after 1 week of voting</p> <p>The changes proposed in FIP.01 were implemented. The DIP will be distributed to ALL holders of FLR during 37 months.</p> <p>Flare Beta is still in operation, but community-run validators are gradually gaining more power.</p>"},{"location":"tech/archive/flare-launch-process/#regular-operation","title":"Regular Operation","text":"<p>Trigger: Community-run FTSO validators are deemed reliable enough</p> <p>Flare Beta will end.</p> <p>FTSO validators' validation power is not artificially reduced anymore and validator rewards (20% of inflation) will be distributed equally among all validators according to their performance and stake.</p>"},{"location":"tech/fassets/","title":"FAssets","text":"<p>The FAssets system allows tokens on blockchains that do not support smart contracts to be used trustlessly with smart contracts on the Flare blockchain.</p> <p>The following diagram summarizes the relationship between the FAssets system, its users, and the networks involved:</p> <p> </p> FAssets overview. <p>Anyone on the Flare blockchain can mint FAssets as wrapped versions of the original tokens from other blockchains, known as underlying networks. The original tokens from these chains, such as <code>$BTC</code>, <code>$LTC</code>, <code>$DOGE</code>, and <code>$XRP</code>, are called underlying assets. For example, the FAsset version of <code>$BTC</code> is <code>$FBTC</code>.</p> <p>You can then use these FAssets in smart contracts and decentralized applications on Flare, and at any time you can redeem them for the underlying asset.</p> <p>The system is enabled by these Flare protocols:</p> <ul> <li>FTSO, whose contracts provide decentralized price feeds for multiple tokens.</li> <li>State Connector, which brings payment data from any connected chain into Flare.</li> </ul> <p>FAssets are backed by collateral provided by entities in the following roles that maintain the infrastructure of the system and hold Flare's native assets. All these entities are independent of the Flare Foundation.</p>"},{"location":"tech/fassets/#roles-in-the-fassets-system","title":"Roles in the FAssets System","text":"<p>The following roles participate in the FAssets system:</p> <ul> <li>Agents</li> <li>Users</li> <li>Collateral providers</li> <li>Liquidators</li> <li>Challengers</li> </ul>"},{"location":"tech/fassets/#agents","title":"Agents","text":"<p>The main purpose of agents is to keep the underlying assets while the minted FAssets are circulating. Agents are off-chain programs, that:</p> <ul> <li>Manage the account that holds an underlying asset, like <code>$BTC</code>.</li> <li>Provide the main part of the collateral.</li> <li>Repay the underlying assets when users redeem them.</li> </ul> <p>Each agent has an owner, a person who controls the following addresses associated with the agent. These addresses enable owners to manage their agents and run FAsset operations.</p> <ul> <li>Work address: Used by programs permanently online to execute operations like paying for redemptions.     Because the private key for this address resides on a server, it is vulnerable to theft.     To keep it secure, owners should regularly change the private key and its corresponding work address.     It is also known as a hot wallet.</li> <li>Management address: Used when the owner wants to change the work address.     This address can never change and will typically be a multisignature account.     It is also known as a cold wallet.</li> </ul> <p>Before agents can participate in the FAssets system, they must be verified by governance. To be verified by governance, owners submit the agent's management address and, during the initial stages, some sort of off-chain personal information for KYC purposes. After the agent is verified, its management address is added to a list of allowed agents.</p> <p>The backing factor is a system-wide setting that specifies how much of the kept assets must be locked, i.e., not freely used by agents. This factor is currently 100%, meaning that agents should not transfer out of their account any underlying that is backing FAssets, unless they receive a redemption request. Decreasing the underlying below the backing factor is an illegal action and is reported by challengers.</p>"},{"location":"tech/fassets/#users","title":"Users","text":"<p>Users interact with the FAssets system in the following ways:</p> <ul> <li> <p>Minting: Depositing underlying assets to an agent's address in exchange for the equivalent amount of FAssets minus a minting fee.     The minting fee is split between the agent and the collateral pool, which receives fees as FAssets.     During this operation, users are called minters.</p> </li> <li> <p>Redeeming: Returning FAssets to the FAssets system in exchange for the equivalent amount of underlying assets, paid from an agent's address.     If the agent fails to pay the underlying assets in time, the FAssets system pays the redeemer from the vault or the collateral pool plus a premium.     To ensure redemption is always possible, even after fluctuating price changes, the total collateral is always higher than the value of the backed FAssets.     During this operation, users are called redeemers.</p> </li> </ul> <p>No eligibility requirements apply. Anyone can use the FAssets system to mint and redeem. In the future, a mechanism might be implemented to allow agents to reject minting requests according to their respective countries' KYC laws.</p>"},{"location":"tech/fassets/#collateral-providers","title":"Collateral Providers","text":"<p>Anyone can participate in the FAssets system by providing native <code>$FLR</code> tokens to an agent's collateral pool and becoming a collateral provider.</p> <p>For as long as these tokens remain locked in the pool, the collateral provider receives a share of every fee produced by FAssets minted using that pool.</p>"},{"location":"tech/fassets/#liquidators","title":"Liquidators","text":"<p>When an agent's collateral falls below the required minimum, it enters the liquidation state. In this state, liquidators send FAssets into the system in exchange for collateral from the agent's vault and collateral pool. The collateral they receive has the same value as the FAssets they send plus a premium. The FAssets sent by liquidators are burned, which reduces the amount of FAssets that the agent's collateral needs to back.</p> <p>Once the agent's collateral is above a safety margin, the liquidation state ends.</p> <p>No eligibility requirements apply. Anyone can be a liquidator, contribute to the health of the FAssets system, and earn rewards in the process.</p>"},{"location":"tech/fassets/#challengers","title":"Challengers","text":"<p>Challengers monitor an agent's underlying address to detect illegal transactions that reduce the amount of underlying assets below the backing factor. When challengers detect an illegal transaction, they provide the proof to the FAssets system in exchange for a reward from the agent's vault.</p> <p>Then, the offending agent enters full liquidation, and the agent's vault is permanently locked against new mintings.</p> <p>No eligibility requirements apply. Anyone can be a challenger, contribute to the health of the FAssets system, and earn rewards in the process.</p>"},{"location":"tech/fassets/#how-the-fassets-system-works","title":"How the FAssets System Works","text":"<p>Select one of the following topics to continue learning about FAssets:</p> <ul> <li>Collateral</li> <li>The minting process</li> <li>The redemption process</li> <li>Liquidation</li> </ul>"},{"location":"tech/fassets/collateral/","title":"FAssets Collateral","text":"<p>FAssets collateral is locked in contracts that ensure the minted FAssets can always be redeemed for the underlying assets they represent or compensated by collateral.</p> <p>Along with Flare's native token, <code>$FLR</code>, any governance-approved ERC-20 token on the Flare blockchain can be used as collateral.</p>"},{"location":"tech/fassets/collateral/#collateral-types","title":"Collateral Types","text":"<p>Two kinds of collateral secure FAssets: vault collateral and pool collateral.</p> <p> </p> FAssets collateral types. <p>Vault collateral is provided exclusively by agents and ensures they perform their duties. Pool collateral is provided by agents and <code>$FLR</code> holders who choose to contribute to the pool. It is a safeguard when a sudden drop in the price of the vault collateral makes it insufficient to back the underlying assets.</p> <p>The two types of collateral are explained next. Collateral pool tokens and minting fees are explained afterwards.</p>"},{"location":"tech/fassets/collateral/#vault-collateral","title":"Vault Collateral","text":"<p>Vault collateral consists of the types of collateral chosen by agents to store in their vaults. Flare governance approves the valid types, which are generally stablecoins, such as <code>$USDC</code>, <code>$USDT</code>, or other highly liquid tokens on the Flare network.</p> <p>Agents choose one of the types defined by FAssets governance and use it as collateral in their vaults. Agents cannot switch to a different type after a vault is created, but they can create any number of vaults, with different types.</p> <p>Each collateral type defines an ERC-20 token to use as collateral, a series of collateral ratios, and information to retrieve the asset's price from the FTSO system. Governance reserves the right to add new types or deprecate existing types. If governance deprecates a type, agents must switch to a supported type.</p> <p>Each vault is associated with a single, unique address on the underlying chain called the agent's underlying address. It receives underlying assets when they are minted into FAssets and sends underlying assets to the redeemer's address when they are redeemed.</p> <p>When an agent creates a vault, the underlying address is checked for validity using the State Connector. Otherwise, malicious agents could provide an address that systematically blocks payments and exploit the minting process to their advantage.</p>"},{"location":"tech/fassets/collateral/#pool-collateral","title":"Pool Collateral","text":"<p>When the price of the vault collateral changes in such a way that the vault collateral cannot fully back all the minted FAssets, a liquidation mechanism ensures enough FAssets are burned to restore balance. The pool collateral provides an additional source of backing for situations when the price fluctuates too rapidly for liquidations to correct the imbalance.</p> <p>Pool collateral is always native <code>$FLR</code> tokens (or <code>$SGB</code> tokens on the Songbird network) and can be used as an additional source of collateral for liquidations and failed redemptions.</p> <p>Anyone can participate in the FAssets system by providing native tokens to this pool. In return, providers receive collateral pool tokens (CPTs) as proof of the share of native tokens they provided to a specific pool from a specific agent. CPTs are ERC-20 tokens specific to both an agent and a pool.</p> <p>Providers can redeem their CPTs for <code>$FLR</code>, or even transfer or trade them, after a governance-defined time period has elapsed since they entered the pool. This time lock is necessary to reduce sandwiching attacks.</p> <p>Additionally, CPT holders are entitled to a share of any fee the agent earns from minting FAssets using this pool as explained in the next section.</p> Formulas: CPT Conversion <p>The amount of collateral pool tokens a provider \\(p\\) receives upon entering a pool is calculated as:</p> \\[ received\\_CPT_p = { added\\_collateral_p \\over collateral\\_in\\_pool } \\times currently\\_issued\\_CPT \\] <p>where:</p> <ul> <li>\\(added\\_collateral_p\\) is the amount of <code>$FLR</code> tokens that provider \\(p\\) is adding to the pool.</li> <li>\\(collateral\\_in\\_pool\\) is the amount of <code>$FLR</code> tokens in the pool before adding the new tokens.</li> <li>\\(currently\\_issued\\_CPT\\) is the circulating amount of collateral pool tokens.</li> </ul> <p>When a pool is first created, \\(received\\_CPT_p = added\\_collateral_p\\).</p> <p>The amount of <code>$FLR</code> collateral a provider receives when they redeem their CPT is calculated using the opposite formula:</p> \\[ received\\_collateral_p = collateral\\_in\\_pool \\times { redeemed\\_CPT_p \\over currently\\_issued\\_CPT } \\] <p>where:</p> <ul> <li>\\(redeemed\\_CPT_p\\) is the amount of CPT the provider is returning to the pool.</li> </ul> Example: CPTs Conversion <code>$FLR</code> in pool Issued CPTs 1. An agent creates a new vault. The collateral pool is initially empty of <code>$FLR</code> and fees. 0 0 2. Alice deposits 100 <code>$FLR</code> and gets 100 CPTs in return. 100 100 3. Bob deposits 200 <code>$FLR</code> and gets 200 CPTs in return. 300 300 4. Alice redeems 50 CPTs and receives 50 <code>$FLR</code> in return. 250 250 <p>Note that in general 1 FLR does not always correspond to 1 CPT, because of mechanisms like the top-up, for example.</p>"},{"location":"tech/fassets/collateral/#fasset-minting-fees-and-debt","title":"FAsset-Minting Fees and Debt","text":"<p>As part of the minting process, users pay a minting fee on the underlying chain. The agent's share of this fee remains on the underlying chain, whereas the pool's share triggers the minting of an equivalent amount of FAssets on the Flare network.</p> <p>These FAssets coming from the minting fee are added to the collateral pool, where they are shared between collateral providers in proportion to the amount of CPTs that providers have. At any time, providers can claim their due share of the fees in the pool. When providers exit the collateral pool by redeeming their CPTs, any remaining unclaimed fee is automatically transferred to them.</p> <p>Providers are naturally only entitled to the minting fees accrued after they entered the pool. Therefore, providers entering a pool with preexisting fees are assigned a fee debt. The amount of fees a provider can actually withdraw from the pool is calculated by first subtracting their debt from the total amount of fees in the pool. In this way, the amount of fees that a provider can withdraw upon entering a pool is exactly zero.</p> <p>A provider's fee debt:</p> Increases when the provider Decreases when the provider Enters a pool which already has fees in it. Exits the pool, partially or completely. Withdraws FAsset fees. Deposits FAssets, paying off part of the debt. <p>It is worth noting that:</p> <ul> <li>When a provider withdraws fees, their debt increases by the same amount.</li> <li>Since CPTs are ERC-20 tokens, a secondary market for them is expected to develop.     If CPTs become more valuable than the FAsset fees they represent, returning the FAssets and paying off part of their fee debt might be more lucrative for providers.</li> </ul> Formulas: Fee Entitlement <p>The following formulas consider all the above information to calculate each provider's due share of FAsset minting fees.</p> <p>The amount of debt a provider \\(p\\) is assigned upon entering a pool is calculated as:</p> \\[ fee\\_debt_p = { added\\_collateral_p \\over collateral\\_in\\_pool } \\times fees\\_in\\_pool \\] <p>where:</p> <ul> <li>\\(added\\_collateral_p\\) is the amount of <code>$FLR</code> tokens that provider \\(p\\) is adding to the pool.</li> <li>\\(collateral\\_in\\_pool\\) is the amount of <code>$FLR</code> tokens in the pool before adding the new tokens.</li> <li>\\(fees\\_in\\_pool\\) is the amount of FAsset minting fees currently in the pool.</li> </ul> <p>The following formulas are based on the concept of virtual fees, which are the fees that a provider would be entitled to if they had no fee debt.</p> <p>The total virtual fees is the sum of all provider's virtual fees and can be expressed as:</p> \\[ total\\_virtual\\_fees = fees\\_in\\_pool + total\\_fee\\_debt \\] <p>where:</p> <ul> <li>\\(total\\_fee\\_debt\\) is the sum of the fee debt held by all providers \\(= \\sum_p fee\\_debt_p\\)</li> </ul> <p>Then, the virtual fees due to a provider \\(p\\), i.e., the amount of FAsset minting fees they would be entitled to if they had no debt, are:</p> \\[ virtual\\_fees_p = { CPT_p \\over currently\\_issued\\_CPT } \\times total\\_virtual\\_fees \\] <p>where:</p> <ul> <li>\\(CPT_p\\) is the amount of CPTs provider \\(p\\) holds.</li> <li>\\(currently\\_issued\\_CPT\\) is the circulating amount of CPTs.</li> </ul> <p>Finally, the amount of fees from the pool that a provider \\(p\\) is free to withdraw at any given time is:</p> \\[ free\\_fees_p = virtual\\_fees_p - fee\\_debt_p \\] <p>where:</p> <ul> <li>\\(fee\\_debt_p\\) is the amount of fee debt that provider \\(p\\) holds.</li> </ul> Example: Fee Entitlement <code>$FLR</code> in pool Fees in pool Total fee debt Total virtual fees 1. An agent creates a new vault. 0 0 0 0 2. Alice deposits 100 <code>$FLR</code> and gets 100 CPTs in return. 100 0 0 0 3. 10 FAssets of fees are added to the pool due to a mint. 100 10 0 10 4. Bob deposits 100 <code>$FLR</code> and gets 100s CPT in return. 200 10 10 20 5. 10 more FAssets of fees are added to the pool due to another mint. 200 20 10 30 6. Alice withdraws 10 FAssets of fees. 200 10 20 30 7. Bob exits the pool by returning the 100 CPTs and withdrawing 100 <code>$FLR</code>. 100 5 10 15 <p>After step 4, Bob is not entitled to any of the fees in the pool:</p> <ul> <li>Bob is assigned an initial fee debt of 10 FAssets, according to the \\(fee\\_debt_p\\) formula in the box above.</li> <li>As a result, the total virtual fees are increased to 20 FAssets. 10 of them are in fees, and 10 of them are in debt.</li> <li>Each user now holds half the total CPTs, therefore they are allowed to withdraw half the virtual fees, this is, 10 FAssets each.</li> <li>Alice has no debt, so she can withdraw 10 FAssets, which is all the fees in the pool, because she was the only CPT holder when these fees were accrued.</li> <li>Conversely, Bob has 10 FAssets of debt, so he can't withdraw any of the fees.</li> </ul> <p>After step 5, the new fees are shared between both users, and the previous 10 FAssets still belong to Alice:</p> <ul> <li>The 10 FAssets in new fees increase the total virtual fees to 30.</li> <li>Both users are entitled to half of the total, which is 15 FAssets each.</li> <li>Alice has no debt, so she can withdraw 15 FAssets: the initial 10 plus half of the 10 that were added to the pool afterwards.</li> <li>Bob has 10 FAssets of debt, so he can only withdraw 5, this is, his entitlement (15) minus the debt (10).</li> </ul> <p>After step 6:</p> <ul> <li>The 10 FAssets that Alice has withdrawn have converted into debt for her.</li> <li>However, this action does not change the total virtual fees because the sum of fees in the pool and total debt remains constant.</li> <li>Therefore, both users are still entitled to 15 FAssets each.</li> <li>However, now Alice has 10 FAssets of debt, so she can withdraw only 5 more.</li> <li>Nothing has changed for Bob, who can still withdraw 5 FAssets.</li> </ul> <p>In step 7:</p> <ul> <li>Bob is returning 100 CPTs, which is 50% of the circulating CPTs, so he is entitled to half the total virtual fees, 15 FAssets.</li> <li>Because he is exiting the pool, all his debt, which is 10 FAssets, must be cancelled.</li> <li>He can withdraw the remaining 5 FAssets from the fees pool.</li> <li>After Bob withdraws his 5 FAssets, the pool contains only 5 FAssets, which correspond to the amount that Alice can withdraw.</li> </ul>"},{"location":"tech/fassets/collateral/#transferable-and-locked-cpts","title":"Transferable and Locked CPTs","text":"<p>CPTs can always be redeemed by exiting the pool, but only the portion of them above the fee debt can be transferred to another account. Therefore, CPTs held by providers are divided into two types:</p> <ul> <li>Transferable: Tokens whose time lock has expired and are also free of fee debt.     These tokens are fungible, and they can be transferred or traded just like any other ERC-20 token.</li> <li> <p>Locked: The CPTs serve only as proof of ownership of some of the collateral in the pool, and they cannot be transferred nor traded.</p> <p>Locked CPTs are one of the following types:</p> <ul> <li>Time-locked: Tokens whose time lock has not expired must wait to become transferable or redeemable.</li> <li> <p>Debt-locked: Tokens corresponding to an amount of fees below the provider's fee debt cannot be transferred because they would need to carry the debt with them.     However, they can be redeemed.</p> <p>As new fees arrive in the pool, some previously debt-locked tokens become transferable.</p> <p>These CPTs can also become transferable by adding FAssets to the pool, which settles, either partially or completely, the fee debt.</p> </li> </ul> </li> </ul> Formulas: Collateral Pool Token Transferability <p>The amount of CPTs that a given provider \\(p\\) can transfer is calculated as:</p> \\[ transferable\\_CPT_p = { free\\_fees_p \\over virtual\\_fees_p } \\times CPT_p \\] <p>where:</p> <ul> <li>\\(free\\_fees_p\\) is the amount of fees from the pool that a provider \\(p\\) can withdraw, as defined in the previous formula box.</li> <li>\\(virtual\\_fees_p\\) is the amount of FAsset minting fees that provider \\(p\\) would be entitled to if they had no debt, as defined in the previous formula box.</li> <li>\\(CPT_p\\) is the amount of CPTs provider \\(p\\) holds.</li> </ul> <p>Accordingly, the amount of CPT that is locked and cannot be transferred is calculated as:</p> \\[ locked\\_CPT_p = { fee\\_debt_p \\over virtual\\_fees_p } \\times CPT_p \\] <p>As new minting fees arrive in the pool, the \\(transferable\\_CPT_p\\) of all providers also increases.</p> <p>Conversely, when a provider withdraws fees from the pool, their debt increases in the same amount, and \\(total\\_virtual\\_fee\\) remains the same. Therefore, only that provider's \\(transferable\\_CPT_p\\) is reduced, without affecting the rest of the providers.</p> Example: Collateral Pool Token Transferability Issued CPTs Fees in pool Total fee debt Total virtual fees 1. An agent creates a new vault. 0 0 0 0 2. Alice deposits 100 <code>$FLR</code> and receives 100 CPTs. 100 0 0 0 3. 10 FAssets of fees are added to the pool due to a mint. 100 10 0 10 4. Alice withdraws 5 FAssets of fees. 100 5 5 10 5. 10 more FAssets of fees are added to the pool due to another mint. 100 15 5 20 6. Alice transfers 75 CPTs to Bob. 100 15 5 20 7. Alice exits the pool by returning her remaining 25 CPTs. 75 15 0 15 <p>After step 2, all of Alice's CPTs are transferable because she has no debt.</p> <p>After step 3, all of Alice's CPTs continue to be transferable, and she is entitled to 100% of the fees in the pool. If she transferred or traded his CPTs, the recipient of those CPTs would be entitled to the fees.</p> <p>After step 4, only half of Alice's CPTs are transferable (50 CPTs). The other half is debt-locked.</p> <p>After step 5, only 25% of Alice's CPTs remain locked (25 CPTs), which correspond to her 5 FAssets of debt.</p> <p>After step 6:</p> <ul> <li>Alice has 25 CPTs, which entitle her to 5 FAssets of virtual fees.   After subtracting her 5 FAssets of fees, her free fees are zero, which means she cannot withdraw any more fees.</li> <li>Bob has 75 CPTs and no debt, so he is entitled to 15 FAssets of fees, which are all the fees in the pool.</li> </ul> <p>In step 7:</p> <ul> <li>Alice is returning 25 CPTs, which is 25% of the circulating CPTs, so she is entitled to 25% of the total virtual fees, which is 5 FAssets.</li> <li>Because she is exiting the pool, all her debt, which is 5 FAssets, must be cancelled.</li> <li>Her \\(free\\_fees_p\\) are 0, so she cannot take any of the remaining fees in the pool.</li> <li>The 15 FAssets that remain in the fee pool now belong entirely to Bob, who holds 100% of all the issued CPTs, which is 75 CPTs.</li> </ul>"},{"location":"tech/fassets/collateral/#the-collateral-ratio","title":"The Collateral Ratio","text":"<p>The collateral ratio (CR) is the ratio between the value of all the tokens used as collateral and the total value of the underlying assets held by an agent at any given time. The agent's vault and the collateral pool each has its own unique collateral ratio, which is constantly changing as the value of the underlying assets and the collateral change. These values are obtained using the FTSO system.</p> <p>Example: Vault and Pool CR</p> <p>Assume an amount of FAssets currently valued at $1000 USD, backed by $1500 worth of <code>$USDC</code> in vault collateral and $2000 worth of <code>$FLR</code> in pool collateral.</p> <p>The resulting vault CR is then \\(\\$1500 \\over \\$1000\\) = 1.5.</p> <p>The resulting pool CR is \\(\\$2000 \\over \\$1000\\) = 2.</p> <p>Several thresholds are defined for the collateral ratio, and they are used at different times during the FAsset operations. Some are set by the system, and others are set by the agent:</p> <p> </p> Collateral ratio thresholds."},{"location":"tech/fassets/collateral/#system-wide-thresholds","title":"System-wide Thresholds","text":"<p>The following thresholds are set by the FAssets system's governance and are the same for all agents:</p> <ul> <li> <p>Minimal CR: The lowest collateral ratio the agent vault and the collateral pool must maintain so that enough collateral exists to insure the minted FAssets and to compensate for redemption payments that fail.     The minimal CR can be different for each type of collateral.</p> <p>If an agent's CR remains below the minimal CR for longer than a governance-set amount of time, liquidations can start.</p> </li> <li> <p>Collateral call band CR (CCB CR): An agent's position is unhealthy when the agent's vault CR or pool CR fall below their minimal CR.     However, as long as the CR remains above CCB CR, the CR can briefly fall below the minimal CR.</p> <p>During this time, the agent can either deposit more collateral or self-close some backed FAssets to improve the position.</p> <p>However, if the CR falls below the CCB CR, liquidations can start immediately.</p> <p>The value of each CCB CR is approximately 10% less than the minimal CR.</p> <p>Example</p> <p>Assume the minimal CR is 1.4 and the CCB CR is 1.3.</p> <p>If the agent's vault CR drops below 1.3, the agent's position can be liquidated immediately. If the agent's vault CR drops below 1.4 but not below 1.3, the agent has some time to amend the position before it can be liquidated.</p> <p>Adjusted for the collateral pool's minimal CR, the same example applies to the collateral pool.</p> </li> <li> <p>Safety CR: If one or both of the collateral types fall below CCB CR or below the minimum CR for a longer period of time, liquidation occurs.     When the offending collateral reaches a healthy CR again, the liquidation stops.     To prevent the agent from immediately reverting into liquidation after a small price change, the CR must reach the safety CR before it can start operating normally again and liquidation stops.</p> <p>Each of the collateral types, the agent's vault and the collateral pool, has its own unique safety CR.</p> </li> </ul>"},{"location":"tech/fassets/collateral/#agent-thresholds","title":"Agent Thresholds","text":"<p>The following thresholds are set by each agent according to their own preferences:</p> <ul> <li> <p>Minting CR: For each mint done by an agent, the maximum amount allowed to be minted is calculated so that the CR for the agent's vault and the CR for the agent's collateral pool after the mint remain higher than the minting CR for each collateral type.     To reduce the threat of liquidation, agents should set the minting CR well above the minimal CR to accommodate price fluctuations that might occur before the CR falls below the minimal CR after the mint and minting is no longer possible.</p> </li> <li> <p>Exit CR: After a user redeems CPTs, the pool CR must be more than the exit CR.     If the pool CR is already below the exit CR, redemption cannot occur.     The exit CR is for the collateral pool only.</p> </li> <li> <p>Top-up CR: To incentivize healthy collateral pools, when the pool CR reaches the top-up CR, anyone can add collateral to the pool and receive CPTs at a reduced price.     This top-up mechanism decreases the likelihood of liquidations because of a low amount of pool collateral.</p> </li> </ul>"},{"location":"tech/fassets/collateral/#redemption-of-cpts","title":"Redemption of CPTs","text":"<p>When collateral providers exit the pool by redeeming their CPTs, the FAssets system burns them and returns the appropriate share of the collateral plus the share of FAsset-minting fees minus any FAsset-fee debt.</p> <p>Providers also have the option to exit the pool partially, by redeeming only some of their CPTs. In this case, they can choose one of the following options to manage their due FAsset fees: withdraw the fees, reduce the fee debt, or both, keeping the current fee-to-debt-ratio.</p> <p>However, providers can exit, either fully or partially, only when the collateral ratio (CR) is high enough. After they exit, the CR must be higher than the exit CR to prevent their exit from reducing the CR to a dangerous level.</p> <p>Therefore, exits are impossible when the CR is below the exit CR. In this case, if providers have enough FAssets, they can exit by self-closing, which burns enough of their FAssets, plus their fees, to release their collateral.</p> <p>Providers are mainly compensated in underlying assets for the burned FAssets, depending on the number of lots of FAssets that need to be redeemed:</p> <ul> <li>If more than 1 lot needs to be redeemed, the value of the burned FAssets is redeemed through the standard redemption process.</li> <li> <p>If less than 1 lot needs to be redeemed, the agent buys the underlying funds from the user using vault collateral, at the price reported by the FTSO system minus a percentage defined by the agent.     This purchase by the agent occurs because fees on underlying chains can be expensive, which makes redemption of small quantities too expensive for the agent.</p> <p>Providers can always request this option instead of receiving underlying tokens. Also, if enough vault collateral is not available, pool collateral is used instead.</p> </li> </ul> <p>Warning</p> <p>In the case where the agent does not redeem in the underlying asset, the FAssets system pays the provider in collateral from the agent's vault because the pool collateral backing the redeemed FAssets is already withdrawn.</p> <p>When this type of redemption occurs, users might receive less collateral than they would have received if they had made a normal redemption.</p>"},{"location":"tech/fassets/collateral/#agents-stake-in-the-collateral-pool","title":"Agent's Stake in the Collateral Pool","text":"<p>Agents must have a stake in their collateral pools, which means they must hold the amount of CPTs proportional, by a system-defined constant, to the backed amount of FAssets. The maximum amount of minting is limited by the amount of collateral pool tokens held by the agents. The agents' tokens are locked, which means they cannot be redeemed or transferred, while agents back these FAssets.</p> <p>When the agent's portion of the collateral pool is below the threshold, new mintings are not allowed. However, this situation does not trigger a liquidation because only the total pool stake matters when collateral needs to be redeemed or a liquidation payment needs to be made.</p> <p>If an agent's actions force a payment to be made from the collateral pool, the agent's CPTs, valued by the paid native tokens and recalculated by the collateral-pool-price formula, are burned. These actions can cause the agent's CPTs to be burned:</p> <ul> <li>When a redemption payment fails, when enough vault collateral to compensate the redeemer is not available, or when the system is set to automatically pay for redemption failures from the collateral pool.</li> <li>Liquidation because the CR of the vault collateral is too low.</li> <li>Full liquidation because of an agent infraction during a transfer on an underlying chain.</li> </ul>"},{"location":"tech/fassets/collateral/#top-up","title":"Top-up","text":"<p>To reduce the likelihood of liquidations because the pool collateral is too low, the pool can be topped up at a reduced price when the CR is above the top-up CR.</p> <p>A top-up mechanism for vault collateral is not available. To prevent liquidation, agents can add vault collateral any time.</p>"},{"location":"tech/fassets/liquidation/","title":"FAssets Liquidation","text":"<p>Liquidation is the process of selling assets to bring the FAssets system back to health after an agent becomes undercollateralized.</p> <p>The following types of liquidation can occur:</p> <ul> <li>Unhealthy position liquidation: Occurs when the collateral ratio (CR) of either the agent's vault or collateral pool falls below its respective minimal CR.   In this case, the agent's position is liquidated until the collateral ratio reaches the safety CR or all of the backed FAssets are liquidated.</li> <li>Full liquidation: Occurs when the agent makes an illegal payment from the underlying chain address.   In this case, all the FAssets backed by the agent are liquidated, and the liquidation cannot be stopped.</li> </ul> <p>In both cases, liquidators, who can be anyone who holds FAssets, are encouraged to sell their FAssets back to the system. They will be paid with the agent's collateral plus a premium, as a penalty against the agent for unhealthy positions or misconduct.</p>"},{"location":"tech/fassets/liquidation/#liquidation-process","title":"Liquidation Process","text":"<p>When liquidation starts, any liquidator can send FAssets and get paid with a combination of vault collateral and pool collateral at the current asset price multiplied by a premium factor greater than 1. The maximum amount of FAssets that is accepted is the amount required to make the agent's position healthy again, rounded up to the next lot.</p> <p>The premium is a system-defined percentage, and it can increase through the duration of the liquidation. The premium is limited to the agent's combined collateral ratio, which is the sum of the current value of the vault collateral and pool collateral divided by the current value of the backed FAsset amount. However, if this limit is reached, all the agent's backed FAssets are liquidated, and all the vault collateral and pool collateral are paid to the liquidators. The liquidation-collateral payment is divided between the agent and the collateral pool.</p> <p>A fixed ratio (\u2265 1.0) of the payment is paid from the agent's collateral, and the remainder is paid from the pool collateral. If not enough of one type of collateral exists, more is paid from the other type.</p> <p>Full Liquidations</p> <p>Illegal payments trigger a full liquidation, which involves the following additional actions:</p> <ul> <li>The liquidated agent's vault is locked so that it cannot be used to mint again.     If the agent wants to continue to mint FAssets, he must create a new agent vault with a new underlying address.</li> <li>Ongoing mintings against this agent's locked vault continue, but the minted FAssets are immediately added to the liquidation process.</li> <li>Ongoing redemptions continue.     New redemptions can start until all the agent's redemption tickets are liquidated.     Unfortunately, if the agent's underlying backing is unhealthy, redeemers are more likely to be paid in native tokens from the collateral pool.</li> </ul> <p>This liquidation process includes the time-increasing premium, and it only stops when all the agent's collateral is liquidated.</p>"},{"location":"tech/fassets/liquidation/#stopping-liquidations","title":"Stopping Liquidations","text":"<p>After liquidation of an unhealthy position starts, it can be stopped by depositing enough collateral or self-closing FAssets to reach the safety CR. Also, if a change in the price pushes the CR above the safety CR, anyone can stop the liquidation by notifying the FAssets system.</p> <p>To maintain a healthy account, agents should track positions and automatically top up or self-close FAssets when liquidation approaches. Otherwise, the agent and the liquidators compete to try to stop the liquidation. To stop a liquidation, the agent's vault must reach the safety CR, which is above the minimal CR that triggered the liquidation.</p> <p>The top-up mechanism can prevent liquidations caused by a low CR in the collateral pool, but full liquidations cannot be stopped. However, an agent can still self-close positions to avoid paying a premium to liquidators.</p> Example 1: Small Price Movement <p>Using <code>$BTC</code> as underlying and <code>$USDC</code> as collateral, an agent creates a vault to mint <code>$FBTC</code> FAssets.</p> <ol> <li> <p>Initial conditions:</p> <ul> <li>The agent is backing 1 <code>$FBTC</code>, currently valued at $20K, according to the FTSO system.</li> <li>The minimal CR is 1.3 for the vault collateral and 2.5 for pool collateral.</li> <li>The agent must hold 20% of the pool's minimal CR.     In this case, 20% of 2.5 times $20K is $10K.</li> <li>The underlying backing factor is 50%, so the agent needs to hold only 0.5 <code>$BTC</code>.</li> <li>The liquidation premium factor is 1.1, of which 1.0 is paid in vault collateral, and 0.1 is paid in pool collateral.</li> </ul> <p>At this point, the 1 <code>$FBTC</code> is backed by:</p> <ul> <li>0.5 <code>$BTC</code> underlying.</li> <li> <p>$26K worth of <code>$USDC</code> vault collateral.</p> <p>The vault CR is \\(\\$26K \\over \\$20K\\) = 1.3, equal to the vault's minimal CR.</p> </li> <li> <p>$60K worth of <code>$FLR</code> in pool collateral, of which $10K belongs to the agent.</p> <p>The pool CR is \\(\\$60K \\over \\$20K\\) = 3, above the pool's minimal CR.</p> </li> </ul> </li> <li> <p>Now the price of <code>$BTC</code> increases from $20K to $21K.     As a result:</p> <ul> <li>The vault CR is \\(\\$26K \\over \\$21K\\) \u2248 1.24, below the vault's 1.3 minimal CR.</li> <li>The pool CR is \\(\\$60K \\over \\$21K\\) \u2248 2.86, still above the pool's 2.5 minimal CR.</li> </ul> <p>Liquidation Trigger</p> <p>Because one of the CRs is below the minimal CR, liquidation can start after a system-defined wait period.</p> <p>If any of the CRs go below the CCB CR, liquidations can start immediately.</p> </li> <li> <p>A liquidator notices the CR levels and decides to liquidate $10K worth of FAssets by returning 0.48 <code>$FBTC</code> to the FAssets system.</p> <p>The liquidation premium factor is 1.1, so the liquidator receives $11K worth of assets:</p> <ul> <li>$10K worth of <code>$USDC</code> from the agent's vault collateral.</li> <li> <p>$1K worth of <code>$FLR</code> from the agent's portion of the collateral pool.</p> <p>The corresponding $1K worth of CPTs are burned, so their price is unaffected.</p> </li> </ul> <p>At this point, the agent is backing 0.52 <code>$FBTC</code> with:</p> <ul> <li> <p>0.5 <code>$BTC</code> underlying.</p> <p>The ratio is \\(0.5 \\over 0.52\\) \u2248 0.96, well above the 50% underlying backing factor.</p> </li> <li> <p>$16K worth of <code>$USDC</code> vault collateral.</p> <p>The vault CR is \\(\\$16K \\over \\$11K\\) \u2248 1.45, now above the vault's minimal CR.</p> </li> <li> <p>$59K worth of <code>$FLR</code> in pool collateral, of which $9K belong to the agent.</p> <p>The pool CR is \\(\\$59K \\over \\$11K\\) \u2248 5.36, still well above the pool's minimal CR.</p> </li> </ul> <p>Liquidation Finished?</p> <p>Both CRs are now above the minimal CR values, but liquidation does not stop until the CRs further increase up to the safety CR.</p> </li> </ol> <p>In summary, as a result of the price increase and the liquidation, around 50% of the backed <code>$FBTC</code> was burned. The actual amount of FAssets that need to be burned, though, depends on the safety CR setting.</p> Example 2: Large Price Movement <p>The same setup and initial conditions as in Example 1 are used: Using <code>$BTC</code> as underlying and <code>$USDC</code> as collateral, an agent creates a vault to mint <code>$FBTC</code> FAssets.</p> <ol> <li> <p>Initial conditions:</p> <ul> <li>The agent is backing 1 <code>$FBTC</code>, currently valued at $20K, according to the FTSO system.</li> <li>The minimal CR is 1.3 for the vault collateral and 2.5 for pool collateral.</li> <li>The agent must hold 20% of the pool's minimal CR.     In this case, 20% of 2.5 times $20K is $10K.</li> <li>The underlying backing factor is 50%, so the agent needs to hold only 0.5 <code>$BTC</code>.</li> <li>The liquidation premium factor is 1.1, of which 1.0 is paid in vault collateral, and 0.1 is paid in pool collateral.</li> </ul> <p>At this point, the 1 <code>$FBTC</code> is backed by:</p> <ul> <li>0.5 <code>$BTC</code> underlying.</li> <li> <p>$26K worth of <code>$USDC</code> vault collateral.</p> <p>The vault CR is \\(\\$26K \\over \\$20K\\) = 1.3, equal to the vault's minimal CR.</p> </li> <li> <p>$60K worth of <code>$FLR</code> in pool collateral, of which $10K belongs to the agent.</p> <p>The pool CR is \\(\\$60K \\over \\$20K\\) = 3, above the pool's minimal CR.</p> </li> </ul> </li> <li> <p>Now the price of <code>$BTC</code> increases from $20K to $30K.     As a result:</p> <ul> <li>The vault CR is \\(\\$26K \\over \\$30K\\) \u2248 0.87, way below the vault's 1.3 minimal CR.</li> <li>The pool CR is \\(\\$60K \\over \\$30K\\) = 2, below the vault's 2.5 minimal CR.</li> </ul> <p>To comply with the vault's 1.3 minimal CR, the agent needs 1.3 * $30K = $39K of <code>$USDC</code> vault collateral, which he does not have.</p> <p>Full Liquidation</p> <p>At this point, all the agent's FAssets backed by this vault must be liquidated.</p> </li> <li> <p>A liquidator notices this situation and decides to liquidate 1 <code>$FBTC</code>, currently worth $30K.</p> <p>The liquidation premium factor is 1.1, so the liquidator receives $33K worth of assets:</p> <ul> <li>$26K worth of <code>$USDC</code>, which is all of the collateral in the agent's vault.</li> <li>$7K worth of <code>$FLR</code>.</li> </ul> <p>Note that the portion of payment in <code>$FLR</code> is higher than in Example 1 because enough <code>$USDC</code> in collateral did not exist.</p> <p>At this point, the agent is backing 0 <code>$FBTC</code>, and the remaining collateral is:</p> <ul> <li>0.5 <code>$BTC</code> underlying.</li> <li>$0 worth of <code>$USDC</code> in vault collateral.</li> <li> <p>$53K worth of <code>$FLR</code> in pool collateral, of which $3K belongs to the agent.</p> <p>All this collateral can be freely withdrawn by its owners. Because this collateral is not backing any FAssets anymore, no part of it is locked.</p> </li> </ul> </li> </ol> Example 3: Very Large Price Movement <p>A price increment such that the vault plus the pool collateral is not enough to back the minted FAssets results in a combined CR lower than 1.   By design, liquidation payments will never exceed the combined CR times the liquidated amount, so, in this case, liquidation is not a profitable operation.</p> <p>Moreover, the collateral locked in the FAssets system might not be a strong enough deterrent for agents that want to dispose of the higher-valued underlying in an illegal way.</p>"},{"location":"tech/fassets/liquidation/#liquidation-triggers","title":"Liquidation Triggers","text":"<p>Some events related to liquidation are not detected automatically and must be triggered by entities external to the blockchain. These entities are liquidators and challengers.</p> <p>Anyone can be a liquidator or a challenger and earn rewards for contributing to the correct working of the FAssets system.</p> <p>Some triggers put an agent in liquidation mode, and some others get agents out of liquidation mode.</p>"},{"location":"tech/fassets/liquidation/#liquidation-enabling-triggers","title":"Liquidation-Enabling Triggers","text":"<ul> <li>A valid liquidation request is submitted, triggering the liquidation automatically.</li> <li>A liquidator triggers a liquidation manually, but does not submit a liquidation request immediately, seeking a better premium, because the premium might increase as time passes.</li> <li>A liquidator detects that the CR is below the CCB and sets the start time for an agent.     This operation does not immediately trigger the liquidation.     Instead, it starts a timer that enables the liquidation to be triggered after a system-defined time has elapsed.</li> <li>A proof of illegal activity is presented, which immediately triggers a full liquidation.</li> </ul>"},{"location":"tech/fassets/liquidation/#liquidation-disabling-triggers","title":"Liquidation-Disabling Triggers","text":"<p>After an agent enters the liquidation state, it remains there until its CR exceeds the safety CR again.</p> <p>The following operations can increase an agent's CR and can, therefore, potentially get the agent out of the liquidation state:</p> <ul> <li>Redemptions.</li> <li>A liquidation improves the agent's position.</li> <li>The agent deposits more collateral.</li> <li>The agent self-closes a position.</li> <li>After the price has moved so that the agent's position is healthy again, the agent, or someone on the agent's behalf, manually sets the liquidation state to false.</li> </ul> <p>Exiting the liquidation state as soon as possible is in the agent's best interest, even if the agent might re-enter it again soon. Premiums paid to liquidators might depend on how long the agent has been in liquidation, for example. Also, exiting the liquidation state resets the CCB timer.</p>"},{"location":"tech/fassets/liquidation/#tracking-the-underlying-balance","title":"Tracking the Underlying Balance","text":"<p>Agents are required to keep a certain percentage of underlying asset for each backed FAsset. This percentage, called the backing factor, is stored at an address on the underlying chain controlled by the agent.</p> <p>This requirement is enforced by balance-tracking in the FAsset contract. To track balances, the system must receive reports for each payment sent and received at the agent's address:</p> <ul> <li>Incoming payments are part of the minting process and are updated as the process occurs.</li> <li>Outgoing payments are either part of the redemption process or illegal payments, which are penalized.</li> </ul> <p>Challengers maintain the health of the FAssets system by monitoring the agent's underlying address to identify illegal operations that can make the agent's underlying backing too low. Challengers that correctly report illegal operations receive rewards from the agent's vault collateral.</p> <p>The following subsections contain details about all the topics that must be considered when monitoring an agent's underlying balance.</p>"},{"location":"tech/fassets/liquidation/#chain-fees","title":"Chain Fees","text":"<p>Fees for gas on the underlying chain can create issues for the FAssets system, so part of tracking an agent's underlying balance involves tracking the amount spent on fees on the underlying chain.</p> <p>Expensive gas fees can cause an address to have fewer assets than it should have and trigger a liquidation. Therefore, consider these actions:</p> <ul> <li> <p>Cap the gas usage on underlying chains: On smart-contract chains, the State Connector defines a cap on the gas amount to enable any simple transaction to pass.     If senders limit their gas amount to this cap and a transaction still fails due to insufficient gas, the failure is considered the receiver's fault, and the transaction is labeled as blocked.</p> <p>The gas cap is defined by the State Connector, not the FAssets system, because it is the State Connector that labels transactions as blocked.</p> </li> <li> <p>Maintain the underlying balance: Agents must ensure that the payment plus the transaction fee for a redemption never reduce their balance to an amount lower than the amount required to back the FAssets.     Agents can ensure that redemptions do not reduce that balance in several ways:</p> <ul> <li>They can honor redemptions from some other address.     On UTXO chains, they can also honor redemptions from a combination of addresses.</li> <li>They can top up the underlying address and then send proof of payment to update the tracked balance.     After a redemption begins, the agent has a limited time to comply, so topping-up is time-sensitive.</li> </ul> </li> </ul>"},{"location":"tech/fassets/liquidation/#underlying-withdrawals","title":"Underlying Withdrawals","text":"<p>Agents might legally withdraw part of the funds on their underlying address in several ways:</p> <ul> <li>Minting fees: A part of a minter's payment is the mint fee in the underlying asset.</li> <li>Failed redemptions: When an address is backing assets and those assets were redeemed, but the agent does not pay the redeemer, the redeemer is paid with collateral, and the agent can withdraw the assets.</li> <li>Liquidated assets: If an agent's position was partially or fully liquidated, the agent can withdraw the assets.</li> <li>Self-closed assets: After an agent self-closes, the closed assets can be withdrawn.</li> </ul> <p>The FAssets system must keep track of the agent's underlying funds, so when performing the above legal withdrawals, agents must still adhere to the following process:</p> <ol> <li>Announce the withdrawal to the FAssets system and obtain a payment reference.</li> <li>Perform the withdrawal, using the payment reference.</li> <li>Use the State Connector to obtain a proof of payment.</li> <li> <p>Present the proof of payment to the FAssets system, which clears the announcement.</p> <p>If the agent does not present the proof of payment, anyone can present it after a while and receive a reward from the agent's vault. Enabling nonagents to present this proof helps the FAssets system keep track of underlying balances.</p> </li> </ol> <p>Only one withdrawal announcement can be active per agent at any time to prevent the agent from overwhelming the balance-tracking system with many simultaneous small withdrawals.</p>"},{"location":"tech/fassets/liquidation/#illegal-payments","title":"Illegal Payments","text":"<p>Any challenger can report illegal payments from an underlying address and receive rewards in return.</p> <p>An illegal payment always triggers a full liquidation, which cannot be stopped. An agent can still escape paying the liquidation premium by self-closing before liquidators submit their liquidation requests, but the agent's vault remains unusable and must be closed. To resume operations, the agent must open a new vault with a different underlying address.</p> <p>The challenge system ensures that all minted FAssets are always backed by the assets on the agent's underlying address in the required percentage. Malicious agents might try to remove those assets in different ways. Therefore, challengers can report illegal activities by using these different challenges:</p>"},{"location":"tech/fassets/liquidation/#illegal-payment-challenge","title":"Illegal Payment Challenge","text":"<p>A payment from the agent's underlying address without a payment reference or with a payment reference that does not correspond to any open redemption or announced withdrawal.</p> <p>This challenge is performed in the following way:</p> <ol> <li>The challenger obtains proof of the illegal payment using the State Connector.</li> <li> <p>The challenger presents the proof to the FAssets system, which triggers:</p> <ul> <li>A vault collateral payment from the agent's vault to the challenger's address as a reward.</li> <li>The agent's state for the address is set to full liquidation.</li> </ul> </li> </ol>"},{"location":"tech/fassets/liquidation/#double-payment-challenge","title":"Double Payment Challenge","text":"<p>An agent might try to abuse a redemption request to pay to the redeemer and use the same payment reference to pay an amount to the agent's own address. An agent might even try to pay the redeemer multiple times when he is redeeming against himself.</p> <p>This activity is easy to detect after the first payment is reported in step 6 of the redemption process, because then the request is deleted and the second payment becomes illegal. However, a malicious agent might try to issue the second payment before reporting the completion of the first one.</p> <p>The double payment challenge catches this attempt as soon as the payments are finalized, regardless of whether they have been reported to the FAssets system.</p> <p>This challenge is performed in the following way:</p> <ol> <li>The challenger detects two seemingly legal payments from the same agent's underlying address and with equal payment reference, and obtains proofs for both using the State Connector.</li> <li>The challenger presents the two proofs to the FAssets system and triggers the reward payment and full liquidation.</li> </ol>"},{"location":"tech/fassets/liquidation/#negative-balance-challenge","title":"Negative Balance Challenge","text":"<p>One or more legal payments can make the balance on the agent's underlying address too small or equivalently make the free underlying balance negative. This situation can happen because gas fees might be unknown when redemptions are approved.</p> <p>This situation would normally be detected after all payments are reported, but in this way it can be caught as soon as the payments are finalized on the underlying chain:</p> <ol> <li>The challenger detects one or more legal payments from the same agent's underlying address and the total outgoing amount exceeds the sum of all redemption values plus the total free balance.     The challenger obtains proofs for all of them using the State Connector.</li> <li>The challenger presents all the proofs to the FAssets system, which checks that the transactions are from the agent's underlying address, that they have not been confirmed yet, and that their total really makes the free balance negative.     Then, it triggers reward payment and full liquidation.</li> </ol>"},{"location":"tech/fassets/liquidation/#time-lock-for-withdrawing-collateral","title":"Time Lock for Withdrawing Collateral","text":"<p>The agent's collateral backs minted FAssets but also pays challenge fees and possibly illegal payment penalties. Because finalization on some underlying chains takes a long time, challenges can sometimes be proved to be valid only after an agent's position is already closed and enough collateral to pay them is not available.</p> <p>For this reason, collateral withdrawals are locked for a certain amount of time before they become effective. The amount of time varies depending on the underlying chain and the time frame required for achieving finality on that chain.</p> <p>For agents, any collateral withdrawals must be announced, and then the amount is locked for some time before it can be withdrawn. The locked collateral is also ineligible for minting.</p> <p>Agents must announce the closing of their vaults. They become unusable until the lock expires, and then they can be closed.</p>"},{"location":"tech/fassets/minting/","title":"FAssets Minting","text":"<p>Minting FAssets is the process of wrapping underlying tokens from connected blockchains into FAssets to be used on the Flare blockchain. Any user can mint FAssets.</p>"},{"location":"tech/fassets/minting/#minting-process","title":"Minting Process","text":"<p>This is the summary of the minting process:</p> <p> </p> Minting process. <ol> <li>The minter chooses an agent from the publicly available agent list.     The choice is based on the minting fee or the amount of free collateral, which must be enough to back the amount to be minted.</li> <li> <p>The minter sends to the Asset Manager contract a collateral reservation transaction (CRT). The CRT includes:</p> <ul> <li>The address of the chosen agent</li> <li>The amount to mint, which must be a whole number of lots</li> <li>The collateral reservation fee (CRF) to compensate for the locked collateral</li> </ul> </li> <li> <p>The Asset Manager contract locks the agent's collateral in the amount needed to back the whole minting until the underlying payment is proved or disproved.     The collateral reservation response is an event issued by the contract, which includes:</p> <ul> <li>The agent's address to which the minter must send funds on the underlying chain.</li> <li>The amount to be paid on the underlying chain, which corresponds to the amount to be minted plus the agent's fee.</li> <li>The payment reference, which is a unique 32-byte number the minter must include as a memo in the payment on the underlying chain.</li> <li> <p>The last underlying block and the last underlying timestamp to pay.     Valid payments occur either before the last block or before the last timestamp, both inclusive.</p> <p>The time to pay is measured both in the underlying chain's block numbers and block times because the underlying chain might halt for a long time.       In this situation, the block numbers do not increment but the block timestamps do.</p> </li> </ul> </li> <li> <p>After this event is emitted, the minter must pay the full underlying amount plus the fee to the agent on the underlying chain in a certain amount of time.</p> </li> <li>Using the State Connector, the minter proves the payment on Flare.</li> <li>After the payment is proved, the minter executes the minting process, which sends FAssets to the minter's account.</li> </ol> <p>When minting is executed, the minting fee is split between the agent and the pool:</p> <ul> <li>The percentage split is set by the agent.</li> <li>The agent's share increases the free balance on the agent's underlying address.   The free balance is the part of the balance in an agent's underlying address that the agent can withdraw.   It is composed of minting fees, redemption fees, and self-closed FAssets.</li> <li>The pool share gets minted as FAssets and credited to the collateral pool contract.</li> </ul> <p>After minting is complete, the Asset Manager creates a redemption ticket, which includes the mint amount and the name of the agent backing the minting.</p>"},{"location":"tech/fassets/minting/#fees","title":"Fees","text":"<p>The following fees are paid to mint FAssets:</p> <ul> <li> <p>The collateral reservation fee (CRF) is paid in native tokens by the minter at the same time the CRT is made.   The CRF is defined by governance as a percentage of the minted value, and the same fee applies to all agents.</p> <p>When the minter does not pay on the underlying chain, this fee compensates the agent and the CPT holders for the time their collateral was locked while the mint processed. If the minter pays on the underlying chain, the CRF is burned.</p> <p>For underlying chains on which proving payments takes a long time, the fee might be higher than the fee on chains that quickly prove payments.</p> </li> <li> <p>The minting fee is paid by the minter with the underlying currency as a percentage of the minted amount, and each agent can declare a different fee value.   This fee is the main source of revenue for the agent and the CPT holders.</p> <p>The minting fee is further divided in two shares:</p> <p> Minting fees. </p> <ul> <li>Agent's share: This share remains in the agent's underlying account but is not marked as being in use.     The agent can use this balance freely.</li> <li>Pool's share: This share is minted as FAssets and sent to the collateral pool.     The percentage of this share is defined by the agent and can be changed by the agent after a delay that provides time for minters to notice the change.</li> </ul> <p>The Collateral page contains more information about this fee.</p> </li> </ul>"},{"location":"tech/fassets/minting/#payment-failure","title":"Payment Failure","text":"<p>To finalize the minting, the minter must pay the agent on the underlying chain and prove the payment was received. If the payment is not completed in the time frame defined by the underlying chain block and timestamp, the agent must prove nonpayment to release the locked collateral. After nonpayment is proved, the agent's collateral that was reserved by the CRT is released, and the agent receives the CRF.</p> <p>The agent's registration process verifies that the agent's underlying address does not purposefully block payments and illegally collects the CRF.</p> <p>Example: Proof of Nonpayment</p> <p>The following example shows how the nonpayment proof works.</p> <p>The State Connector's payment nonexistence attestation type proves nonpayment.</p> <ol> <li> <p>The minter sends a request to mint <code>$FBTC</code>.     At the time the request is received, the last mined block on the Bitcoin chain is number 92, with timestamp 09:00 AM.</p> <p>The Asset Manager answers with the following threshold settings to complete the payment:</p> <ul> <li>Block 100</li> <li>Timestamp 11:00 AM</li> </ul> </li> <li> <p>Block 101 is mined with timestamp 10:59 AM.    At this point, the payment can still happen.</p> </li> <li> <p>Block 102 is mined with timestamp 11:04 AM.    Payment did not occur.    After this block is finalized, nonpayment can be proved.</p> </li> <li> <p>Block 109 is mined.    In this case, 7 blocks on the Bitcoin blockchain are enough blocks to assume finality.</p> </li> <li>The agent sends a nonpayment attestation request, which includes the payment reference, the underlying amount that was expected, the last block (100), and the last timestamp (11:00).</li> <li> <p>Attestation providers attest to the following facts:</p> <ul> <li>Block 102 is finalized and has both the number and timestamp larger than required.</li> <li>Until this block, the required payment either was not made or was not sufficient.</li> </ul> </li> </ol> <p>Now, the mint-payment failure and the nonpayment proof can be submitted to the FAssets system.</p>"},{"location":"tech/fassets/minting/#edge-cases","title":"Edge Cases","text":"<ul> <li> <p>Unresponsive minter: After a successful payment, the minter might not provide the payment proof needed to complete the minting process.     In this case, the agent can present the payment proof and execute minting at any time.     FAssets are still transferred to the minter's account, and the agent's collateral becomes redeemable.</p> </li> <li> <p>Expired proof: Proofs provided by the State Connector are available for only 24 hours, approximately.     If neither the minter nor the agent presents the proof of payment or nonpayment within 24 hours, the regular minting process cannot continue, and the agent's collateral could be locked indefinitely.</p> <p>In this case, the agent can still recover the collateral by buying it back with native tokens. The recovery is accomplished with the following procedure:</p> <ol> <li>Request the proof from the time when the deposit should have happened.     The State Connector's answer will indicate that payments proofs are no longer available for that time.</li> <li>Provide the amount of <code>$FLR</code> collateral equivalent to the price of the underlying assets that should have been deposited.</li> <li>Present the proof.</li> </ol> <p>Because a successful deposit cannot be proven, the FAssets system burns the amount of collateral in native tokens provided by the agent. After the burn is complete, the rest of the agent's collateral is released, both from his vault and the collateral pool.</p> <p>Warning</p> <p>Note that this procedure should be used only in rare cases because providing timely payment or nonpayment proofs is always more advantageous for agents.</p> </li> </ul>"},{"location":"tech/fassets/minting/#duration-of-the-minting-process","title":"Duration of the Minting Process","text":"<p>The duration of the minting process depends mainly on the speed of the underlying chain. The maximum duration of the process is the sum of:</p> <ul> <li>A system-defined maximum time for deposit.     It is either a few blocks on the underlying chain or a few minutes, whichever is longer.</li> <li>The underlying chain's finalization time.</li> <li>The State Connector proof time, which is approximately 3 - 5 minutes, independent of the underlying chain.</li> </ul> <p>On fast chains like XRPL, the maximum total time is less than 10 minutes, while on Bitcoin it is approximately 1.5 hours. For payment failures, the agent needs to wait the maximum time, as defined above, before the nonpayment proof can be retrieved.</p>"},{"location":"tech/fassets/minting/#minting-payment-reference","title":"Minting Payment Reference","text":"<p>The system generates a unique payment reference at the time of the collateral reservation request. The minter must include the payment reference in a memo field when the underlying payment transaction is made.</p> <p>The payment reference ensures the payment transaction cannot be used by another entity that might claim to have made the payment on the underlying chain and receive the minted FAssets in return. Additionally, if the payment time expires before payment is done, the agent can prove that no payment with that reference was made.</p> <p>A similar payment reference for the same purposes is generated for redemptions.</p>"},{"location":"tech/fassets/minting/#redemption-tickets-and-the-redemption-queue","title":"Redemption Tickets and the Redemption Queue","text":"<p>For every minting operation, a redemption ticket is created. This ticket references the minted amount and the agent that is backing the minting.</p> <p>The redemption tickets are ordered in a queue that determines the next agent to be redeemed against according to the first in, first out method (FIFO). In other words, the first redemption ticket created will be the first redemption ticket processed. The FIFO queue impartially ensures that all agents have the opportunity to fulfill the duties of their role.</p> <p>Example: Redemption Queue</p> <p>The following example shows how the redemption queue works.</p> <ol> <li>Bob mints 10 <code>$FXRP</code> with Agent 1.</li> <li>Alice mints 20 <code>$FXRP</code> with Agent 2.</li> <li> <p>Charlie mints 5 <code>$FXRP</code> with Agent 1.</p> <p>After Bob, Alice, and Charlie have minted their FAssets, the redemption queue according to the FIFO method is:</p> <ol> <li>Agent 1 with 10 <code>$FXRP</code>.</li> <li>Agent 2 with 20 <code>$FXRP</code>.</li> <li>Agent 1 with 5 <code>$FXRP</code>.</li> </ol> </li> <li> <p>Dana redeems 25 <code>$FXRP</code>.    To redeem 25 <code>$FXRP</code>:</p> <ol> <li>Agent 1 pays 10 <code>$FXRP</code>.</li> <li>Agent 2 pays 15 <code>$FXPR</code>.</li> </ol> <p>Now, the redemption queue according to the FIFO method is:</p> <ol> <li>Agent 2 with 5 <code>$FXRP</code>.</li> <li>Agent 1 with 5 <code>$FXRP</code>.</li> </ol> </li> </ol>"},{"location":"tech/fassets/minting/#lots","title":"Lots","text":"<p>Every minting and redemption must be made in a whole number of lots. Lots serve the following purposes:</p> <ul> <li>They prevent underlying transaction fees from exceeding minting or redemption fees.</li> <li>They restrict large numbers of very small redemption tickets from being submitted, which would increase gas costs.</li> </ul> <p>The initial lot size is equivalent to $1,000 USD. According to this initial size, no less than 1 lot ($1,000 USD) of the underlying token can be minted as an FAsset.</p> <p>Over time, the lot size can be updated to reflect price fluctuations of the underlying asset. Only a governance call can update the lot size, and it can be updated only by a limited amount per day.</p> <p>Dust</p> <p>Some processes generate a fractional number of lots:</p> <ul> <li>On minting, part of the minting fee is minted as the FAsset fee to the collateral pool.   This value is usually less than 1 lot.</li> <li>When the lot size is changed, redemptions close only a whole number of lots of each redemption ticket, which leaves the remainder unredeemed.</li> </ul> <p>These amounts, known as dust, cannot be redeemed directly because redemption requires a whole number of lots.</p> <p>In such cases, the generated dust is not included in any redemption ticket. Instead, each agent's dust is accumulated until the dust amounts to a whole lot. When that happens, another redemption ticket is automatically created.</p> <p>Therefore, the dust can be recovered or destroyed in the following ways:</p> <ul> <li>If the dust exceeds 1 lot during minting, the part that is a whole multiple of a lot is automatically added to the created redemption ticket.</li> <li> <p>If an agent does not mint any FAssets for a while but the lot size changes and several redemptions occur, enough dust might accumulate to more than 1 lot.</p> <p>In this case, the part that is a whole multiple of a lot can be converted to a redemption ticket by request. To prevent an inactive agent making FAssets less fungible, this request can be made by any address.</p> </li> <li> <p>Self-closing can work with fractional lots, so it can be used to remove dust.</p> </li> <li>Liquidation can work with fractional lots too, so it can also be used to remove dust.</li> </ul>"},{"location":"tech/fassets/minting/#self-minting","title":"Self-Minting","text":"<p>Agents can also act as minters and mint FAssets from their own vaults. This process is called self-minting and is simpler than regular minting because neither the CRT nor the agent's fee are necessary.</p> <p>When an agent self-mints FAssets:</p> <ul> <li>The agent still needs to pay the amount to mint on the underlying chain and execute the minting.</li> <li>The self-minting operation also adds a ticket to the redemption queue, alongside tickets added by mints done by other users.     All tickets are processed by the FIFO queue.</li> <li>Only the pool's share of the fee must be paid.</li> </ul> <p>Because self-minting is done without a collateral reservation request, in some cases, a change between the underlying deposit and the execution, such as another collateral reservation, price change which reduces the amount of free lots, or lot-size change, might prohibit the intended number of lots to be minted. If one of these changes occurs, the agent can self-mint a smaller number of lots, even 0 lots, and the remainder of the deposited underlying assets is added to the free underlying balance.</p> <p>Additionally, when agents create a vault, they can choose not to make it public, so the vault can only be used to self-mint.</p>"},{"location":"tech/fassets/redemption/","title":"FAssets Redemption","text":"<p>Any holder of FAssets can redeem their FAssets for the underlying original asset. To do so, these holders, known as redeemers, send FAssets to the Asset Manager smart contract, and the redeemed amount is paid with the underlying asset from an agent's address.</p>"},{"location":"tech/fassets/redemption/#redemption-process","title":"Redemption Process","text":"<p>This is the summary of the redemption process:</p> <p> </p> Minting. <ol> <li> <p>The redeemer starts the redemption for a whole number of lots by issuing a request to the Asset Manager smart contract.</p> <p>The FAssets system chooses one or more redemption tickets from the front of the FIFO redemption queue. The number of chosen redemption tickets is capped to avoid high gas consumption. If the redemption amount requires too many tickets, only a partial redemption is done.</p> </li> <li> <p>The system burns FAssets from the redeemer\u2019s account in the amount of the total of the selected redemption tickets.     If the redeemer's account does not contain enough FAssets, the redemption fails immediately.</p> </li> <li> <p>Each chosen ticket belongs to an agent.     For every agent participating in the redemption, the system issues an event with the following redemption payment information:</p> <ul> <li> <p>Redeemer\u2019s underlying address.</p> <p>Agents can use the State Connector to ensure the validity of this address. Otherwise, malicious redeemers could provide an address that systematically blocks payments and exploit the redeeming process to their advantage (See Redemption Payment Failure below).</p> </li> <li> <p>Amount to pay minus the fee that was already subtracted.</p> </li> <li>A payment reference.     This payment reference is different for each agent and each redemption.</li> <li>The last underlying block and the last underlying timestamp to complete the payment.</li> </ul> </li> <li> <p>Every agent pays the redeemer on the underlying chain and includes the payment reference in the memo field of the payment transaction.</p> <p>Agents can pay the redemption from any address they control on the underlying chain. It does not need to be the same address where they receive minting payments.</p> </li> <li> <p>After the payment is finalized, the agent uses the State Connector to prove the payment and obtain a payment proof.</p> </li> <li> <p>After the payment proof is presented to the FAssets system, the agent's vault collateral and pool collateral that were backing those FAssets are released.</p> <p>After the collateral is released, it can either back the minting of more FAssets or be withdrawn.</p> </li> </ol>"},{"location":"tech/fassets/redemption/#redemption-payment-failure","title":"Redemption-Payment Failure","text":"<p>Agents have a limited time to pay the redeemer on the underlying chain. The amount of time is defined by the last block and the last timestamp on the underlying chain. If the payment is not made in time, the redeemer has to prove nonpayment to be compensated. After the redeemer presents the nonpayment proof, he is paid with the agent's collateral plus a premium. The premium is intended to encourage the agent to complete redemptions by paying with the underlying asset instead of collateral.</p> <p>If a payment fails and the failed transaction is recorded on the underlying chain, the agent must submit a proof of failed payment. In this way, the gas costs of the failed transaction can be accounted for by the FAssets system. If the transaction was not recorded, then no gas was spent and reporting is not necessary.</p> <p>If the agent does not report the failed payment in time, anyone can report the failed payment and receive a reward from the agent's vault.</p> <p>Blocked Payments</p> <p>When payment fails because of the redeemer, the agent can obtain a proof of the failed payment from the State Connector and present it to the FAssets system. The agent's obligation is then fulfilled, and he can keep both the collateral and the underlying.</p> <p>Two different proofs can be used:</p> <ul> <li>Proof of invalid address, due to a wrong syntax or checksum, for example.</li> <li> <p>Proof of blocked payment: Even if the address is valid, it might contain a contract that blocks the payment.     This can only happen on underlying networks supporting smart contracts.</p> <p>The agent must still try to pay and, if the payment is blocked, the agent can request this proof from the State Connector and present it to the FAssets system.</p> </li> </ul> <p>During step 4 above, if any agent does not to pay on the underlying chain, the redeemer completes the following procedure separately for each nonpaying agent:</p> <ol> <li>The redeemer obtains a proof of nonpayment from the State Connector.</li> <li>The redeemer presents the nonpayment proofs to the FAssets system, which triggers a redemption failure.</li> <li>The redeemer is paid with collateral, according to the current price plus a premium.</li> <li>FAssets are overcollateralized, so, even after paying the redeemer with a premium, a remainder is released.    This remainder is derived by the system-wide collateral ratio settings specified by governance.</li> <li>The underlying assets backing the redeemed FAssets are marked as free and can be withdrawn by the agent later.</li> </ol>"},{"location":"tech/fassets/redemption/#edge-cases","title":"Edge Cases","text":"<ul> <li>Unresponsive redeemer: After a redemption nonpayment, the redeemer might not report the failure for some reason.   In this case, the agent can present a nonpayment proof, and the redeemer receives collateral plus a premium.   After this operation, the underlying backing collateral and the remaining local collateral are released.</li> <li>Unresponsive agent: After a successful payment, the agent might not present the payment proof.   Because the agent has already paid, the redeemer is not affected.   However, the system still requires the payment proof to correctly track the agent's balance on the underlying chain.   After enough time for the agent to present the proof has elapsed, anyone can present the payment proof and receive collateral from the agent\u2019s vault.</li> <li> <p>Expired proof: Proofs provided by the State Connector are available for only 24 hours, approximately.   If neither the redeemer nor the agent presents the proof of payment or nonpayment within 24 hours, the regular redeeming process cannot continue, and the agent's collateral could be locked indefinitely.</p> <p>The procedure to recover this collateral is the same as the procedure in the minting case.</p> </li> </ul>"},{"location":"tech/fassets/redemption/#redemption-fee","title":"Redemption Fee","text":"<p>The redemption fee is the amount of the underlying asset that the agent can keep for doing the redemption. This fee is meant only to cover the agent\u2019s transaction fee on the underlying chain, so it is not shared with the collateral pool. The fee percentage is defined by governance, is the same for all agents, and is typically smaller than the minting fee.</p> <p>Governance calculates the percentage so that the fee to redeem 1 lot pays for a typical transaction fee on the underlying chain. Therefore, when larger amounts on a single address are redeemed, the agent accrues some extra fees because the underlying fee for small and large transactions is the same. However, when underlying fees are very high, the agent might still lose funds when a redemption for a small amount, such as 1 lot, is made. If this situation occurs frequently, governance will increase the redemption-fee percentage.</p>"},{"location":"tech/fassets/redemption/#self-redemption","title":"Self-redemption","text":"<p>Agents can also act as users and redeem FAssets from their own vaults. This process is called self-redemption or self-closing, and it is simplified because payment on the underlying chain is not required.</p> <p>As shown in the following process, agents can self-redeem for any reason, including to stop liquidations because it reduces the amount of FAssets the agent is backing.</p> <ol> <li>An agent sends FAssets to their account.</li> <li>FAssets are burned.</li> <li>The collateral that was backing those assets is released.</li> <li>The underlying collateral is released and can be withdrawn from the underlying address later.</li> </ol> <p>The self-redeemed amount is not limited to a whole number of lots and can be less than 1 lot, which makes self-closing ideal for redeeming an agent's dust.</p>"},{"location":"user/","title":"User Guides","text":"<p>This section contains step-by-step guides on how to use tools like the Block Explorer or the different wallets.</p> <p>Select one of the topics below:</p> <ul> <li>Automatic Claiming</li> <li>Block Explorers</li> <li>Claiming the FlareDrop</li> <li>FTSO Delegation</li> <li>Governance</li> <li>Personal Delegation Accounts</li> <li>Staking on Validators</li> <li>Wallets</li> <li>Wrapping Tokens</li> </ul>"},{"location":"user/automatic-claiming/","title":"Automatic Claiming","text":"<p>To save time, maximize compound interest, and avoid unnecessary exposure of a cold wallet, you can set an executor to claim rewards for you. Executors then use automatic claiming to send rewards directly to your account.</p>"},{"location":"user/automatic-claiming/#introduction","title":"Introduction","text":"<p>To set an executor you only need to enter its address in the Flare Portal.</p> <p>However, the Flare Portal does not help you find executor addresses, so you must find them in different ways, depending on whether they are manual or registered:</p> <ul> <li>Manual executors are ones that you locate yourself.     Whether they charge a fee or not and how you pay it is between you and the executor.</li> <li>Registered executors are listed in a smart contract and can be retrieved, for instance, using the block explorer or third-party applications.     These executors charge a fee when you set them up and every time they claim for you.</li> </ul> <p>Overview of autoclaiming functionality</p> <p>For an overview of what is available for the entire autoclaiming feature, see Automatic Claiming in the Flare Fundamentals section.</p>"},{"location":"user/automatic-claiming/#prerequisite","title":"Prerequisite","text":"<p>To enable an executor, obtain its address off-chain or, for registered executors, on-chain.</p> <p>The list of registered executors has not been added yet to the Flare Portal, but a manual method is given below using the block explorer (recommended for advanced users).</p> Find a registered executor (using the Block Explorer) <p>To find an executor you will need to use the <code>ClaimSetupManager</code> contract. See the Contract Addresses page to learn how to find the address of this contract.</p> <ol> <li>In the Block Explorer, paste the address of the <code>ClaimSetupManager</code> contract and scroll down to select the Read Contract tab.</li> <li>To get the available executors' addresses, scroll down to <code>getRegisteredExecutors</code> and enter a range of how many addresses to check, for example, <code>0</code> in the _start field and <code>10</code> in the _end field.</li> <li>Click Query. The Block Explorer returns the addresses and the total number available, so you can know if you've gotten them all.</li> <li>To get the executor's fee, copy one address at a time and enter it in the executor field for <code>getExecutorCurrentFeeValue</code>.</li> <li>Click Query. In the future, there will be more criteria to help with making this decision.</li> <li>Choose an executor and copy its address.</li> </ol>"},{"location":"user/automatic-claiming/#enabling-automatic-claiming","title":"Enabling Automatic Claiming","text":"<p>Now that you have your desired executor's address, you can set it as the executor for your account.</p> <ol> <li>Open the Flare Portal.</li> <li>Click Connect to Wallet and log into your wallet.    The interface to your Main Account opens.      Flare Portal Main Account interface. </li> <li>In the Executor section, click Add or Change.</li> <li>Paste the executor's address.     A message confirms the executor's fee, whether it is a registered executor, and whether rewards go to your Main Account or your Personal Delegation Account (PDA).      Set an executor. </li> <li>To set this executor, click Confirm.    Your wallet opens with the details of the transaction.</li> <li>Review the transaction and confirm it.</li> </ol> <p>If you confirm the executor, the Flare Portal displays the executor address you have selected, whether it is registered, and its fee. Note also that the Add button now reads Change, enabling you to remove or change the executor any time you choose.</p> <p></p> The executor is confirmed. <p>Reward must be high enough to pay the executor's fee</p> <p>If the reward amount is too low to accommodate the fee, automatic claims won't occur, so you may see small amounts of unclaimed rewards even if you have autoclaiming set up.</p>"},{"location":"user/automatic-claiming/#disabling-automatic-claiming","title":"Disabling Automatic Claiming","text":"<p>To disable automatic claiming and stop paying the executor fees, go through the above process again and clear the Executor address field in Step 4. This is, confirm an empty address.</p> <p>Once you confirm the transaction in your wallet, automatic claiming will be disabled.</p>"},{"location":"user/automatic-claiming/#checking-for-accrued-rewards","title":"Checking for Accrued Rewards","text":"<p>To check if you have accrued rewards, go to the Flare Portal:</p> <ol> <li>Click Connect to Wallet and log into your wallet.</li> <li>Select your Main Account or Delegation Account, if you have enabled a PDA.</li> <li>At the bottom of the screen, see the Claim x FLR button, where x is the number of <code>$FLR</code> rewards you can claim.</li> </ol> <p>Note</p> <p>If the configured executor is doing its job correctly, you should never see any pending rewards.</p>"},{"location":"user/claiming-the-flaredrop/","title":"Claiming the FlareDrop","text":"<p>Claiming the FlareDrop is available every 30 days and is based on the average balance from the last 23 days of each 30-day month. Therefore, it is advised that each address claim its funds during the first 7 days of each 30-day round.</p> <p>See The FlareDrop concept page for further explanation.</p> <p></p> FlareDrop distribution dates. <p>There are several ways to claim. You can claim:</p> <ul> <li>Using the Flare Portal.</li> <li>Through an executor, which you can configure using the Portal, or</li> <li>Directly against a smart contract (for advanced users).</li> </ul> <p>Two steps to ensure receiving all your <code>$FLR</code> !</p> <p>You must:</p> <ol> <li>Wrap <code>$FLR</code> to receive it. Rewards are proportional to the <code>$WFLR</code> balance, not <code>$FLR</code>, so always wrap as much <code>$FLR</code> as you can! Wrapping has no downside: Wrapped tokens continue to be available for delegation and governance voting, for example, and they can be unwrapped at any time. See Wrapping Flare Tokens.</li> <li>Claim before the distribution expires. After the distribution becomes claimable, it expires in two bank months and a week (67 days).</li> </ol>"},{"location":"user/claiming-the-flaredrop/#claiming-from-the-flare-portal","title":"Claiming from the Flare Portal","text":"<p>Claim manually from the Flare Portal. From there, you can see how many <code>$FLR</code> tokens you have to claim and you can claim them.</p> <ol> <li>Go to the Flare Portal.</li> <li>Click Connect to Wallet and log into your wallet.</li> <li>Your Main Account is open by default.    If you enabled a PDA and want to claim for it instead, click Delegation Account.</li> <li>Under Claim your FlareDrop distribution, any <code>$FLR</code> you have to claim displays on the button.      Claim Your FlareDrop Distribution. </li> <li>Click the Claim button to claim your <code>$FLR</code>.     A confirmation dialog opens.      FlareDrop claiming confirmation.      As a convenience, you have the choice to wrap your tokens after claiming them.     In this way they are ready for the next FlareDrop or to be delegated to the FTSO system, for example.</li> <li>Click on the Claim All Distribution button and confirm the transaction on your wallet.</li> </ol>"},{"location":"user/claiming-the-flaredrop/#nominating-executors","title":"Nominating Executors","text":"<p>Alternatively, you can assign an executor to claim the FlareDrop for you. This is useful for cold wallets but also for any users wishing to reduce their operational burden. See Automatic Claiming to learn how.</p>"},{"location":"user/personal-delegation-account/","title":"Personal Delegation Accounts","text":"<p>You can receive <code>$WFLR</code> rewards for making contributions to the Flare community, for example, by delegating your tokens to FTSO data providers.</p> <p>A Personal Delegation Account (PDA) allows you to keep these rewards temporarily separate from your main account, so that you can track them, for example, as a personal record or for tax purposes. In certain jurisdictions, delaying the realization of earnings for a specified time can lead to a reduced tax rate. See the Concept page for more detail.</p> <p>Particularly, the balance of a PDA can still be redelegated to earn compounded interest and the governance votes it grants can be transferred to another address.</p> <p>If a PDA is enabled and you configured an executor, it automatically claims rewards for the main account and the PDA, and sends them to the PDA.</p>"},{"location":"user/personal-delegation-account/#enabling-a-pda","title":"Enabling a PDA","text":"<p>You can enable and disable your PDA at any time in the Flare Portal without any ill-effect, except the cost of the transaction fee.</p> <ol> <li>Open the Flare Portal.</li> <li>Click Connect to Wallet and log into your wallet.    The interface to your Main Account opens.      Main Account opens. </li> <li>To switch from the Main Account to your PDA, click Delegation Account.</li> <li>Click Enable.      Enable a PDA. </li> <li>A popup appears with a short description of what a PDA is.      Confirm enabling the PDA. </li> <li>Click Enable.    Your wallet shows the details of the transaction.</li> <li>Review the transaction and confirm it.</li> </ol> <p>Once the PDA is enabled, the Flare Portal displays the PDA address and the initial <code>0.0</code> <code>$WFLR</code> balance. Your PDA is now ready to receive rewards!</p> <p></p> The PDA address is enabled. <p>If a PDA is enabled and you configured an executor, it automatically claims rewards for the main account and the PDA, and sends them to the PDA.</p>"},{"location":"user/personal-delegation-account/#operations-available-in-a-pda","title":"Operations available in a PDA","text":"<p>Other operations available are:</p> Operation Description Disable You can Disable the PDA at any time. Disabling sends all <code>$WFLR</code> back to the main account to your <code>$WFLR</code> balance. Automatic claims from executors will go to the main account as well. Withdraw You can withdraw from your PDA at any time. Click Withdraw, enter the amount of <code>$WFLR</code> to withdraw, and click Withdraw again. The amount is sent to your main account to your <code>$WFLR</code> balance. Delegate You can delegate your rewards to FTSO data providers for compounded rewards. Transfer votes A PDA cannot vote on governance proposals directly, but it can transfer its votes to another address, including its main account. Click Transfer votes, click main account or enter an address to transfer to, and click Confirm. Claim FLR The Claim FLR button shows how many rewards you have to claim. Use this button to claim rewards yourself, or configure an executor from the main account tab to do that for you."},{"location":"user/wrapping-tokens/","title":"Wrapping Flare Tokens","text":"<p>This information explains how to wrap and unwrap native tokens on various Flare networks using the Flare Portal or the block explorer. Wrapped tokens are required to delegate your vote power to FTSO data providers and to vote on decisions that affect how Flare networks operate.</p> <p>When you complete the following steps for wrapping, your native tokens, such as <code>$FLR</code> and <code>$SGB</code>, are wrapped into <code>$WFLR</code> and <code>$WSGB</code>, respectively, so that you can participate in FTSO delegation and governance. When you need to convert your wrapped tokens into native tokens again, unwrap the wrapped tokens using similar steps, as described below.</p>"},{"location":"user/wrapping-tokens/#using-the-flare-portal","title":"Using the Flare Portal","text":"<ol> <li> <p>Open the Flare Portal.     The home page is displayed.</p> <p> Flare Portal home. </p> </li> <li> <p>Click Connect to Wallet and log into your wallet.     The interface to your Main Account opens.</p> </li> <li> <p>Ensure you are connected to the network you want.     In the following image, the wallet is connected to the Flare network.</p> <p> Main Account on the Flare network. </p> </li> <li> <p>Choose one of the following options:</p> <ul> <li> <p>Wrap: Locate your balance of native tokens, and click Wrap.</p> <p>Never wrap all your tokens</p> <p>Wrapping and unwrapping tokens are transactions with fees to be paid in native tokens. Always leave some unwrapped tokens to pay for transaction fees.</p> <p>Specify the amount to wrap, and click Wrap again.</p> </li> <li> <p>Unwrap: Locate your balance of wrapped tokens, and click Unwrap.     Specify the amount to unwrap, and click Unwrap again.</p> </li> </ul> </li> <li> <p>Follow the steps to complete the transaction in your wallet.</p> </li> </ol> <p>Your wrapped token balance is updated and displayed in the Flare Portal and your wallet.</p> <p>If your wrapped token balance is not displayed in your wallet, you must manually add the wrapped token so that your wallet recognizes it.</p>"},{"location":"user/wrapping-tokens/#using-the-block-explorer","title":"Using the Block Explorer","text":"<p>This section is for advanced users.</p> <ol> <li>Open a block explorer.</li> <li>From the block explorer, follow the Retrieval from Blockchain procedure to find and open the <code>WNat</code> contract.</li> <li>Click Connect Wallet, and complete the steps to connect your wallet, ensuring you are on the network on which you will wrap tokens.</li> <li> <p>Click the Write Contract tab, and use the following methods to wrap and unwrap tokens:</p> <ul> <li><code>deposit</code>: Wraps the amount of native tokens you specify in the field.</li> <li><code>withdraw</code>: Unwraps the amount of native tokens you specify in the field.</li> </ul> </li> </ol> <p>Your token balance is updated and displayed in your wallet.   If your wrapped token balance is not displayed in your wallet, you must manually add the wrapped token so that your wallet recognizes it.</p>"},{"location":"user/wrapping-tokens/#adding-wrapped-tokens-to-wallets","title":"Adding Wrapped Tokens to Wallets","text":"<p>Your wrapped tokens are stored on the blockchain in a special ERC-20 smart contract called <code>WNat</code>, for Wrapped Native tokens. Some wallets, like the Bifrost Wallet, are aware of this contract and are therefore preconfigured to display <code>$WFLR</code> and <code>$WSGB</code> balances. Some other wallets, though, require you to configure them so that they can display wrapped-token balances.</p> <p>If your wallet doesn't display your wrapped-token balance, you need to configure it, either automatically or manually as described in the following procedures.</p>"},{"location":"user/wrapping-tokens/#automatically","title":"Automatically","text":"<p>This is typically the fastest procedure, but might not work with all wallets.</p> <ol> <li> <p>Open the Flare Portal. The home page is displayed.</p> <p> Flare Portal home. </p> </li> <li> <p>Click Connect to Wallet and log into your wallet. The interface to your Main Account opens.</p> </li> <li> <p>Ensure you are connected to the network you want. In the following image, the wallet is connected to the Flare network.</p> <p> Main Account on the Flare network. </p> </li> <li> <p>On the Main Account tab, locate the Account heading and the Help icon, identified by a question mark.</p> <p> Flare Portal Account Help. </p> </li> <li> <p>Click the Help icon and click How do I add Wrapped Flare token to my wallet?.    A Click here link for adding <code>$WFLR</code> to your wallet is displayed.</p> <p> Flare Portal Wrapping Help. </p> </li> <li> <p>Click Click here.    Your wallet opens. Wallets typically ask you to accept the token. The exact instructions depend on your wallet.</p> </li> <li> <p>Follow the prompts in your wallet to add the wrapped token.</p> </li> </ol> <p>Your wrapped token balance is displayed in your wallet.</p>"},{"location":"user/wrapping-tokens/#manually","title":"Manually","text":"<p>This section is for advanced users.</p> <p>If the automatic method did not work for you, most wallets can still be configured to recognize ERC-20 tokens through an Import tokens or Add custom asset menu, for example.</p> <p>The exact instructions depend on your wallet, but they generally just require you to locate the aforementioned menu and provide the address of the <code>WNat</code> contract. The wallet can usually then retrieve the token name, symbol, and number of decimals directly from the contract.</p> <p>See the Contract Addresses page to find the address of the <code>WNat</code> contract.</p>"},{"location":"user/block-explorers/","title":"Block Explorers","text":"<p>Block explorers enable you to analyze transactions and interact with addresses on blockchains.</p> <p>Flare provides two versions of its block explorer to examine the network activities in the Flare ecosystem.</p> <ul> <li> <p>Flarescan block explorers: Provide full support for the C-chain, basic support for the P-chain, and analytics.</p> </li> <li> <p>Original Flare block explorers: Provide analytics plus full support for the C-chain, but they do not provide support for the P-chain.</p> </li> </ul> Network Flarescan Block Explorers Original Flare Block Explorers Flare Mainnet Flare Mainnet Explorer Original Flare Mainnet Explorer Songbird Songbird Canary Explorer Original Songbird Explorer Coston Coston Canary Explorer Original Coston Explorer Coston2 Coston2 Testnet Explorer Original Coston2 Explorer"},{"location":"user/block-explorers/#guides","title":"Guides","text":"<p>These guides refer to the original Flare block explorers.</p> <ul> <li>Finding the Reward Epoch</li> <li>Managing Delegations</li> <li>Managing Rewards</li> <li>Verifying the Vote-Power Block</li> <li>Viewing NFTs</li> <li>Viewing Token Balances</li> <li>Viewing Token Transfers</li> <li>Viewing Transactions</li> <li>Block Explorer Dashboard</li> </ul>"},{"location":"user/block-explorers/finding-reward-epoch/","title":"Finding the Reward Epoch","text":"<p>This page is for advanced users.</p> <p>Reward epochs are periods during which delegations rewards are accrued. Use the block explorer to find the current reward epoch, which you can use to find the epoch for which you can claim rewards and to determine the vote-power block for the next epoch.</p> <p>The following guide refers to the original Flare block explorers.</p> <ol> <li>Open a block explorer for the appropriate network.    The block explorer dashboard is displayed.</li> <li>From the block explorer, follow the Retrieval from Blockchain procedure to find and open the <code>FtsoManager</code> contract.    The Contract Address Details page is displayed.</li> <li> <p>Click the Read Contract tab, and locate the <code>getCurrentRewardEpoch</code> method.    The current reward epoch number is already displayed beside the function, as shown in the following example:</p> <p> Current Reward Epoch. </p> <p>In this example, the FTSO reward epoch is 80.</p> </li> </ol>"},{"location":"user/block-explorers/managing-delegations/","title":"Managing Delegations Using the Block Explorer","text":"<p>This page is for advanced users.</p> <p>When you make delegations to FTSO data providers, you increase their vote power, reinforce the stability of the FTSO ecosystem, and earn monetary rewards.</p> <p>Use the following information to manage your vote-power delegations with the the block explorer, which provides many options but is more complex. Alternatively, if you prefer a simpler interface, use the Flare Portal.</p>"},{"location":"user/block-explorers/managing-delegations/#prerequisites","title":"Prerequisites","text":"<p>Before you delegate your vote power, you must:</p> <ul> <li>Wrap your native tokens.   Wrapped tokens are required to delegate your vote power to data providers.</li> <li>Choose 1 or 2 data providers.   Multiple lists of data providers are available online, such as FlareMetrics.   As you browse the lists, consider the factors that affect the potential for rewards.</li> <li>Understand how the timing of delegations affects rewards, and consider the implications about the vote-power snapshot that will affect your rewards.</li> </ul> <p>The following guide refers to the original Flare block explorers.</p>"},{"location":"user/block-explorers/managing-delegations/#delegating-your-vote-power","title":"Delegating Your Vote Power","text":"<ol> <li>After you choose your data provider from the list of data providers, locate its address beneath its name, and copy it.</li> <li> <p>To verify the address of the data provider, open a block explorer, paste the address in the search field, and click the same address displayed as the result.</p> <p>On the Transactions tab, a list of recently submitted <code>SubmitHash</code> and <code>RevealPrices</code> transactions are displayed to confirm that the data provider is operating.</p> </li> <li> <p>Open a block explorer for the appropriate network.    The block explorer dashboard is displayed.</p> </li> <li>Follow the Retrieval from Blockchain procedure to find and open the <code>WNat</code> contract.    The Contract Address Details page is displayed.</li> <li> <p>Click the Write Contract tab, and then click Connect Wallet, as shown in the following image:</p> <p> Write Contract Tab and Connect Your Wallet. </p> </li> <li> <p>Complete the steps to connect your wallet.</p> </li> <li> <p>Locate the <code>delegate</code> method, and specify values for these parameters:</p> <ul> <li>_to(address): The address for the data provider you copied in Step 1.</li> <li>_bips(uin256): The percentage in basis points. For example, 10000 bips = 100%, and 5000 bips = 50%.</li> </ul> </li> <li> <p>Click Write to run the <code>delegate</code> method.</p> </li> <li>Follow the steps to complete the transaction in your wallet.    Delegation is complete.</li> </ol> <p>In the next reward epoch, your newly delegated tokens will be included in the calculation of your selected data provider's weight.    If the data provider submits useful data and garners any rewards, you will be able to claim your share of the rewards when the reward epoch is over.</p>"},{"location":"user/block-explorers/managing-delegations/#removing-delegations","title":"Removing Delegations","text":"<ol> <li>Open a block explorer for the appropriate network.    The block explorer dashboard is displayed.</li> <li>Follow the Retrieval from Blockchain procedure to find and open the <code>WNat</code> contract.    The Contract Address Details page is displayed.</li> <li> <p>Click the Write Contract tab, and then click Connect Wallet, as shown in the following image:</p> <p> Write Contract Tab and Connect Your Wallet. </p> </li> <li> <p>Complete the steps to connect your wallet.</p> </li> <li>Locate the <code>delegate</code> method, change the value of _bips(uin256) for the data provider's address to 0, and click Write to run the method.</li> <li>Follow the steps to complete the transaction in your wallet.</li> </ol>"},{"location":"user/block-explorers/managing-delegations/#redelegating-vote-power","title":"Redelegating Vote Power","text":"<ol> <li>Open a block explorer for the appropriate network.    The block explorer dashboard is displayed.</li> <li>Follow the Retrieval from Blockchain procedure to find and open the <code>WNat</code> contract.    The Contract Address Details page is displayed.</li> <li> <p>Click the Write Contract tab, and then click Connect Wallet, as shown in the following image:</p> <p> Write Contract Tab and Connect Your Wallet. </p> </li> <li> <p>Complete the steps to connect your wallet.</p> </li> <li>Locate the <code>undelegateAll</code> method, and click Write to run the method.</li> <li>Follow the steps to complete the transaction in your wallet.    All your delegations are removed.</li> <li>Delegate to the data providers you've chosen by following the previous set of steps to delegate.</li> </ol>"},{"location":"user/block-explorers/managing-delegations/#revoking-vote-power","title":"Revoking Vote Power","text":"<p>You can immediately revoke your vote power from a malicious data provider.</p> <ol> <li>Open a block explorer for the appropriate network.    The block explorer dashboard is displayed.</li> <li>Follow the Retrieval from Blockchain procedure to find and open the <code>WNat</code> contract.    The Contract Address Details page is displayed.</li> <li> <p>Click the Write Contract tab, and then click Connect Wallet, as shown in the following image:</p> <p> Write Contract Tab and Connect Your Wallet. </p> </li> <li> <p>Complete the steps to connect your wallet.</p> </li> <li> <p>Locate the <code>revokeDelegationAt</code> method, and specify values for the following parameters:</p> <ul> <li>_who(address): The address of the data provider from whom you will revoke your delegation.</li> <li>_blockNumber(uint256): The block number at which your delegation will be revoked.</li> </ul> </li> <li> <p>Click Write to run the method.</p> </li> <li>Follow the steps to complete the transaction in your wallet.    Your delegation is immediately revoked.</li> </ol>"},{"location":"user/block-explorers/managing-rewards/","title":"Managing Rewards Using the Block Explorer","text":"<p>This page is for advanced users.</p> <p>Rewards are accrued from your delegations to FTSO data providers whose submitted data is close to the calculated median value in a price epoch.</p> <p>Use the following information to check your reward balance and claim your rewards with the block explorer, which provides many options but is more complex. Alternatively, if you prefer a simple interface, use the Flare Portal.</p> <p>The following guide refers to the original Flare block explorers.</p>"},{"location":"user/block-explorers/managing-rewards/#checking-your-reward-balance","title":"Checking Your Reward Balance","text":"<ol> <li>Open a block explorer for the appropriate network.    The block explorer dashboard is displayed.</li> <li>Follow the Retrieval from Blockchain procedure to find and open the <code>FtsoRewardManager</code> contract.    The Contract Address Details page is displayed.</li> <li> <p>Click the Read Contract tab, and then click Connect Wallet, as shown in the following image:</p> <p> Read Contract Tab and Connect Your Wallet. </p> </li> <li> <p>Complete the steps to connect your wallet.</p> </li> <li> <p>Locate the <code>getStateOfRewards</code> method, and specify values for the following parameters:</p> <ul> <li>_beneficiary(address): The address to check for rewards.</li> <li>_rewardEpoch(uint256): The epoch in which you want to check the address for rewards. To check rewards for the epoch currently in progress, get the current reward epoch.</li> </ul> </li> <li> <p>Click Query to run the <code>getStateOfRewards</code> method.    The following information is returned:</p> <ul> <li>_dataProviders: List of providers to which the address delegated vote power during this epoch.</li> <li>_rewardAmounts: List of reward amounts from each delegation.</li> <li>_claimed: List of boolean values indicating whether each of the amounts has already been claimed.</li> <li>_claimable: Boolean value indicating whether rewards for the address are claimable. Rewards are claimable if they are not expired and the epoch has ended. The value of <code>_claimable</code> is independent of the value of <code>_claimed.</code></li> </ul> </li> </ol>"},{"location":"user/block-explorers/managing-rewards/#claiming-your-rewards","title":"Claiming Your Rewards","text":"<ol> <li>Open a block explorer for the appropriate network.    The block explorer dashboard is displayed.</li> <li>Follow the Retrieval from Blockchain procedure to find and open the <code>FtsoRewardManager</code> contract.    The Contract Address Details page is displayed.</li> <li> <p>Click the Read Contract tab, and then click Connect Wallet, as shown in the following image:</p> <p> Read Contract Tab and Connect Your Wallet. </p> </li> <li> <p>Complete the steps to connect your wallet.    In the next steps, you will check this wallet for accrued rewards.    You can disconnect this wallet and connect a different wallet as frequently as necessary.</p> </li> <li>Run the <code>getEpochsWithUnclaimedRewards(beneficiary_address)</code> method by clicking Query.    A list of previous epochs with pending rewards to be claimed is returned.</li> <li> <p>On the Write Contract tab, locate the <code>claimReward</code> method, and specify values for the following parameters:</p> <ul> <li>_recipient(address): The address to which you want claimed rewards to be sent. It can be the address you used to connect your wallet to the block explorer or a different address.</li> <li>_rewardEpochs(uint256[]): One or more epoch numbers retrieved in Step 5. Specify multiple epoch numbers in a comma-separated list enclosed by square brackets, such as <code>[59,60]</code>.</li> </ul> </li> <li> <p>Click Write to run the <code>claimReward</code> method. One of the following results occurs:</p> <ul> <li>The <code>claimReward</code> method prompts you to confirm the transaction.   Go to Step 8.</li> <li>The <code>claimReward</code> method fails. For security reasons, the <code>FtsoRewardManager</code> contract       contains a limited amount of tokens and is replenished periodically. Sometimes, all delegators claim their rewards in a short period of time immediately after the reward epoch ends, and the contract becomes empty. If you are unable to claim your rewards because the contract is empty, try again the next day.</li> </ul> </li> <li> <p>Follow the steps to confirm the transaction in your wallet.    Your rewards are claimed, and your updated balance of native tokens is displayed.</p> </li> </ol>"},{"location":"user/block-explorers/user-interface/","title":"Block Explorer Dashboard","text":"<p>Each block explorer provides this dashboard, which includes:</p> <p></p> Block Explorer Dashboard. <ul> <li>Navigation Bar</li> <li>Metrics</li> <li>Blocks</li> <li>Transactions</li> </ul> <p>This dashboard represents the dashboard of the original Flare block explorers.</p>"},{"location":"user/block-explorers/user-interface/#navigation-bar","title":"Navigation Bar","text":"<p>Use the options in the navigation bar to explore the blockchain and toggle light and dark modes.</p> <ul> <li>Blocks: View recently created blocks and their constituent transactions.</li> <li>Transactions: View validated or pending transactions.</li> <li>Tokens: View a list of all the tokens on the blockchain or the addresses of wallets that hold a specific token.</li> <li>APIs: For web3 developers to retrieve blockchain data.</li> <li>Network: View the explorers for other networks in the Flare ecosystem.</li> <li>Display theme: Toggle between light and dark mode.</li> <li>Search: Search the blockchain by address, token symbol, token name, transaction hash, or block number.</li> </ul>"},{"location":"user/block-explorers/user-interface/#metrics","title":"Metrics","text":"<p>The metrics section displays the following information:</p> <ul> <li>Gas tracker: The average amount of gas required to process a transaction on a Flare network. Gas is denominated in units of gwei, where 1,000,000,000 gwei equals one token on a Flare network.</li> <li>Average block time: The average time required to confirm a block.</li> <li>Total transactions: The total amount of verified transactions.</li> <li>Total blocks: The total amount of confirmed blocks.</li> <li>Wallet addresses: The total amount of wallets created on the network.</li> </ul>"},{"location":"user/block-explorers/user-interface/#blocks","title":"Blocks","text":"<p>A block is a group of transactions submitted, validated, and recorded on the blockchain. Each block has a sequential ID and a number of transactions aggregated in the block. To view details about a block and the transactions it contains, click the block ID. Alternatively, view a continuous list of confirmed blocks as they occur by clicking View All Blocks.</p> <p></p> Blocks."},{"location":"user/block-explorers/user-interface/#transactions","title":"Transactions","text":"<p>Transactions are the various actions you can take on a blockchain. They are categorized by the following types:</p> <ul> <li>Standard: Transfers of tokens between two wallets.</li> <li>Contract: Interactions between two smart contracts or a wallet and a smart contract.   Contract transactions include delegating tokens, transferring tokens, wrapping and unwrapping tokens, and so on.   Interactions between two smart contracts are internal transactions.</li> </ul> <p></p> Transaction Types."},{"location":"user/block-explorers/verifying-vote-power-block/","title":"Verifying the Vote-Power Block","text":"<p>This page is for advanced users.</p> <p>Use the block explorer to verify the vote-power block snapshot for a specific epoch. The snapshot indicates when your delegations are enacted.</p> <p>The following guide refers to the original Flare block explorers.</p> <ol> <li>Open a block explorer for the appropriate network.    The block explorer dashboard is displayed.</li> <li>From the block explorer, follow the Retrieval from Blockchain procedure to find and open the <code>FtsoManager</code> contract.    The Contract Address Details page is displayed.</li> <li>Click the Read Contract tab.</li> <li>On the Read Contract tab, locate the <code>getRewardEpochVotePowerBlock</code> method, and specify the epoch number.</li> <li>Click Query to run the <code>getRewardEpochVotePowerBlock</code> method.    The block number that was used to determine the vote power for the next epoch is returned.</li> <li> <p>Copy this block number, paste it into the Search field, and press Enter.    The Block Details page is displayed.    The timestamp is displayed, as shown in the following image:</p> <p> Vote-Power Block Snapshot. </p> <p>The displayed timestamp is the exact date and UTC time when vote power was locked during the epoch you specified.</p> </li> </ol>"},{"location":"user/block-explorers/viewing-nfts/","title":"Viewing NFTs","text":"<p>This page is for advanced users.</p> <p>Use the block explorer to view NFTs. Before you begin, ensure the status of the transaction to mint the NFT is Confirmed.</p> <p>The following guide refers to the original Flare block explorers.</p> <ol> <li>Retrieve the transaction hash for the NFT.</li> <li>Open a block explorer for the appropriate network.    The block explorer dashboard is displayed.</li> <li>Specify the NFT transaction hash from Step 1 in the Search field, and click the result.    The Transaction Details page is displayed.</li> <li>Locate the Tokens Minted section.    The value of the For parameter is the numerical ID for the NFT.</li> <li>Click the ID. The NFT collection page is displayed.    In most cases, your NFT is displayed in the upper-right hand side of the page.    However, if the NFT creator used public IPFS gateways or did not create the NFT according to the ERC-721 or ERC-1155 standards, the NFT might not display.</li> </ol>"},{"location":"user/block-explorers/viewing-token-balances/","title":"Viewing Token Balances","text":"<p>This page is for advanced users.</p> <p>Use the block explorer to view the list of token balances at an address.</p> <p>The following guide refers to the original Flare block explorers.</p> <ol> <li>Retrieve the address whose tokens you want to view.</li> <li>Open the block explorer for the appropriate network. The block explorer dashboard is displayed.</li> <li>Insert the address from Step 1 into the Search field. If the address exists, it is highlighted in the results list.</li> <li>Click the highlighted address. The Address Details page is displayed.</li> <li> <p>Click the Tokens tab, as shown in the following image:</p> <p> Tokens. </p> </li> </ol> <p>The address's <code>$FLR</code> balance and a list of the non-native tokens it contains are displayed. The list can include ERC-20, ERC-721, and ERC-1155 tokens.</p>"},{"location":"user/block-explorers/viewing-token-balances/#balance-history","title":"Balance History","text":"<p>Use the block explorer to view a historical chart of the native-token balance at the address.</p> <ol> <li>Retrieve the address whose tokens you want to view.</li> <li>Open the block explorer for the network appropriate network.    The block explorer dashboard is displayed.</li> <li>Insert the address from Step 1 into the Search field.    If the address exists, it is highlighted in the results list.</li> <li>Click the highlighted address. The Address Details page is displayed.</li> <li> <p>Click the Coin Balance History tab, as shown in the following image:</p> <p> Coin Balance History. </p> <p>A chart that shows the history of the native token at the address and a list of associated blocks is displayed, as shown in the following image:</p> <p> Coin Balance Chart. </p> </li> </ol>"},{"location":"user/block-explorers/viewing-token-transfers/","title":"Viewing Token Transfers","text":"<p>This page is for advanced users.</p> <p>The following guide refers to the original Flare block explorers.</p> <p>Use the block explorer to view token transfers to and from an address.</p> <ol> <li>Retrieve the address whose token transfers you want to view.</li> <li>Open the block explorer for the appropriate network.    The block explorer dashboard is displayed.</li> <li>Insert the address from Step 1 into the Search field.    If the address exists, it is highlighted in the results list.</li> <li>Click the highlighted address. The Address Details page is displayed.</li> <li> <p>Click the Token Transfers tab, as shown in the following image:</p> <p> Token Transfers. </p> <p>The Token Transfers list is displayed.</p> </li> <li> <p>Click the transaction hash for the token transfer you want to view.    The following details about the transfer are displayed:</p> <ul> <li>Transaction Hash: A unique identifier that proves a transaction is verified and added to the blockchain.</li> <li>Result: The state of the transaction. The state is either Success, Pending, or Failed.</li> <li>Status: The status of the transaction. The status is either Confirmed or Unconfirmed.</li> <li>Block: The number of the block that contains the transaction.</li> <li>Timestamp: The date and time when the transaction was added to the blockchain and the amount of time required to confirm it.</li> <li>From: The address of the transaction sender.</li> <li>Interacted With (To): The address of the contract that handles the transaction.</li> <li>Tokens Transferred<ul> <li>From: The address that initiated the transaction with the contract.</li> <li>To: The address of the recipient of the token in the transaction.</li> <li>For: The symbol of the token and its quantity in the transaction.</li> </ul> </li> <li>Value: The quantity of tokens sent.</li> <li>Transaction Fee: The total cost of the transaction.</li> <li>Gas Price: The price per unit of gas specified by the sender. Units are measured in gwei.</li> <li>Transaction Type:</li> <li>Gas Limit: The maximum amount of gas approved for the transaction.</li> <li>Max Fee Per Gas: The maximum total amount per unit of gas the sender would pay, including the base fee and priority fee.</li> <li>Max Priority Fee per Gas: The maximum fee per unit of gas specified by the sender to pay a validator to prioritize the transaction. This fee is also called a tip.</li> <li>Priority Fee/Tip: The priority fee specified by the sender to pay a validator to prioritize the transaction.</li> <li>Transaction Burnt Fee: The amount of <code>$FLR</code> burned for the transaction.</li> <li>Gas Used by Transaction: The actual amount of gas used by the transaction.</li> <li>Nonce Position: The transaction number from the sender's address. Each transaction made by an address increases the nonce by one.</li> <li>Raw Input: The hashed input of a transaction. This input accompanies the transaction to process it.</li> <li>Input: The relevant functions that were called and parameters used in the transaction.</li> </ul> </li> </ol>"},{"location":"user/block-explorers/viewing-transactions/","title":"Viewing Transactions","text":"<p>This page is for advanced users.</p> <p>Use the block explorer to view transaction details that explain where the transactions exist on the blockchain, when they were processed, how much gas they consumed, and more.</p> <p>The following guide refers to the original Flare block explorers.</p> <ol> <li>Retrieve the address whose transactions you want to view.</li> <li>Open the block explorer for the appropriate network.    The block explorer dashboard is displayed.</li> <li>Insert the address from Step 1 into the Search field.    If the address exists, it is highlighted in the results list.</li> <li> <p>Click the highlighted address.    The Address Details page is displayed, as shown in the following image. The preselected Transactions tab lists the transactions associated with the address.</p> <p> Transactions. </p> </li> <li> <p>Click the transaction hash, as shown in the following image, which highlights in sequence a standard transaction and a contract transaction.    The listed transactions were made by the address you specified. Details about a transaction are displayed when you click a transaction hash.</p> <p> Transaction Hash. </p> <p>The Transaction Details page is displayed, as shown in the following image:</p> <p> Transaction Details. </p> </li> </ol>"},{"location":"user/block-explorers/viewing-transactions/#transaction-details","title":"Transaction Details","text":"<p>The following transaction information is provided:</p> <ul> <li>Transaction Hash: A unique identifier that proves a transaction is verified and added to the blockchain.</li> <li>Result: The state of the transaction.   The state is either Success, Pending, or Failed.</li> <li>Status: The status of the transaction.   The status is either Confirmed or Unconfirmed.</li> <li>Block: The number of the block that contains the transaction.</li> <li>Timestamp: The date and time when the transaction was added to the blockchain and the amount of time required to confirm it.</li> <li>From: The address of the transaction sender.</li> <li>To: The address of the transaction recipient.</li> <li>Value: The quantity of tokens sent.</li> <li>Transaction Fee: The total cost of the transaction.</li> <li>Gas Price: The price per unit of gas specified by the sender.   Units are measured in gwei.</li> <li>Transaction Type:</li> <li>Gas Limit: The maximum amount of gas approved for the transaction.</li> <li>Max Fee Per Gas: The maximum total amount per unit of gas the sender would pay, including the base fee and priority fee.</li> <li>Max Priority Fee per Gas: The maximum fee per unit of gas specified by the sender to pay a validator to prioritize the transaction.   This fee is also called a tip.</li> <li>Priority Fee/Tip: The priority fee specified by the sender to pay a validator to prioritize the transaction.</li> <li>Transaction Burnt Fee: The amount of <code>$FLR</code> burned for the transaction.</li> <li>Gas Used by Transaction: The actual amount of gas used by the transaction.</li> <li>Nonce Position: The transaction number from the sender's address.   Each transaction made by an address increases the nonce by one.</li> </ul> <p>The following elements are specific to contract transactions:</p> <ul> <li>Interacted With (To): The address of the contract that handles the transaction.</li> <li>Tokens Minted<ul> <li>From: The address that initiated the transaction with the contract.</li> <li>To: The address of the recipient of the token in the transaction.</li> <li>For: The symbol of the token and its quantity in the transaction.</li> </ul> </li> <li>Raw Input: The hashed input of a transaction. This input accompanies the transaction to process it.</li> </ul>"},{"location":"user/block-explorers/viewing-transactions/#input","title":"Input","text":"<p>The Input section shows the methods that were called and the parameters used in the transaction.</p>"},{"location":"user/block-explorers/viewing-transactions/#internal-transactions","title":"Internal Transactions","text":"<p>Internal transactions occur between multiple smart contracts. In some cases, tokens are transferred to a smart contract during an internal transaction.</p> <ol> <li> <p>Locate the Internal Transactions tab, as shown in the following image:</p> <p> Internal Transactions. </p> </li> <li> <p>Click the transaction hash, as shown in the following image:</p> <p> Transaction Hash. </p> <p>The transaction details are displayed.</p> </li> </ol>"},{"location":"user/block-explorers/viewing-transactions/#logs","title":"Logs","text":"<p>Transaction logs show events that were trigged by smart contracts during a transaction and information related to those events.</p> <p>Click the Logs tab, as shown in the following image:</p> <p></p> Logs. <p>The logs are displayed.</p>"},{"location":"user/block-explorers/viewing-transactions/#raw-trace","title":"Raw Trace","text":"<p>The raw trace shows all parameters and data related to a transaction. If errors occurred during the transaction, this information can be used to debug them.</p> <p>Click the Raw Trace tab, as shown in the following image:</p> <p></p> Raw Trace. <p>The raw trace is displayed in JSON format.</p>"},{"location":"user/delegation/","title":"FTSO Delegation","text":"<p>Select one of the topics below:</p> <ul> <li>Managing Delegations</li> <li>Managing Rewards</li> </ul>"},{"location":"user/delegation/managing-delegations/","title":"Managing Delegations Using the Flare Portal","text":"<p>When you make delegations to data providers, you increase their vote power, reinforce the stability of the FTSO ecosystem, and earn monetary rewards.</p> <p>This information explains how to manage your delegations using the Flare Portal. Alternatively, if you have used block explorers for other networks and are competent interacting with smart contracts without a user interface, you can use the block explorer, which provides more options but can be more complex. Using it is intended for advanced users.</p>"},{"location":"user/delegation/managing-delegations/#prerequisites","title":"Prerequisites","text":"<p>Before you delegate your vote power, you must:</p> <ul> <li>Wrap your native tokens. Wrapped tokens are required to delegate your vote power to data providers.</li> <li>Choose 1 or 2 data providers. Multiple lists of data providers are available online, such as FlareMetrics. As you browse the lists, consider the factors that affect the potential for rewards.</li> <li>Understand how the timing of delegations affects rewards, and consider the following implications about the vote-power snapshot that will affect your rewards.</li> </ul>"},{"location":"user/delegation/managing-delegations/#delegating-your-vote-power","title":"Delegating Your Vote Power","text":"<ol> <li> <p>Open the Flare Portal. The home page is displayed.</p> <p> Flare Portal home. </p> </li> <li> <p>Click Connect to Wallet and log into your wallet. The interface to your Main Account opens.</p> </li> <li> <p>Ensure you are connected to the network you want. In the following image, the wallet is connected to the Flare network.</p> <p> Main Account on the Flare network. </p> </li> <li> <p>On the Main Account tab, locate the FTSO provider delegations field, and click Delegate. The Delegate FTSO providers window is displayed.</p> </li> <li> <p>Click the Main provider dropdown menu, click the data provider you want, and drag the slider to select the percentage of your vote power you want to delegate to the data provider.</p> <p> Delegate FTSO providers window. </p> </li> <li> <p>Optional: If you want to delegate to a second data provider, locate the Second (optional) provider field, and repeat step 3.</p> </li> <li>Click Submit.</li> <li>Follow the steps to confirm the transaction in your wallet.</li> </ol>"},{"location":"user/delegation/managing-delegations/#removing-delegations","title":"Removing Delegations","text":"<ol> <li>Open the Flare Portal, connect your wallet, and ensure you are connected to the network you want.</li> <li>On the Main Account tab, locate the FTSO provider delegations field, and click Delegate. The Delegate FTSO providers window is displayed.</li> <li>Drag the slider to 0% for one or both of the data providers, and click Submit.</li> <li>Follow the steps to confirm the transaction in your wallet.</li> </ol>"},{"location":"user/delegation/managing-rewards/","title":"Managing Rewards Using the Flare Portal","text":"<p>Rewards are accrued from your delegations to FTSO data providers whose submitted data is close to the calculated median value in a price epoch.</p> <p>Use this information to claim FTSO delegation rewards by using the Flare Portal. Alternatively, if you have used block explorers for other networks and are competent interacting with smart contracts without a user interface, you can use the block explorer, which provides more options but can be more complex. Using it is intended for advanced users.</p> <ol> <li> <p>Open the Flare Portal. The home page is displayed.</p> <p> Flare Portal home. </p> </li> <li> <p>Click Connect to Wallet and log into your wallet. The interface to your Main Account opens.</p> </li> <li> <p>Ensure you are connected to the network you want. In the following image, the wallet is connected to the Flare network.</p> <p> Main Account on the Flare network. </p> </li> <li> <p>On the Main Account tab, locate the Claim your delegation rewards section to determine whether you have claimable rewards and whether those rewards can currently be claimed:</p> <ul> <li>If you have rewards to claim and the reward manager contains enough tokens, the Claim button is enabled and shows the amount of rewards you can claim. Go to Step 5.</li> <li> <p>If you have rewards to claim, but the reward manager currently does not contain enough tokens, the Claim button shows the amount of rewards you can claim but is disabled.</p> <p>For security reasons, a limited amount of tokens is stored at a given time in the reward manager contract. Sometimes, all delegators claim their rewards in a short period of time immediately after the reward epoch ends, and the token storage is depleted. The storage is replenished periodically. If you are currently unable to claim your rewards because the storage is empty, try again the next day.</p> </li> <li> <p>If you don't have claimable rewards, the Claim button shows 0 and is disabled.</p> </li> </ul> <p>The following image shows an account with claimable rewards:</p> <p> An account with claimable rewards. </p> </li> <li> <p>Click the Claim button. The Claim your delegation rewards window is displayed.</p> <p> Claim your delegation rewards. </p> </li> <li> <p>Optional: If you have enabled your personal delegation account, the option to send your rewards to the PDA is preselected by default.     To send your rewards to the address that you connected to the Portal instead, deselect the option.</p> </li> <li>Click Claim All Rewards to claim all available rewards for the listed epochs.</li> <li>Follow the steps to confirm the transaction in your wallet. Your rewards are claimed, and your updated balance of native tokens is displayed.</li> </ol>"},{"location":"user/governance/","title":"Governance","text":"<p>This section contains information about participating in governance on the Flare and Songbird networks.</p> <ul> <li>Voting</li> </ul>"},{"location":"user/governance/voting/","title":"Voting","text":"<p>An integral part of the governance process, voting is the way you influence decisions about how Flare and Songbird operate.</p> <p>This process can be performed directly through Flare's smart contracts, but the Flare Foundation has developed the Flare Portal to enable you to conveniently cast your vote.</p> <p>The following information is about voting on the Flare and Songbird networks. Ensure you have selected one of these networks in your wallet.</p>"},{"location":"user/governance/voting/#governance-process-summary","title":"Governance Process Summary","text":"<p>This section summarizes the voting process, which is explained in more detail in the Governance page.</p> <p>All changes to the Flare and Songbird networks are determined by the outcomes of votes on Flare Improvement Proposals and Songbird Testing Proposals.</p> <p>For now, all proposals are published by the Flare Foundation.</p> <p>On each network, each account can cast a number of votes equal to the amount of wrapped tokens it holds. Since this amount varies over time, a snapshot of all accounts is taken at a block randomly chosen before voting starts. This block is called the vote count block.</p> <p>Before snapshots are taken, a notice period occurs. If you need to wrap tokens before a voting, wrap them during this notice period so that they are always included in the snapshot.</p> <p>Tip</p> <p>It is worth noting that you can use the same wrapped tokens to simultaneously vote on proposals and delegate to FTSO data providers.</p>"},{"location":"user/governance/voting/#requirements","title":"Requirements","text":"<p>To vote on any proposal, you need an account that contains wrapped tokens. You can wrap your tokens by using the Flare Portal, as shown in the Getting Wrapped Tokens section below.</p> <p>Warning</p> <p>Only wrapped tokens held at the vote count block are considered towards your vote count. Tokens wrapped or received afterwards will not result in additional votes.</p> <p>If you need to wrap tokens, always do so during the notice period.</p>"},{"location":"user/governance/voting/#guide","title":"Guide","text":""},{"location":"user/governance/voting/#1-connecting-to-the-portal","title":"1. Connecting to the Portal","text":"<p>Copy the Flare Portal URL, since you will need it later:</p> <pre><code>https://portal.flare.network\n</code></pre> <p>The first step to use the portal is to connect your wallet to it, and the procedure is different for each wallet:</p>"},{"location":"user/governance/voting/#bifrost-wallet","title":"Bifrost Wallet","text":"<ol> <li>Open Bifrost Wallet, log in, and click the web browser tab indicated by the four gray squares at the bottom of the screen.</li> <li>Paste the Flare Portal URL in the search field at the top of the window, and click Search.</li> <li>Click Connect to Wallet.</li> <li>Select Bifrost Wallet.</li> <li>Ensure either the Flare or Songbird network is selected in the pop-up window, and click Connect.</li> </ol> <p>Your wallet is now connected to the portal.</p>"},{"location":"user/governance/voting/#metamask-mobile","title":"MetaMask Mobile","text":"<ol> <li>Open MetaMask, and log in.</li> <li>Click the three-lines menu, and click Browser.</li> <li>Paste the Flare Portal URL in the search field at the top of the window, and click Go.</li> <li>Click Connect to Wallet, and click MetaMask.</li> </ol> <p>Your wallet is now connected to the portal.</p>"},{"location":"user/governance/voting/#ledger-nano-sx-and-chrome","title":"Ledger Nano S/X and Chrome","text":"<ol> <li>Connect to your Ledger device, and unlock it.</li> <li>Log into the MetaMask Chrome extension, and sync your Ledger device.</li> <li>Paste the Flare Portal URL in the search field at the top of the Chrome window, and click Enter.</li> <li>Click Connect to Wallet.</li> <li>Click MetaMask.</li> </ol> <p>Your wallet is now connected to the portal.</p>"},{"location":"user/governance/voting/#metamask-or-brave-wallet","title":"MetaMask or Brave Wallet","text":"<ol> <li>Copy and paste the Flare Portal URL in the search bar at the top of your browser and press Enter.</li> <li>Click Connect to Wallet.</li> <li>Select MetaMask.</li> <li>Ensure the correct account address is selected and press Confirm.</li> </ol> <p>Your wallet is now connected to the portal.</p>"},{"location":"user/governance/voting/#2-getting-wrapped-tokens","title":"2. Getting Wrapped Tokens","text":"<p>Wrapped tokens are required to vote.</p> <p>To wrap your tokens:</p> <ol> <li>On the Account tab in the Flare Portal, ensure you are connected to the network on which the proposal will be voted.</li> <li>Locate your token balance, and click Wrap.</li> <li> <p>Specify the amount you want to wrap, and click Wrap.</p> <p>Never wrap all your tokens</p> <p>Always leave some unwrapped tokens to pay for transaction fees.</p> </li> <li> <p>Confirm the transaction in your wallet.</p> </li> </ol> <p>Remember to wrap your tokens before voting starts, as explained in the Governance Process Summary section above.</p>"},{"location":"user/governance/voting/#3-casting-your-vote","title":"3. Casting Your Vote","text":"<p>Tip</p> <p>Wrapped tokens are required to vote. Depending on the network, ensure you have either <code>$FLR</code> or <code>$SGB</code> in the wallet you will use to vote. For more information, see Getting Wrapped Tokens.</p> <ol> <li>In the Flare Portal, select the Voting tab.    The Governance Proposals page is displayed.</li> <li>Locate your current number of votes in the black box.    If you have fewer votes than you expected, consider the warning in the Requirements section above.</li> <li>In the List of proposals, locate the proposal you want to vote on, and click on it.    The selected proposal is displayed.</li> <li>Review the information in the Proposal info and Voting details sections.</li> <li> <p>Cast your vote.    All your available votes will be assigned to the option you specify:</p> <ul> <li>To vote in favor of the proposal, click Vote For.</li> <li>To vote for the proposal to be rejected, click Vote Against.</li> </ul> </li> <li> <p>After you sign the transaction, your vote is final and cannot be changed.    To sign the transaction and lock your vote, click Confirm.</p> </li> </ol> <p>Your contribution to this proposal is now complete.</p>"},{"location":"user/governance/voting/#transferring-votes","title":"Transferring Votes","text":"<p>Votes can be transferred to another account while the wrapped tokens remain in your possession. This is useful, for example, if you have wrapped tokens in multiple self-custody wallets, since you can simplify your voting process by transferring all the votes to a single wallet.</p> <p>You can read all the details about transferring votes in the Governance page.</p> <p>By completing the following process, you are crediting another account with votes only; the tokens themselves stay in the original wallet.</p> <ol> <li>Copy the Flare or Songbird address you want to transfer votes to.</li> <li>On the Voting tab in the Flare Portal, locate your amount of current votes in the black box, and click Transfer votes.    The Information about transferred votes window is displayed.</li> <li>Read the disclaimer, and click Transfer votes.    The Transfer votes window is displayed.</li> <li>In the Transfer all my votes to field, paste the address from Step 1, and click Confirm.</li> <li>Click Confirm on your wallet to sign the transaction.    Your votes are credited to the address you specified.    The tokens themselves stay in the original address.</li> </ol> <p>Canceling vote transfers</p> <p>You can stop transferring your votes to another address, if you do so before the snapshot is taken.</p> <p>You can do so from the Transfer votes window using the Remove delegation button. This button is only available when you have previously transferred votes.</p>"},{"location":"user/staking/","title":"Staking on Validators","text":"<p>This section contains information about staking Flare assets on validators and receiving rewards earned from your stake.</p> <ul> <li>Using FlareStake to Stake</li> <li>Using the Command Line to Stake</li> </ul>"},{"location":"user/staking/#lists-of-validators","title":"Lists of Validators","text":"<p>Use any of the following tools to obtain the latest list of validators and their stats:</p> <ul> <li>FlareMetrics</li> <li>Flarescan</li> <li>flare.builders</li> <li>SolidiFi</li> </ul>"},{"location":"user/staking/#limits","title":"Limits","text":"<p>The amount that you can stake and the rewards you can gain by staking are restricted by these limits:</p> <ul> <li> <p>Delegation factor: Limits the total amount that can be staked to a validator to its self-bond, which is the amount validators stake to their own nodes, times the delegation factor, which is 15. For example, if a validator has a self-bond stake of 1M <code>$FLR</code>, the total sum of all stakes, including delegations, cannot exceed 15M <code>$FLR</code>. This limit allows for 14M <code>$FLR</code> of delegations.</p> <p>To determine whether a validator has space for more delegations, open the FlareMetrics list of validators, hover over the progress bar in the Total Stake column, and look at the Free Space amount.</p> </li> <li> <p>Staking cap: Limits the reward performance of individual validators to 5% of the total staked amount. If you stake your funds on a validator with more than 5% of the total staked amount, you receive less <code>$FLR</code> in reward. To maximize your reward, delegate your staking funds to a validator with less than 5% of the total staked amount of <code>$FLR</code>.</p> <p>To determine whether a validator exceeds the staking cap, open the FlareMetrics list of validators and look for an exclamation mark beside the amount of <code>$FLR</code> staked in the Total Stake column and hover over it.</p> </li> </ul>"},{"location":"user/staking/staking-cli/","title":"Using the Command Line to Stake","text":"<p>Flare has a command-line interface (CLI) tool called FlareStake CLI, which allows performing stake operations on validator nodes from a terminal.</p> <p>A staking app with a graphical user interface (GUI) is also available to simplify the staking process. See the Using FlareStake to Stake guide to learn about it. Still, a CLI tool has other advantages, like allowing it to be part of automated processes.</p> <p>Table of Contents</p> <ul> <li>Staking Overview: What you need to know about staking.</li> <li>Installing the Flare Stake CLI: Install required tools.</li> <li>Staking Guide: How to perform staking.</li> <li>Claiming Guide: How to claim staking rewards.</li> <li>Troubleshooting: Addressing common issues.</li> </ul>"},{"location":"user/staking/staking-cli/#staking-overview","title":"Staking Overview","text":"<p>If you already know how staking on validators works on the Flare network, skip this section.</p> <p>Note</p> <p>Proof of stake is being implemented on Flare in phases. Ensure that you have read the Validators page to learn about them.</p> <p>Staking works by locking funds for a period of time to support a specific network validator. When validator owners stake to their own nodes they self-bond, whereas all other participants are said to delegate their stake to that validator.</p> <p>Participants choose how much to stake and for how long their stake will be locked. The minimum values are:</p> Self-bond Delegation Minimum amount 1M <code>$FLR</code> 50K <code>$FLR</code> Minimum duration 60 days 14 days <p>At the end of every reward epoch, participants are rewarded according to how well their chosen validator performed in that period.</p> <p>Staking amounts and rewards are limited</p> <p>When you choose your validator and amount to stake, consider the delegation factor and the staking cap.</p> <p>The deployment phases summary shows other rewards that staked funds can still earn while they are locked.</p> <p>Given that the Flare network uses two independent underlying chains, there is one extra step that must be considered. Funds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens. After the staking period expires and funds are unlocked, they can be transferred back to the C-chain.</p> <p>This guide explains how to perform the above operations using the Flare Stake CLI tool.</p>"},{"location":"user/staking/staking-cli/#installing-the-flare-stake-cli","title":"Installing the Flare Stake CLI","text":"<p>This tool is open source, so it can be installed from its source code. However, it is more convenient to use the prepackaged npm version.</p> <p>The Flare Stake CLI works on Windows, Mac, and Linux.</p> <p>Note</p> <p>It is not recommended to run this tool using the Windows Subsystem for Linux (WSL), as it might have issues accessing hardware wallets through USB ports. On Windows, use the standard Windows command prompt or terminal instead.</p>"},{"location":"user/staking/staking-cli/#prerequisites","title":"Prerequisites","text":"<p>Install the npm package manager. This guide has been tested with Node.js v18.16.0 and npm v9.5.1.</p>"},{"location":"user/staking/staking-cli/#installation","title":"Installation","text":"<p>After npm is available, type this command into a terminal to make the tool available from any folder:</p> <pre><code>npm install @flarenetwork/flare-stake-tool -g\n</code></pre> <p>Check that the tool has been correctly installed by running:</p> <pre><code>flare-stake-tool\n</code></pre> <p>The tool's banner is displayed:</p> <pre><code>  _____ _                  ____  _        _           ____ _     ___\n |  ___| | __ _ _ __ ___  / ___|| |_ __ _| | _____   / ___| |   |_ _|\n | |_  | |/ _` | '__/ _ \\ \\___ \\| __/ _` | |/ / _ \\ | |   | |    | |\n |  _| | | (_| | | |  __/  ___) | || (_| |   &lt;  __/ | |___| |___ | |\n |_|   |_|\\__,_|_|  \\___| |____/ \\__\\__,_|_|\\_\\___|  \\____|_____|___|\n\nVersion: 3.0.2\n</code></pre> <p>Make sure at least version 3.0.0 has been installed.</p>"},{"location":"user/staking/staking-cli/#configuration","title":"Configuration","text":"<p>You can specify the account from which staking will take place in different ways.</p> <p>Choose one of the following two options.</p> <p>Note that using a Ledger hardware wallet is the only recommended way.</p> Ledger Configuration <p>Your device must be configured before it can be used:</p> <ol> <li> <p>Install the Avalanche application:</p> <ol> <li>Connect the device to your computer and unlock it using your PIN code.</li> <li>Open the Ledger Live application.     Go to the My Ledger tab and make sure the device is using the latest firmware.</li> <li> <p>In the App catalog tab, search for \"Avalanche\" and click on the Install button.</p> <p>Note that this app requires all available space on a Ledger Nano S device (138 KB). You might need to remove other apps first to free up space.</p> </li> </ol> </li> <li> <p>Select your desired account:</p> <ol> <li>Exit the Ledger Live application and make sure the device is not connected to any other application like MetaMask.</li> <li>Open the Avalanche app on the Ledger. The screen should show \"Avalanche Ready\".</li> <li> <p>From a terminal, enter:</p> <pre><code>flare-stake-tool interactive\n</code></pre> <p>This command starts the staking tool in interactive mode. In this mode the tool asks questions until it has enough information to execute a command.</p> </li> <li> <p>Then, after the welcome banner:</p> <pre><code>? How do you want to connect your wallet? (Use arrow keys)\n&gt; Ledger\n  Public Key\n  Private Key (not recommended)\n</code></pre> <p>Select Ledger with the cursor keys and press Enter.</p> </li> <li> <p>The next question is:</p> <pre><code>? Which network do you want to connect to? (Use arrow keys)\n&gt; Flare (Mainnet)\n  Coston2 (Testnet)\n  LocalHost (for development only)\n</code></pre> <p>Select Flare (Mainnet) and press Enter.</p> <p>This message shows for a few seconds:</p> <pre><code>Fetching Addresses...\n</code></pre> </li> <li> <p>Eventually a list of addresses is shown.     These are the addresses that can be used from this device.</p> <p>Choose the one you want to stake from and press Enter.</p> <p>Keep in mind that this address needs to have a positive <code>$FLR</code> balance to pay for transaction fees and be able to stake. You can transfer funds to it later on.</p> </li> <li> <p>Finally the main menu appears:</p> <pre><code>? What do you want to do? (Use arrow keys)\n  View chain addresses\n&gt; Check on-chain balance\n  Get network info\n  Get validator info\n  Move assets from C-chain to P-chain\n  Move assets from P-chain to C-chain\n  Add a validator node\n</code></pre> <p>As an example, choose Check on-chain balance and press Enter.</p> <p>The balance of your selected account is shown for both the C-chain and the P-chain and the tool exits.</p> </li> </ol> <p>At this point, a <code>ctx.json</code> file has been created in the current folder containing the selected account. When you run the tool from the same folder again, you will be given the option to use the same account. Using the same account saves you the inconvenience of repeating the above steps every time.</p> </li> </ol> Private Key Configuration <p>If you have a Ledger device and you have already configured it, skip this step.</p> <p>If you do not have access to a Ledger device, you can still provide your account's private key in a plain text file, but this method is significantly less secure.</p> <ol> <li>Create a text file in a secure folder, i.e., one that is visible only to you.     Give it any name you want.</li> <li> <p>Inside, add one of the following two lines, depending on the format of your private key:</p> <pre><code>PRIVATE_KEY_CB58=\"\"\nPRIVATE_KEY_HEX=\"\"\n</code></pre> <p>If your key is in CB58 format, use the <code>CB58</code> line. If your key is 64 hexadecimal characters, use the <code>HEX</code> line. Put the key inside the quotes.</p> </li> <li> <p>Enter this command on a terminal to check that the key works correctly:</p> <pre><code>flare-stake-tool interactive\n</code></pre> <p>This command starts the staking tool in interactive mode. In this mode the tool asks questions until it has enough information to execute a command.</p> </li> <li> <p>After the welcome banner you see:</p> <pre><code>? How do you want to connect your wallet? (Use arrow keys)\n  Ledger\n  Public Key\n&gt; Private Key (not recommended)\n</code></pre> <p>Select Private Key with the cursor keys and press Enter.</p> </li> <li> <p>The next question is:</p> <pre><code>Warning: You are connecting using your private key which is not recommended\n? Enter Path to Private Key file (E.g. /home/wallet/pvtKeyFile):\n</code></pre> <p>Enter the name and path to the file you and created in step 1 and press Enter.</p> </li> <li> <p>Then:</p> <pre><code>? Which network do you want to connect to? (Use arrow keys)\n&gt; Flare (Mainnet)\n  Coston2 (Testnet)\n  LocalHost (for development only)\n</code></pre> <p>Select Flare (Mainnet) and press Enter.</p> </li> <li> <p>Finally the main menu appears:</p> <pre><code>? What do you want to do? (Use arrow keys)\n  View chain addresses\n&gt; Check on-chain balance\n  Get network info\n  Get validator info\n  Move assets from C-chain to P-chain\n  Move assets from P-chain to C-chain\n  Add a validator node\n</code></pre> <p>As an example, choose Check on-chain balance, and press Enter.</p> <p>The balance of your selected account is shown for both the C-chain and the P-chain and the tool exits.</p> </li> </ol> <p>You can follow the rest of this guide by selecting the Private Key option when prompted.</p>"},{"location":"user/staking/staking-cli/#staking-guide","title":"Staking Guide","text":"<p>To stake on a validator node, you need to:</p> <ol> <li>Check your current P-chain balance.</li> <li>Move funds from the C-chain to the P-chain.</li> <li>Stake them on a validator.</li> <li>Optionally, check that the request has been recorded.</li> <li>Optionally, move the staked funds back to the C-chain once they become unlocked.</li> </ol> <p>Before you start</p> <p>During the process you will need three pieces of information. Take note of them before you start so you can follow the rest of the steps uninterrupted.</p> <ul> <li> <p>The node ID of the validator you want to stake to.</p> <p>If you created the validator, its <code>nodeID</code> was shown to you during the deployment process.</p> <p>If you want to stake to somebody else's validator, you can:</p> <ul> <li>Obtain a list of current validators from any of the tools listed in the Staking page.     Remember to add the <code>NodeID-</code> prefix if it is missing from the listed ID.</li> <li>Use <code>flare-stake-tool info validators</code> to get a JSON list of all validators.</li> </ul> </li> <li> <p>The desired staking start time and end time.</p> <p>When staking to an existing validator, both these times must be inside the period when the validator is active, which you can find in the lists of any of the above tools, or using <code>flare-stake-tool info validators</code>. If you specify a period when the validator is inactive, your transaction on the P-chain reverts.</p> <p>You need to provide these times as a UNIX timestamp, so you might need to use an online conversion tool like Epoch Converter or the Linux <code>date</code> command.</p> <p>As an example, the 1693185095 timestamp corresponds to Monday, August 28, 2023 1:11:35 AM.</p> </li> </ul>"},{"location":"user/staking/staking-cli/#1-check-your-balances","title":"1. Check your Balances","text":"<p>Check your balance by executing <code>flare-stake-tool interactive</code> and selecting the Check on-chain balance option:</p> <pre><code>? How do you want to connect your wallet? Ledger\nYou already have an existing Ctx file with the following parameters -\nPublic Key: \u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\nNetwork: flare\nEth Address: 0x\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\n? Do you wish to continue with this? yes\n? What do you want to do? Check on-chain balance\nUsing network: flare\nBalances on the network \"flare\"\nC-chain 0x\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf: 100000.0 FLR\nP-chain P-flare\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf: 50000.0 FLR\n</code></pre> <p>Your currently available funds on the C-chain and P-chain are shown in the last lines.</p> <p>Funds currently staked are locked and are not reflected in the P-chain balance. They will become automatically available when the staking period expires.</p>"},{"location":"user/staking/staking-cli/#2-move-funds-to-p-chain","title":"2. Move Funds to P-Chain","text":"<p>If your funds are already on the P-Chain, skip this step.</p> <p>Move the funds by executing <code>flare-stake-tool interactive</code> again and selecting the Move assets from C-chain to P-chain option. You are asked the amount of <code>$FLR</code> you want to transfer:</p> <pre><code>? What do you want to do? Move assets from C-chain to P-chain\n? Enter amount (in FLR): 50000\n</code></pre> <p>Transaction Fees</p> <p>When transferring from the C-chain to the P-chain, transaction fees are wholly paid from the C-chain. Make sure you leave enough funds on the C-chain after the transfer, or it will fail.</p> <p>Transfers between chains are made of two operations: an export from the C-chain followed by an import to the P-chain. Therefore, you are asked to confirm TWO transactions on your hardware wallet.</p> <pre><code>Please approve export transaction\nUsing network: flare\nFetching account from ledger...\nCreating export transaction...\nUsing fee of 0.00028075 FLR\nPlease review and sign the transaction on your ledger device...\nSending transaction to the node...\nTransaction with id \u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf sent to the node\nPlease approve import transaction\nUsing network: flare\nFetching account from ledger...\nCreating export transaction...\nPlease review and sign the transaction on your ledger device...\nSending transaction to the node...\nTransaction with id \u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf sent to the node\nFinished execution\n</code></pre> <p>You can check your balances again to verify that the transfer was successful.</p> <p>If you encounter any problem, see the Troubleshooting section.</p>"},{"location":"user/staking/staking-cli/#3-stake","title":"3. Stake","text":"<p>After you have funds on the P-chain, execute <code>flare-stake-tool interactive</code> again and select the appropriate option: If you are going to delegate to your own node (self-bonding), select Add a validator node. Otherwise, if you are going to stake to another node (delegation), select Delegate to a validator node. Press the down key a few times for this last option to show.</p> <p>First-time Address Registration</p> <p>The first time you use the Add a validator node or Delegate to a validator node options you are asked to sign an additional transaction.</p> <p>This step is required so that staking rewards accrued on the P-chain can be claimed on the C-chain and participate in the wider ecosystem.</p> <p>This procedure only needs to be done once per P-chain address and it progresses like this:</p> <pre><code>Checking Address Registration...\nNo address found for key 0x\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\nNote: You need to register your wallet address before you can delegate your funds\nPlease complete this registration transaction to proceed\nSubmitting txn to the chain\n</code></pre> Cryptographical Background <p>Both your P-chain and C-chain addresses are derived from the same public key, but the process is not symmetrical: public keys cannot be derived from addresses.</p> <p>Therefore, smart contracts have no way of knowing the P-chain address that corresponds to a given C-chain address, unless they are both provided by their owner.</p> <p>This step performs exactly this operation, allowing a C-chain address to claim rewards that were accrued by its P-chain counterpart.</p> Manual Address Registration <p>Should automatic registration through the Flare Stake CLI tool fail, you can still register your addresses manually using the Block Explorer:</p> <ol> <li> <p>Retrieve the public key that generated the accounts you want to use.     From a terminal, run <code>flare-stake-tool info addresses</code> and copy the long hexadecimal string starting with <code>0x</code> in the last line.</p> <pre><code>Using network: flare\nAddresses on the network \"flare\"\nP-chain address: P-flare\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\nC-chain address hex: 0x\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\nsecp256k1 public key: 0x\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\n</code></pre> </li> <li> <p>You need to interact with the <code>AddressBinder</code> smart contract, so you must retrieve its address from the <code>FlareContractRegistry</code> as explained in the retrieving Contract Addresses page.</p> </li> <li>Enter the address of the <code>AddressBinder</code> contract in the Block Explorer, and go to the Write Contract tab.</li> <li>Click on Connect Wallet.     You do not need to use the same account as the one you are binding.</li> <li>Locate the <code>registerPublicKey</code> method and paste the public key from step 1 into the <code>_publicKey</code> field.</li> <li>Click on Write and confirm the transaction from your wallet.</li> </ol> <p>If the transaction is successful, your account's P and C-chain addresses are now bound.</p> <p>You then need to provide the following information:</p> <ul> <li>Amount to stake: With the restrictions stated above.     Amount must be provided in FLR units.</li> <li>Validator's NodeID: As explained in the Before you start section.</li> <li>Start time: As explained in the Before you start section.</li> <li>End time: As explained in the Before you start section.</li> </ul> <p>If you selected Add a validator node, you have one more question to answer:</p> <ul> <li> <p>Delegation fee: This is the percentage of all rewards that the node owner keeps.     The rest is split proportionally between the self-bond and all delegators that contributed stake.</p> <p>10 means 10%, so the maximum value is 100.</p> </li> </ul> <pre><code>? What do you want to do? Add a validator node\n? Enter amount (in FLR): 50000\n? Enter Node NodeId (E.g. NodeID-FQKTLuZHEsjCxPeFTFgsojsucmdyNDsz1): NodeID-\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\n? Enter start time(E.g. 1693185095): \u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\n? Enter end time(E.g. 1693185095): \u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\n? Enter delegation fee(E.g. 10): 10\n</code></pre> <p>You are then asked to confirm the staking transaction on your hardware wallet.</p> <pre><code>Using network: flare\nFetching account from ledger...\nCreating export transaction...\nPlease review and sign the transaction on your ledger device...\nSending transaction to the node...\nTransaction with id \u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf sent to the node\nFinished execution\n</code></pre> <p>Your stake is now locked and will start accruing rewards after the configured start time arrives. When the end time arrives, the funds will be automatically unlocked.</p> <p>If you encounter any problem, see the Troubleshooting section.</p>"},{"location":"user/staking/staking-cli/#4-check-stake","title":"4. Check Stake","text":"<p>You can double-check that the operation has been properly registered by looking at the current list of validators:</p> <pre><code>flare-stake-tool info validators &gt; validators.txt\n</code></pre> <p>This creates a file called <code>validators.txt</code>. Open it and search for the line containing the P-chain address of your account. If you don't know it, use <code>flare-stake-tool info addresses</code>.</p> <p>If your account has stake on any node, you will find a section similar to:</p> <pre><code>{\n  \"txID\": \"28Yf5yQ3xt9yaMvfZ1RP5jkCkT4y2pfD86UheZUHFVng2tFcWd\",\n  \"startTime\": \"1688569201\",\n  \"endTime\": \"1696345201\",\n  \"stakeAmount\": \"16750000000000000\",\n  \"nodeID\": \"NodeID-C6i8mruq11VdxGQ7tiUBgrRqoLBot86df\",\n  \"rewardOwner\": {\n    \"locktime\": \"0\",\n    \"threshold\": \"1\",\n    \"addresses\": [\n      \"P-flare19c8zfml39x6efnw5j90nl85dmwdqhluwhrxz9g\"\n    ]\n  },\n},\n</code></pre> <p>Check that the <code>stakeAmount</code> (in wei), <code>nodeID</code>, <code>startTime</code>, and <code>endTime</code> match the values you configured.</p> <p>If you have multiple active stakes, your address can show multiple times.</p>"},{"location":"user/staking/staking-cli/#5-move-funds-back-to-c-chain","title":"5. Move funds back to C-Chain","text":"<p>Finally, you also have the option to move your P-chain funds back to the C-chain where they can participate in the wider ecosystem.</p> <p>You can only transfer P-chain funds that are not currently locked in any stake.</p> <p>Execute <code>flare-stake-tool interactive</code> and select the Move assets from P-chain to C-chain option. You are asked the amount of <code>$FLR</code> you want to transfer:</p> <pre><code>? What do you want to do? Move assets from P-chain to C-chain\n? Enter amount (in FLR): 50000\n</code></pre> <p>Transaction Fees</p> <p>When transferring from the P to the C-chain, transaction fees are paid from BOTH chains. Make sure you leave enough funds on both chains after the transfer, or it will fail.</p> <p>Again, the transfer between the two chains require you to confirm TWO transactions on your hardware wallet.</p> <pre><code>Please approve export transaction\nUsing network: flare\nFetching account from ledger...\nCreating export transaction...\nPlease review and sign the transaction on your ledger device...\nSending transaction to the node...\nTransaction with id \u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf sent to the node\nPlease approve import transaction\nUsing network: flare\nFetching account from ledger...\nCreating export transaction...\nUsing fee of 0.00028075 FLR\nPlease review and sign the transaction on your ledger device...\nSending transaction to the node...\nTransaction with id \u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf sent to the node\nFinished execution\n</code></pre> <p>You can check your balances again to verify that the transfer was successful.</p> <p>If you encounter any problem, see the Troubleshooting section.</p>"},{"location":"user/staking/staking-cli/#reward-claiming-guide","title":"Reward Claiming Guide","text":"<p>At the end of every reward epoch, participants are rewarded according to how well their chosen validator performed in that period, but these rewards are not claimable yet.</p> <p>Every 4 reward epochs, rewards are accumulated in a dedicated smart contract and can then be claimed from the Flare Stake CLI tool:</p> <p>Execute <code>flare-stake-tool interactive</code> and select the Claim Rewards option. Press the down key a few times for this option to show.</p> <p>You are shown the amount of pending rewards (in wei) and are asked how much you want to claim (in FLR):</p> <pre><code>? What do you want to do? Claim Rewards\nChecking your Rewards status...\nYou have unclaimed rewards worth 1000000000000000000\n? Enter amount to claim (in FLR): 1\n</code></pre> <p>Next, select Receive with another wallet and enter the C-chain address where you want the rewards to be sent. This can be the same address from where you are staking.</p> <pre><code>? Where do you want to receive your rewards? Receive with another wallet\n? Please enter the C-address where you want to receive your rewards: 0x\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\n</code></pre> <p>You are then asked to confirm the staking transaction on your hardware wallet.</p> <pre><code>Please sign the transaction on your ledger\nSubmitting txn to the chain\nRewards successfully claimed\nFinished execution\n</code></pre> Manual Reward Claiming <p>Rewards can also be claimed directly from the <code>ValidatorRewardManager</code> contract that accumulates them:</p> <ol> <li>You need to interact with the <code>ValidatorRewardManager</code> smart contract, so you must retrieve its address from the <code>FlareContractRegistry</code> as explained in the retrieving Contract Addresses page.</li> <li>Enter the address of the <code>ValidatorRewardManager</code> contract in the Block Explorer, and go to the Write Contract tab.</li> <li>Click on Connect Wallet.     You need to connect the account for which you are claiming.</li> <li> <p>Locate the <code>claim</code> method and enter the following information:</p> <ul> <li>_rewardOwner: C-chain address that accrued the rewards.</li> <li>_recipient: Address where the rewards must be sent.</li> <li>_rewardAmount: Amount to claim.     Find the pending amount using the <code>getStateOfRewards</code> method in the Read Contract tab.</li> <li>_wrap: Whether the rewards should be also wrapped, as a convenience.</li> </ul> </li> <li> <p>Click on Write and confirm the transaction from your wallet.</p> </li> </ol> <p>If the transaction is successful, the reward is transferred to the specified recipient.</p>"},{"location":"user/staking/staking-cli/#troubleshooting","title":"Troubleshooting","text":"Cannot connect to Ledger device, No Device, Cannot retrieve addresses, or similar <p>Make sure:</p> <ul> <li> <p>The device is connected, the Avalanche app is opened, and it shows the \"Avalanche Ready\" message.</p> </li> <li> <p>No other application like Ledger Live or MetaMask is connected to the device.</p> </li> <li> <p>The device is not in stand-by mode.</p> </li> <li> <p>You are not running on Windows from a Linux terminal (WSL).     Use a native Windows console instead.</p> </li> </ul> Insufficient funds <p>Make sure enough funds will remain after a transaction to pay for the transaction fees.</p> <p>If too much time has elapsed between the transaction's creation and its confirmation on the Ledger, the calculated fee might be incorrect. Try the operation again.</p> <p>The network might be congested and the calculated fees might not be high enough. Try the operation again after a while.</p> Import transaction failed and the funds have vanished <p>Transfer operations require an export and an import transaction. If the export succeeds, but then the import fails, it looks like the funds have disappeared from both chains, but they are still retrievable.</p> <p>Repeat the failed import operation manually:</p> <ul> <li> <p>If you are moving funds from the C-chain to the P-chain:</p> <pre><code>flare-stake-tool transaction importCP --ledger --blind\n</code></pre> </li> <li> <p>If you are moving funds from the P-chain to the C-chain:</p> <pre><code>flare-stake-tool transaction importPC --ledger --blind\n</code></pre> </li> </ul> Unsupported digital routines <p>If you get the following error message:</p> <pre><code>E: Error: error:0308010C:digital envelope routines::unsupported\n</code></pre> <p>Make sure you are using the correct Node.js version, as advised in the Prerequisites section.</p> <p>You can find out the version of Node.js you are running with the following command:</p> <pre><code>node --version\n</code></pre>"},{"location":"user/staking/staking-flarestake/","title":"Using FlareStake to Stake","text":"<p>FlareStake is a graphical user interface (GUI) that enables you to easily stake your funds to validators and earn rewards.</p> <p>Staking works by locking funds for a period of time to support a specific network validator. When validator owners stake to their own nodes they self-bond, whereas all other participants are said to delegate their stake to that validator.</p> <p>Note</p> <p>Proof of stake is being implemented on Flare in phases. Ensure that you have read the Validators page to learn about them.</p> <p>Participants choose how much to stake and for how long their stake will be locked. The minimum values are:</p> Self-bond Delegation Minimum amount 1M <code>$FLR</code> 50K <code>$FLR</code> Minimum duration 60 days 14 days <p>At the end of every reward epoch, participants are rewarded according to how well their chosen validator performed in that period.</p> <p>Staking amounts and rewards are limited</p> <p>When you choose your validator and amount to stake, consider the delegation factor and the staking cap.</p> <p>The deployment phases summary shows other rewards that staked funds can still earn while they are locked.</p> <p>Given that the Flare network uses two independent underlying chains, there is one extra step that must be considered. Funds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens. After the staking period expires and funds are unlocked, they can be transferred back to the C-chain.</p> <p>This guide explains how to stake Flare assets by using FlareStake, the GUI tool for staking. Another tool exists which uses the command line exclusively. See the Using the CLI to Stake guide to learn about it.</p>"},{"location":"user/staking/staking-flarestake/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Ledger hardware wallet set up to manage Flare assets.</li> <li>Knowledge of the available validators to which you want to delegate your funds.     Obtain a list of current validators from any of the tools listed in the Staking page.</li> </ul>"},{"location":"user/staking/staking-flarestake/#accessing-your-wallet","title":"Accessing Your Wallet","text":"<ol> <li>Open FlareStake.</li> <li>Click Access Wallet.</li> <li> <p>Click Ledger.</p> <p>Make sure your Ledger device is plugged in, it is unlocked with your PIN, and the Avalanche app is running</p> Installing the Avalanche application <ol> <li>Connect the device to your computer and unlock it using your PIN code.</li> <li>Open the Ledger Live application.     Go to the My Ledger tab and make sure the device is using the latest firmware.</li> <li> <p>In the App catalog tab, search for \"Avalanche\" and click on the Install button.</p> <p>Version should be at least v0.6.5.</p> <p>Note that this app requires all available space on a Ledger Nano S device (138 KB). You might need to remove other apps first to free up space.</p> </li> <li> <p>Exit the Ledger Live application and make sure the device is not connected to any other application like MetaMask.</p> </li> </ol> </li> <li> <p>Click the top dropdown menu to select whether the account containing the funds you want to stake was created using Ledger Live or some other wallet like MetaMask.</p> <p> Address selection dialog. </p> Derivation Paths <p>A single hardware wallet can generate an unlimited number of addresses by using a derivation path. By using the same derivation path, multiple wallets like MetaMask of Bifrost can retrieve the same addresses from a hardware wallet.</p> <p>You need to tell FlareStake the derivation path that was used to obtain the address containing the funds you want to stake. Fortunately, there are only two common paths:</p> <ul> <li>Ledger Live: If you created your account from the Ledger Live tool.</li> <li>BIPS-44: If you used almost any other wallet.</li> </ul> </li> <li> <p>Click the bottom dropdown menu, and select the address you want to use from the list.</p> <p>The first time it takes a few seconds to obtain the list of addresses from the device.</p> </li> <li> <p>Click Access Wallet.    The FlareStake dashboard is displayed.</p> </li> </ol> <p>You can now continue to the Staking Guide or the Reward Claiming Guide.</p>"},{"location":"user/staking/staking-flarestake/#staking-guide","title":"Staking Guide","text":"<p>To stake on a validator node, you need to:</p> <ol> <li>Bind your C-chain and P-chain addresses.</li> <li>Move your funds from the C-chain to the P-chain.</li> <li>Stake them on a validator.</li> </ol>"},{"location":"user/staking/staking-flarestake/#1-binding-your-addresses","title":"1. Binding Your Addresses","text":"<p>To receive your staking rewards, you must bind your P-chain address to your C-chain address.</p> <p>This procedure only needs to be done once per P-chain address. See the command-line version of this guide for more information.</p> <ol> <li> <p>On the FlareStake dashboard, click  Staking.</p> </li> <li> <p>In the Bind Your Addresses section, click Register.</p> <p> Address binding menu. </p> <p>The Bind Your Addresses window is displayed.</p> </li> <li> <p>Click Bind Address.</p> </li> <li> <p>Confirm the action on your Ledger.</p> </li> </ol> <p>Your P-chain address and your C-chain address are now bound to each other.</p>"},{"location":"user/staking/staking-flarestake/#2-move-funds-to-the-p-chain","title":"2. Move Funds to the P-Chain","text":"<p>To stake, your P-chain address must contain at least 50.000 native <code>$FLR</code> tokens. If your P-chain address is already properly funded, skip this step.</p> <p>Keep in mind that wrapped <code>$WFLR</code> tokens must be unwrapped before they can be transferred to the P-chain.</p> <ol> <li>On the FlareStake dashboard, click  Cross Chain.</li> <li>Ensure the Source Chain field says C-chain and the Destination Chain field says P-chain.</li> <li>In the Amount field, specify the amount of <code>$FLR</code> to send to your P-chain address.</li> <li>Click Confirm.</li> <li>Click Transfer.</li> <li> <p>Confirm the action on your Ledger.</p> <p>Transaction Fees</p> <p>When transferring from the C-chain to the P-chain, transaction fees are wholly paid from the C-chain. Make sure you leave enough funds on the C-chain after the transfer, or it will fail.</p> <p>Transfers between chains are made of two operations: an export from the C-chain followed by an import to the P-chain. Therefore, you are asked to confirm TWO transactions on your hardware wallet.</p> </li> </ol> <p>The amount of funds you specified in step 3 is now at your P-chain address.</p>"},{"location":"user/staking/staking-flarestake/#3-stake-your-funds","title":"3. Stake Your Funds","text":"<p>To stake funds, you delegate them to an existing validator.</p> <ol> <li>On the FlareStake dashboard, click  Staking.</li> <li> <p>In the Add a Delegation section, click Add Delegation.</p> <p> Add a delegation menu. </p> <p>The Delegate window is displayed.</p> </li> <li> <p>In the Node ID column, locate the ID for the validator to which you want to delegate your staking funds.</p> </li> <li> <p>To select the validator, click Select.    Information about the validator is displayed.</p> </li> <li> <p>In the Staking End Date field, specify the date and time when you want to stop staking your funds.    If you specify a date and time that occurs after the validator's self-bond has ended, your transaction on the P-chain will revert.</p> </li> <li> <p>In the Staking Amount field, specify the amount of <code>$FLR</code> you want to delegate to stake.</p> </li> <li> <p>Click Confirm.    The staking information you specified is displayed.</p> </li> <li> <p>Review the staking information.    If it is correct, click Submit to begin your delegation.    Otherwise, click Cancel.</p> </li> <li> <p>Confirm the action on your Ledger.</p> </li> </ol> <p>Your stake is now locked and will start accruing rewards immediately. When the selected end time arrives, the funds will be automatically unlocked.</p>"},{"location":"user/staking/staking-flarestake/#reward-claiming-guide","title":"Reward Claiming Guide","text":"<p>At the end of every reward epoch, participants are rewarded according to how well their chosen validator performed in that period, but these rewards are not claimable yet.</p> <p>Every 4 reward epochs, rewards are accumulated in a dedicated smart contract and can then be claimed from the FlareStake tool:</p> <ol> <li> <p>On the FlareStake dashboard, click  Staking.</p> </li> <li> <p>In the Manage Rewards section, click Manage Rewards.</p> <p> Manage rewards menu. </p> <p>Information about your rewards is displayed.</p> </li> <li> <p>In the Rewards to claim field, specify all or part of your unclaimed rewards.</p> </li> <li>Optional: To send your rewards to a different wallet, click Another Wallet, and specify the address in the C-Chain Address field.</li> <li>Click Claim Rewards.</li> <li>Confirm the action on your Ledger.</li> </ol> <p>Your rewards are claimed and added to your available balance.</p>"},{"location":"user/wallets/","title":"Wallets","text":"<p>Choose your wallet:</p> <ul> <li>Bifrost Wallet</li> <li>Brave Wallet</li> <li>D'CENT Wallet</li> <li>Enkrypt Wallet</li> <li>Ledger Nano X and Nano S</li> <li>MetaMask</li> <li>SafePal S1 Wallet</li> <li>Trezor T</li> </ul> <p>If your wallet is not in the list, you might be able to configure it to connect to the Flare and Songbird networks by specifying the following configuration parameters in your wallet's settings:</p> FlareSongbird Configuration Parameter Value Chain ID 14 Asset Ticker <code>FLR</code> RPC endpoint <code>https://flare-api.flare.network/ext/bc/C/rpc</code> Block Explorer https://flare-explorer.flare.network Configuration Parameter Value Chain ID 19 Asset Ticker <code>SGB</code> RPC endpoint <code>https://songbird-api.flare.network/ext/bc/C/rpc</code> Block Explorer https://songbird-explorer.flare.network"},{"location":"user/wallets/bifrost-wallet/","title":"Bifrost Wallet","text":"<p>Bifrost Wallet is a noncustodial mobile wallet available for both Android and iOS. You can view your portfolio of crypto assets, access decentralized applications through the in-app browser and perform operations on various blockchain networks, including sending, receiving, wrapping and delegating Flare (<code>$FLR</code>) and Songbird (<code>$SGB</code>).</p>"},{"location":"user/wallets/bifrost-wallet/#getting-started","title":"Getting Started","text":"<p>Start by downloading Bifrost Wallet from the Apple App Store or Google Play Store and either create a new wallet or import an existing one from a recovery phrase.</p> <p>The official guides in the Bifrost Wallet help center may be of assistance.</p> <p>Please make sure you have installed at least version 0.4.5</p> <p>XRP Airdrop</p> <p>Note that, once <code>$FLR</code> distribution begins, users who imported their Ethereum-style claim address into Bifrost to access the XRP airdrop will automatically see their tokens in the Flare asset row in the <code>COINS</code> section.</p>"},{"location":"user/wallets/bifrost-wallet/#adding-flare-tokens","title":"Adding Flare Tokens","text":"<p>When your balance of any native or wrapped token on the Flare network or Songbird network is more than 0, Bifrost Wallet automatically displays the balance. No additional action is required.</p>"},{"location":"user/wallets/bifrost-wallet/#wrap-and-delegate","title":"Wrap and Delegate","text":"<p>When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards.</p> <p>To wrap and delegate your <code>$FLR</code> or <code>$SGB</code> tokens using Bifrost Wallet, see Bifrost's guide for wrapping and delegating $FLR and guide for wrapping and delegating $SGB.</p> <p>Alternatively, wrap and delegate your <code>$FLR</code> or <code>$SGB</code> tokens using the Flare Portal. First, wrap your tokens, and then delegate them.</p>"},{"location":"user/wallets/brave-wallet/","title":"Brave Wallet","text":"<p>Brave Browser now offers a noncustodial software wallet on both Windows and macOS for Ethereum Virtual Machine (EVM) integrated chains such as Flare and Songbird.</p>"},{"location":"user/wallets/brave-wallet/#getting-started","title":"Getting Started","text":"<p>To use Brave Wallet with Flare or Songbird, ensure you have:</p> <ul> <li>Downloaded Brave Browser to your computer, version 1.42.88 or later.</li> <li>Initialized a Brave wallet or restored an existing one.</li> <li>Protected your Brave wallet with a password.</li> <li>Backed up your crypto wallet with a 12-word recovery phrase.</li> </ul>"},{"location":"user/wallets/brave-wallet/#adding-flare-tokens","title":"Adding Flare Tokens","text":"<p>After your wallet is set up, you need to connect to Flare's networks, which will add each network's native token to your listed assets.</p> <ol> <li>Open Brave browser on your computer.</li> <li>Navigate to Settings, and select Web3 from the list of options.</li> <li>In the box on the right, click Wallet Networks, and then click Add.</li> <li> <p>Complete the following steps to set up the Flare network and Songbird network:</p> FlareSongbird <ol> <li> <p>In the Search network field, select <code>0xe(14) Flare Mainnet</code>, and verify that the displayed values match the values in this table:</p> Network Setting Value The id of chain 0xe The name of chain Flare Mainnet Chain's currency name Flare Chain's currency symbol FLR Chain's currency decimals 18 RPC URLs https://flare-api.flare.network/ext/bc/C/rpc Icon URLs (leave blank) Block explorer URLs https://flare-explorer.flare.network </li> <li> <p>Click Submit.</p> </li> </ol> <ol> <li> <p>In the Search network field, select <code>0x13(19) Songbird Canary-Network</code>, and verify that the displayed values match the values in the following table.</p> <p>Tip</p> <p>Make sure the RPC node URL is <code>https://songbird-api.flare.network/ext/bc/C/rpc</code>.</p> Network Setting Value The id of chain 0x13 The name of chain Songbird Canary-Network Chain's currency name Songbird Chain's currency symbol SGB Chain's currency decimals 18 RPC URLs https://songbird-api.flare.network/ext/bc/C/rpc Icon URLs (leave blank) Block explorer URLs https://songbird-explorer.flare.network </li> <li> <p>Click Submit.</p> </li> </ol> </li> <li> <p>Click Wallet.</p> </li> <li>Specify your password, and click Unlock.</li> <li>On the left side of the screen beside Balance, click the drop-down menu and select Flare or Songbird.    Connection to the network is complete, and your balance of native tokens on the selected network is displayed.</li> </ol> <p>With the previous steps completed, you now have access to the Flare network and Songbird Network and each network's native token, but you must complete an extra step for the wallet to recognize wrapped tokens, which are needed in a lot of operations.</p>"},{"location":"user/wallets/brave-wallet/#wrap-and-delegate","title":"Wrap and Delegate","text":"<p>When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards.</p> <p>Wrap and delegate your <code>$FLR</code> or <code>$SGB</code> tokens using the Flare Portal. First, wrap your tokens, and then delegate them.</p>"},{"location":"user/wallets/dcent-wallet/","title":"D'CENT Wallet","text":"<p>D'CENT Biometric Wallet is a noncustodial hardware wallet and is considered one of the most secure ways to manage your crypto assets.</p>"},{"location":"user/wallets/dcent-wallet/#getting-started","title":"Getting Started","text":"<p>Purchase a D'CENT Biometric hardware wallet from the official D'CENT shop or download their software wallet/mobile app from the Apple App Store or Google Play Store. Then either initialize a new wallet or import an existing one from a recovery phrase.</p> <p>The official D'CENT device setup help guides can be found here: https://userguide.dcentwallet.com/biometric-wallet/setting-up.</p>"},{"location":"user/wallets/dcent-wallet/#adding-flare-tokens","title":"Adding Flare Tokens","text":"<p>After your device is set up and synced with the mobile app, complete the following procedure to add native tokens <code>$FLR</code> and <code>$SGB</code> to your listed assets. Although this procedure also explains how to add the wrapped tokens <code>$WFLR</code> and <code>$WSGB</code> to your listed assets, you can automatically add <code>$WFLR</code> and <code>$WSGB</code> using the Flare Portal.</p> <ol> <li>Ensure the D'CENT biometric wallet is updated with the latest firmware, v2.24.0 or later.</li> <li>Login to your D'CENT mobile app and have your device turned on, unlocked, and paired via Bluetooth.</li> <li>Click the + sign on the bottom right of the Account tab.</li> <li> <p>In the Search box, search for one of the following tokens to add, and select the result:</p> Token Result <code>Flare</code> Flare (FLR) <code>Songbird</code> Songbird Token (SGB) <code>Wrapped Flare</code> Wrapped Flare (WFLR) <code>Wrapped Songbird</code> Wrapped Songbird (WSGB) </li> <li> <p>Name your new account, and click Create.</p> </li> <li>Repeat steps 4 and 5 for each token you want to add to the list of assets in your wallet.</li> </ol>"},{"location":"user/wallets/dcent-wallet/#wrap-and-delegate","title":"Wrap and Delegate","text":"<p>When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards.</p> <p>You can wrap and delegate your <code>$SGB</code> using D'CENT's native FTSO Portal:</p> <p>Delegation instructions for the Flare network are awaiting confirmation.</p> <ol> <li>Click the Discovery tab at the bottom middle of the screen.</li> <li>Select the FTSO Portal from the menu then click Go.</li> <li>Choose the Songbird account you wish to use and click Connect.</li> <li>You will need to wrap your <code>$SGB</code> by clicking SGB \u2194\ufe0f WSGB marked in green near the top middle of the screen.</li> <li>Input the <code>$SGB</code> amount you want to wrap and click the green SGB \u2194\ufe0f WSGB box.</li> <li>Click Confirm and follow the prompts to sign the transaction with your hardware device.</li> <li>You can now delegate your <code>$WSGB</code> by clicking Add delegation.</li> <li> <p>Select a provider and input the percentage of your <code>$WSGB</code> holdings you want to delegate to their service and press Delegate.</p> <p>Note</p> <p>Providers listed as a Partner have additional security features integrated with D'cent.</p> </li> <li> <p>Click Confirm and follow the prompts to sign the transaction with your hardware device.</p> </li> <li>To add a second provider (up to two), repeat steps 7 through 9.</li> </ol> <p>Alternatively, wrap and delegate your <code>$FLR</code> or <code>$SGB</code> tokens using the Flare Portal. First, wrap your tokens, and then delegate them.</p>"},{"location":"user/wallets/enkrypt-wallet/","title":"Enkrypt Wallet","text":"<p>Enkrypt is a multichain, open-source and noncustodial wallet that tracks no data. It interacts with Polkadot, Ethereum, Bitcoin and more, all directly in the browser.</p>"},{"location":"user/wallets/enkrypt-wallet/#getting-started","title":"Getting Started","text":"<ol> <li>Install Enkrypt.</li> <li>Create a new wallet or import an existing wallet to Enkrypt.</li> <li>Securely back up your recovery phrase offline.</li> <li>Protect your Enkrypt wallet with a password.</li> </ol>"},{"location":"user/wallets/enkrypt-wallet/#adding-flare-tokens","title":"Adding Flare Tokens","text":"<p>After you set up your wallet, connect to Flare's networks, which will add each network's native token and wrapped token to your listed assets:</p> <ol> <li> <p>Add Flare or Songbird as a custom network using these parameters:</p> FlareSongbird <ol> <li>From the main menu, click Manage networks. The Manage networks window is displayed.</li> <li>Click the sliders icon beside the Search networks field.</li> <li>Click Custom network.     The Custom network window is displayed.</li> <li> <p>Specify the following values:</p> Network Setting Value Network Name Flare New RPC URL https://flare-api.flare.network/ext/bc/C/rpc Chain ID 14 Currency Symbol FLR Block Explorer URL https://flare-explorer.flare.network </li> <li> <p>Click Add network.</p> </li> <li>Locate Flare Mainnet at the bottom of the list, and toggle the switch to enable your wallet to display your balance of <code>$FLR</code>.</li> <li> <p>Follow these instructions for manually adding tokens to retrieve the <code>WNat</code> contract address, and copy it.</p> <p>Tip</p> <p>The WNat contract address is different on each network. Ensure you copy the <code>WNat</code> contract address on the Flare network.</p> </li> <li> <p>With Flare Mainnet selected on the main menu in your Enkrypt wallet, click Add custom token.     The Add a token window is displayed.</p> </li> <li>In the Contract address field, paste the <code>WNat</code> contract address that you copied in step 6.</li> <li>Click Add token.      The wrapped token <code>$WFLR</code> is added to your list of Flare assets.</li> </ol> <ol> <li>From the main menu, click Manage networks.      The Manage networks window is displayed.</li> <li>Click the sliders icon beside the Search networks field.</li> <li>Click Custom network. The Custom network window is displayed.</li> <li> <p>Specify the following values:</p> Network Setting Value Network Name Songbird New RPC URL https://songbird-api.flare.network/ext/bc/C/rpc Chain ID 19 Currency Symbol SGB Block Explorer URL https://songbird-explorer.flare.network </li> <li> <p>Click Add network.</p> </li> <li>Locate Songbird Canary-Network at the bottom of the list, and toggle the switch to enable your wallet to display your balance of <code>$SGB</code>.</li> <li> <p>Follow these instructions for manually adding tokens to retrieve the <code>WNat</code> contract address, and copy it.</p> <p>Tip</p> <p>The WNat contract address is different on each network. Ensure you copy the <code>WNat</code> contract address on the Songbird network.</p> </li> <li> <p>With Songbird Canary-Network selected on the main menu in your Enkrypt wallet, click Add custom token.      The Add a token window is displayed.</p> </li> <li>In the Contract address field, paste the <code>WNat</code> contract address that you copied in step 6.</li> <li>Click Add token.      The wrapped token <code>$WSGB</code> is added to your list of Songbird assets.</li> </ol> </li> </ol>"},{"location":"user/wallets/enkrypt-wallet/#wrap-and-delegate","title":"Wrap and Delegate","text":"<p>When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards.</p> <p>Wrap and delegate your <code>$FLR</code> or <code>$SGB</code> tokens using the Flare Portal. First, wrap your tokens, and then delegate them.</p>"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/","title":"Ledger Nano X and Nano S","text":"<p>Hardware wallets are considered among the more secure options to manage crypto assets and store private keys. Your crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions.</p> <p>This guide explains how to configure your Ledger device to use it through the MetaMask wallet.</p>"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#one-time-setup","title":"One-Time Setup","text":"<p>You only need to perform the steps in this section once.</p>"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#installing-metamask","title":"Installing MetaMask","text":"<p>Follow the MetaMask guide to install and configure the MetaMask wallet. Make sure MetaMask can show <code>$FLR</code> and <code>$SGB</code> tokens, and their wrapped <code>$WFLR</code> and <code>$WSGB</code> versions.</p>"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#installing-ledger","title":"Installing Ledger","text":"<p>Follow the Ledger instructions to:</p> <ol> <li>Install Ledger Live and open it.</li> <li>Initialize your Ledger device with a recovery phrase.</li> <li>Protect your Ledger device with a PIN code.</li> <li>Install the latest Ledger device firmware.</li> </ol>"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#installing-the-ethereum-app","title":"Installing the Ethereum App","text":"<p>Flare is EVM-compatible, so it uses the Ethereum app on Ledger. After meeting the requirements above, install the Ethereum app on the device with the following steps:</p> <ol> <li>Open the Manager in Ledger Live.</li> <li>Connect and unlock your Ledger device.</li> <li>Enable the manager on your Ledger device by pressing both buttons.</li> <li>Find Ethereum (ETH) in the app catalog.</li> <li>Click the Install button of the app.</li> </ol> <p>Your Ledger device displays Processing\u2026. The app installation is complete.</p>"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#creating-accounts","title":"Creating Accounts","text":"<p>After enabling access to Songbird and Flare in MetaMask, create one or more accounts.</p> <p>In MetaMask:</p> <ol> <li>Select Flare or Songbird in the network dropdown.</li> <li>Connect your Ledger device using USB.</li> <li>Open the Ethereum app on your Ledger device.</li> <li>If Ledger Live is still running on your computer, you must quit the app.</li> <li>Locate MetaMask's Settings and then Advanced settings.</li> <li>Ensure that the Preferred Ledger Connection Type is set to WebHID in the drop-down menu (it should be the case by default).</li> <li>Click your account image and Connect Hardware Wallet. A pop up box opens listing paired Human Interface Devices (HID).</li> <li>Highlight your Ledger S or Ledger X and click Connect. A random set of addresses opens that are available for your use.</li> <li>To create one or more accounts (for example, for different tokens or different purposes), select any account number or multiple account numbers and click Unlock.</li> </ol> <p>You have created one or more Ledger accounts to which you can send <code>$FLR</code> or <code>$SGB</code> tokens.</p> <p>Your <code>$FLR</code> and <code>$SGB</code> balance will be displayed on the MetaMask overview. Once the accounts contain <code>$WFLR</code> or <code>$WSGB</code> their balances will be shown too if you followed the Wrapping Flare Tokens guide.</p> <p>Note</p> <p>The Ledger Live desktop application, as of version 2.55, can show your <code>$FLR</code> and <code>$SGB</code> balances but NOT the wrapped <code>$WFLR</code> and <code>$WSGB</code> versions.</p> <p>The tokens are still in the account, but Ledger Live does not show them.</p>"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#using-ledger-with-metamask","title":"Using Ledger with MetaMask","text":"<p>Now that you have the one-time setup complete, here are a few things you can do to get started using your new accounts.</p> <ul> <li> <p>Receive tokens. To receive tokens, copy your account address and share it with the sender.</p> </li> <li> <p>Send tokens. To send tokens, click Send and enter the recipient address. Then enter the desired amount and click Next. MetaMask will ask you to confirm the transaction from the Ledger device.</p> </li> <li> <p>Confirm transactions. To confirm or reject a transaction, follow the on-screen instructions on your Ledger device.</p> </li> </ul> <p>Warning</p> <p>Always review all transaction details on your Ledger device before confirming any transaction!</p> <p>To learn how to use Ledger, including signing transactions, go to Ledger.com.</p>"},{"location":"user/wallets/how-to-access-flare-network-with-a-trezor-device/","title":"Trezor T","text":"<p>Hardware wallets are considered among the more secure options to manage crypto assets and store private keys. Your crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions.</p>"},{"location":"user/wallets/how-to-access-flare-network-with-a-trezor-device/#getting-started","title":"Getting Started","text":"<p>To use your Trezor device with Flare (<code>$FLR</code>) or Songbird (<code>$SGB</code>), first make sure that you have:</p> <ol> <li>Initialized your Trezor device with a recovery phrase.</li> <li>Protected your Trezor device with a PIN code.</li> <li>Trezor Suite is installed, open and ready to use.</li> <li>Enabled Ethereum under the Crypto tab in Trezor Suite.</li> <li>Installed the latest Trezor device firmware.</li> <li>Installed the latest version of Google Chrome.</li> <li>Installed the MetaMask browser extension.</li> </ol>"},{"location":"user/wallets/how-to-access-flare-network-with-a-trezor-device/#use-trezor-t-device-with-metamask","title":"Use Trezor T Device with MetaMask","text":"<p>You can access Flare and Songbird by using your Trezor T with the MetaMask browser extension.</p> <ol> <li>Open the MetaMask browser extension in your browser.</li> <li> <p>Click Custom RPC in the network dropdown.</p> SongbirdFlare Field Value Network Name Songbird New RPC URL https://songbird-api.flare.network/ext/bc/C/rpc Chain ID 19 Currency Symbol SGB Block Explorer URL https://songbird-explorer.flare.network Field Value Network Name Flare New RPC URL https://flare-api.flare.network/ext/bc/C/rpc Chain ID 14 Currency Symbol FLR Block Explorer URL https://flare-explorer.flare.network </li> <li> <p>Click Save.</p> </li> <li>Select Flare or Songbird in the network dropdown.</li> <li>Connect and unlock your Trezor device.</li> <li>Click your account image and Connect Hardware Wallet.</li> <li>Select Trezor and click Continue.</li> <li>Follow the on screen instructions to export your public key.</li> <li>Select your Account and click Unlock.</li> </ol> <p>Info</p> <p>Please note that the provided Flare RPC node is only for individuals and not for commercial use.</p> <p>Companies and developers may contact Flare Networks to arrange dedicated access.</p> <p>You will see your <code>$FLR</code> or <code>$SGB</code> balance on the overview. To receive tokens, copy your account address and share it with the sender. To send tokens, click Send and enter the recipient address, enter the desired amount and click Next. Follow the on screen instructions to confirm or reject the transaction on your Trezor device.</p> <p>Warning</p> <p>Always review all transaction details on your Trezor device before confirming any transaction!</p>"},{"location":"user/wallets/how-to-access-flare-network-with-a-trezor-device/#wrap-and-delegate","title":"Wrap and Delegate","text":"<p>Once connected to a Flare network, enter the address of the website or dapp you wish to use to wrap and delegate in the MetaMask browser. A few FTSO data providers have developed dApps integrated with their websites that allow users to wrap, delegate and claim SGB and Flare rewards. Delegating using this method is not exclusive to one specific provider, as these dapps allow you to choose from a number of different providers.</p> <p>Other providers have their own websites and are developing similar dapps. See the full list of active data providers on flaremetrics.io.</p>"},{"location":"user/wallets/how-to-access-flare-network-with-metamask/","title":"MetaMask","text":"<p>The MetaMask browser extension is a convenient way to access and interact with blockchains like Songbird or Flare. To do so, you need to first add a custom network to MetaMask, as explained in this guide. Make sure that you have securely backed up your recovery phrase before proceeding.</p>"},{"location":"user/wallets/how-to-access-flare-network-with-metamask/#getting-started","title":"Getting Started","text":"<p>To use MetaMask with Songbird or Flare, ensure you have:</p> <ol> <li>Installed the latest version of Google Chrome.</li> <li>Installed the MetaMask browser extension.</li> <li>Created a new wallet or imported an existing wallet to MetaMask.</li> <li>Securely backed up your recovery phrase offline.</li> <li>Protected your MetaMask with a password.</li> </ol>"},{"location":"user/wallets/how-to-access-flare-network-with-metamask/#adding-flare-tokens","title":"Adding Flare Tokens","text":"<p>After you set up your wallet, add the native tokens <code>$FLR</code> and <code>$SGB</code> and the wrapped tokens <code>$WFLR</code> and <code>$WSGB</code> to your listed assets:</p> <ol> <li>Open the MetaMask browser extension.</li> <li>Unlock your MetaMask wallet with your password.</li> <li>Click the networks drop-down menu, and click Add network. In a browser tab, the Settings menu opens to the Networks section.</li> <li>Scroll to the bottom of the page, and click Add a network manually.</li> <li> <p>Complete the following steps to set up the Flare network and Songbird network:</p> FlareSongbird <ol> <li> <p>Specify the values from the following table to set up the Flare network, which will add the native <code>$FLR</code> token to your list of assets.</p> Field Value Network Name Flare New RPC URL https://flare-api.flare.network/ext/bc/C/rpc Chain ID 14 Currency Symbol FLR Block Explorer URL https://flare-explorer.flare.network </li> <li> <p>Click Save.</p> </li> <li>Follow these instructions to automatically add <code>$WFLR</code> to your listed assets.</li> </ol> <ol> <li> <p>Specify the values from the following table to set up the Songbird network, which will add the native <code>$SGB</code> token to your list of assets.</p> Field Value Network Name Songbird New RPC URL https://songbird-api.flare.network/ext/bc/C/rpc Chain ID 19 Currency Symbol SGB Block Explorer URL https://songbird-explorer.flare.network </li> <li> <p>Click Save.</p> </li> <li>Follow these instructions to automatically add <code>$WSGB</code> to your listed assets.</li> </ol> </li> </ol> <p>Warning</p> <p>Always review all transaction details in MetaMask before confirming any transaction!</p>"},{"location":"user/wallets/how-to-access-flare-network-with-metamask/#wrap-and-delegate","title":"Wrap and Delegate","text":"<p>When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards.</p> <p>Wrap and delegate your <code>$FLR</code> or <code>$SGB</code> tokens using the Flare Portal. First, wrap your tokens, and then delegate them.</p>"},{"location":"user/wallets/safepal-s1-wallet/","title":"SafePal S1 Wallet","text":"<p>SafePal S1 is a noncustodial hardware wallet that is considered one of the most secure ways to manage your crypto assets.</p>"},{"location":"user/wallets/safepal-s1-wallet/#getting-started","title":"Getting Started","text":"<p>Use of a SafePal S1 hardware wallet requires syncing the device with the mobile app. A step by step unboxing guide to initialize a new device/wallet, or import an existing one from a recovery phrase, can be found here: https://safepalsupport.zendesk.com/hc/en-us/articles/360046051752-How-to-Set-Up-a-S1-Hardware-Wallet.</p>"},{"location":"user/wallets/safepal-s1-wallet/#adding-flare-tokens","title":"Adding Flare Tokens","text":"<p>After you set up your wallet, add the native tokens <code>$FLR</code> and <code>$SGB</code> and the wrapped token <code>$WFLR</code> to your listed assets.</p> <p>Tip</p> <p>SafePal currently does not support the addition of wrapped Songbird (<code>$WSGB</code>) to wallets.</p> <ol> <li>Ensure the SafePal S1 is updated with the latest firmware, version V1.0.32 or later.</li> <li>Login to your SafePal mobile app and have your S1 device turned on and unlocked.</li> <li>Scroll to the bottom of your listed assets in the mobile app, and click Manage Coins.</li> <li>Click the Enter token or token contract address field.    The Search window is displayed.</li> <li> <p>Complete the following steps to add Flare and Songbird tokens to your wallet:</p> FlareSongbird <ol> <li>Scroll through the list of networks, and select Flare.</li> <li>In the Enter token or token contract address field, search for <code>Flare</code>.</li> <li>Click the plus sign (+) displayed beside FLR (Flare).     FLR (Flare) added to your list of assets, and the homepage is displayed.</li> <li>Scroll to the bottom of your listed assets in the mobile app, and click Manage Coins.</li> <li>Select Flare  from the list of networks again, and search for <code>Wrapped Flare</code>.</li> <li>Click the plus sign (+) displayed beside WFLR (Flare).     WFLR (Flare) is added to your list of assets on the homepage.</li> </ol> <ol> <li> <p>In the Enter token or token contract address field, search for <code>Songbird</code>.     A list of Songbird tokens on various blockchains is displayed.</p> <p>Tip</p> <p>Ignore all Songbird tokens categorized as BEP-20 and ERC-20.</p> </li> <li> <p>Click the plus sign (+) for this SGB (Songbird) token with the logo:</p> <p></p> <p>SGB (Songbird) is added to your list of assets on the homepage.</p> </li> </ol> </li> </ol>"},{"location":"user/wallets/safepal-s1-wallet/#wrap-and-delegate","title":"Wrap and Delegate","text":"<p>When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards.</p> <p>You can use the SafePal mobile app to wrap and delegate your tokens:</p> <ol> <li>Open the SafePal mobile app and navigate to the built-in web browser by clicking the four squares at the bottom middle of the screen.</li> <li> <p>Enter the address of the website or dapp you wish to use to wrap and delegate in the search bar at the top of the screen.</p> <p>Info</p> <p>These dapps are usually created by FTSO data providers, but some of them allow you to choose a different data provider to delegate to.  Take a look at flaremetrics.io and pick the one you prefer.</p> </li> <li> <p>After copying and pasting the address, click the drop-down menu to the right of the search tab.</p> </li> <li>Scroll down, select the Flare or Songbird networks, and click Go.</li> <li>A pop-up will appear notifying that you are being redirected to a third-party dapp. Press Confirm.</li> </ol> <p>Other data providers host similar websites or dapps for wrapping and delegation. See the full list of signal providers on Songbird at https://flaremetrics.io/.</p> <p>Alternatively, wrap and delegate your <code>$FLR</code> or <code>$SGB</code> tokens using the Flare Portal. First, wrap your tokens, and then delegate them.</p>"}]}